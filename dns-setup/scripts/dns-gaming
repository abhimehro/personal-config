#!/usr/bin/env bash
set -Eeuo pipefail

MODE="gaming"
PROFILE_ID="1igcvpwtsfg"
LOG_FILE="/var/log/ctrld-${MODE}.log"
PID_FILE="/var/run/ctrld.pid"
WAIT_SECS=10

die() { echo "Error: $*" >&2; exit 1; }
log() { echo "[$(date '+%F %T')] $*"; }

require_root() {
  if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
    die "Run with sudo/root: sudo $0"
  fi
}

find_ctrld() {
  if CTRLD_BIN="$(command -v ctrld 2>/dev/null)"; then :
  elif [[ -x /opt/homebrew/bin/ctrld ]]; then CTRLD_BIN=/opt/homebrew/bin/ctrld
  elif [[ -x /usr/local/bin/ctrld ]]; then CTRLD_BIN=/usr/local/bin/ctrld
  else die "ctrld binary not found in PATH (/opt/homebrew/bin or /usr/local/bin)."
  fi
}

stop_ctrld() {
  if command -v brew >/dev/null 2>&1; then
    brew services stop ctrld >/dev/null 2>&1 || true
  fi

  if [[ -f "$PID_FILE" ]]; then
    local pid; pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    if [[ -n "${pid:-}" ]] && kill -0 "$pid" 2>/dev/null; then
      kill "$pid" || true
      for _ in $(seq 1 "$WAIT_SECS"); do
        kill -0 "$pid" 2>/dev/null || break
        sleep 1
      done
      if kill -0 "$pid" 2>/dev/null; then
        echo "ctrld (pid $pid) did not exit; sending SIGKILL..."
        kill -9 "$pid" || true
      fi
    fi
    rm -f "$PID_FILE"
  fi

  pkill -f "ctrld run" >/dev/null 2>&1 || true

  local pids
  pids="$(lsof -nP -iTCP:53 -sTCP:LISTEN -t 2>/dev/null || true)"
  pids+=" $(lsof -nP -iUDP:53 -t 2>/dev/null || true)"
  for p in $pids; do
    if ps -o comm= -p "$p" | grep -vq ctrld; then
      echo "Warning: PID $p is listening on :53 (not ctrld). This may conflict."
      ps -o pid,comm -p "$p" || true
    fi
  done
}

start_ctrld() {
  find_ctrld
  touch "$LOG_FILE"; chmod 640 "$LOG_FILE"
  
  # Use Control D with profile-specific DoH endpoint
  local cmd=( "$CTRLD_BIN" run --cd "$PROFILE_ID" --listen "127.0.0.1:53" --primary_upstream "https://dns.controld.com/1igcvpwtsfg" )
  
  nohup "${cmd[@]}" >> "$LOG_FILE" 2>&1 &
  echo $! > "$PID_FILE"
  sleep 2
}

set_dns_local() {
  local services
  services="$(networksetup -listallnetworkservices 2>/dev/null | tail -n +2 | sed 's/^\*//')"
  [[ -n "$services" ]] || die "No network services found via networksetup."

  while IFS= read -r svc; do
    svc="$(echo "$svc" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [[ -z "$svc" ]] && continue
    if echo "$svc" | grep -Eiq 'Windscribe|Proton|VPN|Tailscale|ZeroTier|WireGuard|utun|wg|tun'; then
      echo "Skipping VPN/tunnel service: $svc"
      continue
    fi
    if networksetup -setdnsservers "$svc" 127.0.0.1 2>/dev/null; then
      echo "Set DNS for '$svc' to 127.0.0.1"
    else
      echo "Note: Could not set DNS for '$svc' (may be disabled/managed)."
    fi
  done <<< "$services"
}

flush_dns() {
  dscacheutil -flushcache || true
  killall -HUP mDNSResponder || true
  killall mDNSResponderHelper >/dev/null 2>&1 || true
}

verify() {
  echo "Active DNS summary (first 100 lines):"
  scutil --dns | sed -n '1,100p' | sed 's/^/  /'

  # Test basic DNS resolution first
  local basic_test
  basic_test="$(dig +short google.com @127.0.0.1 2>/dev/null | head -1)"
  if [[ -n "$basic_test" ]]; then
    echo "✅ DNS resolution working via 127.0.0.1 (got: $basic_test)"
  else
    echo "❌ DNS resolution failed via 127.0.0.1"
    return 1
  fi

  # Try Control D TXT verification with retry
  local txt attempts=3
  for ((i=1; i<=attempts; i++)); do
    txt="$(dig +short txt test.controld.com @127.0.0.1 2>/dev/null | tr -d '"')"
    if [[ -n "$txt" ]]; then
      echo "Control D TXT: $txt"
      if echo "$txt" | grep -qi "$PROFILE_ID"; then
        echo "✅ Control D profile '$MODE' ($PROFILE_ID) verified active."
      else
        echo "⚠️  Control D responding but profile ID mismatch. Current: $MODE ($PROFILE_ID)"
      fi
      return 0
    fi
    if [[ $i -lt $attempts ]]; then
      echo "Attempt $i/$attempts: TXT verification pending, retrying in 2s..."
      sleep 2
    fi
  done
  
  echo "⚠️  Control D TXT verification timed out (common with VPN bootstrap)"
  echo "   Core DNS resolution is working - profile should be active."
  return 0  # Don't fail the script since basic DNS works
}

windscribe_firewall() {
  if command -v windscribe >/dev/null 2>&1; then
    windscribe firewall on >/dev/null 2>&1 || true
    echo "Windscribe firewall (DNS leak protection) ensured ON (if logged in)."
  else
    echo "Tip: Windscribe CLI not found. In the app, enable Firewall to prevent DNS leaks."
  fi
}

main() {
  require_root
  log "Switching Control D to '$MODE' ($PROFILE_ID)"
  log "Stopping any running ctrld..."
  stop_ctrld
  log "Starting ctrld..."
  start_ctrld
  log "Forcing DNS to 127.0.0.1 on primary interfaces..."
  set_dns_local
  log "Flushing DNS caches..."
  flush_dns
  log "Verifying resolver and Control D profile..."
  verify
  windscribe_firewall
  log "Done."
}

main "$@"