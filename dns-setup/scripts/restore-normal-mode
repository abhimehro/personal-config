#!/bin/bash
# Restore Normal Mode Script - Re-enables Control D DNS filtering
# Returns from gaming mode to normal browsing configuration

set -Eeuo pipefail
IFS=$' \n\t'

# Ensure UTF-8 output for emojis/checkmarks
export LC_ALL=en_US.UTF-8 2>/dev/null || export LC_ALL=C
export LANG=en_US.UTF-8 2>/dev/null || export LANG=C

# Script metadata
readonly SCRIPT_NAME="restore-normal-mode"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly CONFIG_FILE="/Users/abhimehrotra/Documents/dev/personal-config/dns-setup/config.env"

# Default configuration
LOG_DIR="$HOME/Library/Logs/dns-mode"
BACKUP_DIR="/Users/abhimehrotra/Documents/dev/personal-config/dns-setup/backups"
CONTROLD_LABELS="ctrld com.controld.maintenance"
CONTROLD_PLISTS="/Library/LaunchDaemons/ctrld.plist /Library/LaunchDaemons/com.controld.maintenance.plist"
FORCE_SERVICES=""
CONTROL_D_DNS_SERVERS=""

# Command line options
DRY_RUN=false
VERBOSE=false
BACKUP_ID=""

# Load configuration if available
load_config() {
    [[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"
}

# Ensure running as root
ensure_root() {
    if [[ $EUID -ne 0 ]]; then
        exec sudo -E "$0" "$@"
    fi
}

# Logging functions with UTF-8 safe emojis
setup_logging() {
    mkdir -p "$LOG_DIR"
    readonly LOG_FILE="$LOG_DIR/${SCRIPT_NAME}-$(date +%F).log"
    exec > >(tee -a "$LOG_FILE") 2>&1
}

success() { 
    if [[ "$LC_ALL" =~ UTF-8|utf8 ]]; then
        printf "âœ… %s\n" "$*" 
    else
        printf "[OK] %s\n" "$*"
    fi
}

info() { 
    if [[ "$LC_ALL" =~ UTF-8|utf8 ]]; then
        printf "â„¹ï¸  %s\n" "$*"
    else
        printf "[INFO] %s\n" "$*"
    fi
}

warn() { 
    if [[ "$LC_ALL" =~ UTF-8|utf8 ]]; then
        printf "âš ï¸  %s\n" "$*" >&2
    else
        printf "[WARN] %s\n" "$*" >&2
    fi
}

error() { 
    if [[ "$LC_ALL" =~ UTF-8|utf8 ]]; then
        printf "âŒ %s\n" "$*" >&2
    else
        printf "[ERROR] %s\n" "$*" >&2
    fi
}

die() {
    error "$@"
    exit 1
}

# Get active network services (same as gaming-mode)
get_network_services() {
    local services=()
    
    # Use forced services if configured
    if [[ -n "$FORCE_SERVICES" ]]; then
        read -ra services <<< "$FORCE_SERVICES"
        printf '%s\n' "${services[@]}"
        return
    fi
    
    # Auto-detect active network services
    while IFS= read -r service; do
        [[ "$service" =~ ^\*.*|^An\ asterisk ]] && continue  # Skip disabled services
        [[ -z "$service" ]] && continue
        
        # Check if service is active (has an assigned IP)
        local info
        info=$(networksetup -getinfo "$service" 2>/dev/null || true)
        if echo "$info" | grep -q "IP address:" && ! echo "$info" | grep -q "IP address: none"; then
            services+=("$service")
        fi
    done < <(networksetup -listallnetworkservices 2>/dev/null | tail -n +2)
    
    # If no active services found, fall back to common names
    if [[ ${#services[@]} -eq 0 ]]; then
        for common in "Wi-Fi" "Ethernet" "USB 10/100/1000 LAN"; do
            if networksetup -getinfo "$common" >/dev/null 2>&1; then
                services+=("$common")
            fi
        done
    fi
    
    printf '%s\n' "${services[@]}"
}

# Discover Control D plist files
discover_controld_plists() {
    local plists=()
    
    # Use configured plists if set
    if [[ -n "$CONTROLD_PLISTS" ]]; then
        read -ra plists <<< "$CONTROLD_PLISTS"
    else
        # Auto-discover Control D plist files
        while IFS= read -r plist; do
            [[ -f "$plist" ]] && plists+=("$plist")
        done < <(find /Library/LaunchDaemons /Library/LaunchAgents ~/Library/LaunchAgents \
                      -name "*controld*" -o -name "*ctrld*" 2>/dev/null || true)
    fi
    
    printf '%s\n' "${plists[@]}"
}

# Restore DNS settings from backup or config
restore_dns_settings() {
    info "Restoring DNS settings..."
    
    local restored=false
    local backup_source="$BACKUP_DIR/latest"
    
    # Use specific backup if requested
    if [[ -n "$BACKUP_ID" ]]; then
        backup_source="$BACKUP_DIR/$BACKUP_ID"
        if [[ ! -d "$backup_source" ]]; then
            die "Backup not found: $backup_source"
        fi
    fi
    
    # Restore DNS for each network service
    while IFS= read -r service; do
        [[ -z "$service" ]] && continue
        
        if [[ "$DRY_RUN" == true ]]; then
            info "Would restore DNS for: $service"
            continue
        fi
        
        local dns_servers=()
        
        # Priority 1: Use configured Control D DNS servers
        if [[ -n "$CONTROL_D_DNS_SERVERS" ]]; then
            read -ra dns_servers <<< "$CONTROL_D_DNS_SERVERS"
            [[ "$VERBOSE" == true ]] && info "Using configured Control D DNS for: $service"
        else
            # Priority 2: Use backup
            local safe_name
            safe_name=$(printf %q "$service" | tr ' /' '__')
            local backup_file="$backup_source/services/${safe_name}.dns"
            
            if [[ -f "$backup_file" ]]; then
                local backup_content
                backup_content=$(cat "$backup_file" 2>/dev/null || echo "")
                
                # Parse backup content
                if echo "$backup_content" | grep -q "There aren't any DNS Servers set"; then
                    # Was set to automatic, restore as automatic
                    dns_servers=("Empty")
                elif [[ -n "$backup_content" ]]; then
                    # Had specific DNS servers
                    while IFS= read -r server; do
                        [[ -n "$server" ]] && dns_servers+=("$server")
                    done <<< "$backup_content"
                fi
                [[ "$VERBOSE" == true ]] && info "Using backup DNS for: $service"
            else
                warn "No backup found for: $service, leaving unchanged"
                continue
            fi
        fi
        
        # Apply DNS settings
        if [[ ${#dns_servers[@]} -gt 0 ]]; then
            if networksetup -setdnsservers "$service" "${dns_servers[@]}" 2>/dev/null; then
                # Verify the change
                local current_dns
                current_dns=$(networksetup -getdnsservers "$service" 2>/dev/null || echo "unknown")
                success "DNS restored for: $service"
                [[ "$VERBOSE" == true ]] && info "  Current DNS: $current_dns"
                restored=true
            else
                warn "Could not restore DNS for service: $service"
            fi
        fi
    done < <(get_network_services)
    
    if [[ "$restored" == true ]]; then
        success "DNS settings restored"
    else
        warn "No DNS settings were restored"
    fi
}

# Start Control D services
start_controld() {
    info "Starting Control D services..."
    
    local started=false
    
    # Try to start services using discovered plist files
    while IFS= read -r plist; do
        [[ -z "$plist" || ! -f "$plist" ]] && continue
        
        # Extract label from plist filename
        local label
        label=$(basename "$plist" .plist)
        
        if [[ "$DRY_RUN" == true ]]; then
            info "Would start service: $label (from $plist)"
            continue
        fi
        
        # Try system domain
        if launchctl bootstrap system "$plist" 2>/dev/null; then
            success "Bootstrapped system service: $label"
            # Try to enable and start
            if launchctl enable "system/$label" 2>/dev/null && \
               launchctl kickstart -k "system/$label" 2>/dev/null; then
                success "Started system service: $label"
                started=true
            fi
        else
            [[ "$VERBOSE" == true ]] && warn "Could not bootstrap system/$label (may already exist)"
            # Try kickstart anyway
            if launchctl kickstart -k "system/$label" 2>/dev/null; then
                success "Restarted system service: $label"
                started=true
            fi
        fi
        
        # Try user domain (less common for Control D)
        local user_agents_dir="$HOME/Library/LaunchAgents"
        if [[ "$plist" == "$user_agents_dir"* ]]; then
            if launchctl bootstrap "gui/$(id -u)" "$plist" 2>/dev/null; then
                success "Bootstrapped user service: $label"
                if launchctl enable "gui/$(id -u)/$label" 2>/dev/null && \
                   launchctl kickstart -k "gui/$(id -u)/$label" 2>/dev/null; then
                    success "Started user service: $label"
                    started=true
                fi
            fi
        fi
    done < <(discover_controld_plists)
    
    # Fallback: try to open Control D app if services didn't start
    if [[ "$started" == false ]]; then
        if [[ "$DRY_RUN" == false ]] && command -v open >/dev/null 2>&1; then
            # Try common Control D app names
            for app in "ControlD" "Control D" "ctrld"; do
                if open -ga "$app" 2>/dev/null; then
                    info "Opened Control D application: $app"
                    started=true
                    break
                fi
            done
        fi
        
        if [[ "$started" == false ]]; then
            warn "Could not start Control D services automatically"
            warn "You may need to start Control D manually"
        fi
    else
        success "Control D services started"
    fi
}

# Flush DNS caches (same as gaming-mode)
flush_dns_cache() {
    info "Clearing DNS cache..."
    
    if [[ "$DRY_RUN" == true ]]; then
        info "Would flush DNS caches"
        return
    fi
    
    # Multiple cache clearing methods for macOS
    dscacheutil -flushcache 2>/dev/null || true
    killall -HUP mDNSResponder 2>/dev/null || true  
    killall mDNSResponderHelper 2>/dev/null || true
    
    success "DNS cache cleared"
}

# Health check to verify Control D is working
health_check() {
    info "Performing health checks..."
    
    if [[ "$DRY_RUN" == true ]]; then
        info "Would perform health checks"
        return
    fi
    
    local healthy=true
    
    # Check if Control D processes are running
    if pgrep -f "ctrld" >/dev/null 2>&1; then
        local pid
        pid=$(pgrep -f "ctrld" | head -1)
        success "Control D process running (PID: $pid)"
    else
        warn "Control D process not detected"
        healthy=false
    fi
    
    # Test DNS resolution
    info "Testing DNS resolution..."
    if command -v host >/dev/null 2>&1; then
        local test_result
        test_result=$(timeout 10s host google.com 2>/dev/null | head -1 || echo "failed")
        if echo "$test_result" | grep -q "has address"; then
            success "DNS resolution working: $test_result"
        else
            warn "DNS resolution test failed"
            healthy=false
        fi
    elif command -v dig >/dev/null 2>&1; then
        local test_result
        test_result=$(timeout 10s dig +short google.com 2>/dev/null | head -1 || echo "failed")
        if [[ -n "$test_result" && "$test_result" != "failed" ]]; then
            success "DNS resolution working: google.com -> $test_result"
        else
            warn "DNS resolution test failed"
            healthy=false
        fi
    else
        warn "Cannot test DNS resolution (no host or dig command available)"
    fi
    
    # Check DNS configuration
    if command -v scutil >/dev/null 2>&1; then
        info "Checking DNS configuration..."
        local dns_info
        dns_info=$(scutil --dns 2>/dev/null | grep -A 2 "resolver #1" | grep nameserver || echo "unknown")
        if [[ -n "$dns_info" && "$dns_info" != "unknown" ]]; then
            info "Primary DNS: $dns_info"
        fi
    fi
    
    if [[ "$healthy" == true ]]; then
        success "Health checks passed"
    else
        warn "Some health checks failed - Control D may need manual attention"
        return 1
    fi
}

# Display usage information
usage() {
    cat << EOF
Restore Normal Mode Script - Re-enables Control D DNS filtering
Returns from gaming mode to normal browsing configuration

Usage: $0 [options]

Options:
    -h, --help                    Show this help message
    -n, --dry-run                Show what would be done without making changes
    -v, --verbose                Enable verbose logging
    -b, --backup-id ID           Restore from specific backup ID
    
This script must be run with sudo privileges or will self-elevate.

Process:
  1. Restore DNS settings from backup or configuration
  2. Start Control D services (re-enables filtering & DoH3)
  3. Clear DNS cache (fresh start)
  4. Perform health checks (verify functionality)

To enter gaming mode: sudo gaming-mode
EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -b|--backup-id)
                [[ -n "${2:-}" ]] || die "Option $1 requires an argument"
                BACKUP_ID="$2"
                shift 2
                ;;
            *)
                die "Unknown option: $1. Use -h for help."
                ;;
        esac
    done
}

# Main execution
main() {
    parse_args "$@"
    load_config
    ensure_root "$@"
    setup_logging
    
    # Print header
    echo ""
    if [[ "$LC_ALL" =~ UTF-8|utf8 ]]; then
        echo "ðŸ›¡ï¸  NORMAL MODE RESTORED"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    else
        echo "NORMAL MODE RESTORED"
        echo "========================================"
    fi
    
    if [[ "$DRY_RUN" == true ]]; then
        info "DRY RUN MODE - No changes will be made"
        echo ""
    fi
    
    # Execute main steps
    restore_dns_settings
    start_controld
    flush_dns_cache
    
    # Health check (non-fatal)
    if ! health_check; then
        warn "Health checks indicated potential issues"
    fi
    
    echo ""
    success "Normal mode restored successfully!"
    if [[ "$LC_ALL" =~ UTF-8|utf8 ]]; then
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    else
        echo "========================================"
    fi
    info "Control D DNS filtering and protection are now active"
    info "To enter gaming mode: sudo gaming-mode"
    echo ""
}

# Run main function with all arguments
main "$@"
