{
  "version": 3,
  "sources": ["../../src/tools/create-relations.ts", "../../src/knowledge-graph-manager.ts"],
  "sourcesContent": ["import { knowledgeGraphManager } from \"../knowledge-graph-manager\";\n\n/**\n * Create relations between existing entities in the knowledge graph.\n */\nexport default async function (input: {\n  /**\n   * A list of new relations to create between entities.\n   */\n  relations: {\n    /**\n     * The source entity name.\n     */\n    from: string;\n    /**\n     * The target entity name.\n     */\n    to: string;\n    /**\n     * The relationship type (in active voice).\n     */\n    relationType: string;\n  }[];\n}) {\n  // Your tool code here\n  return knowledgeGraphManager.createRelations(input.relations);\n}\n", "// Modified from Anthropic's modelcontextprotocol/servers example for Memory\n// https://github.com/modelcontextprotocol/servers/blob/main/src/memory/index.ts\n\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { environment } from \"@raycast/api\";\n\n// If MEMORY_FILE_PATH is just a filename, put it in the same directory as the script\nconst MEMORY_FILE_PATH = path.join(environment.supportPath, \"memory.json\");\n\n// Ensure the memory file exists\n(async () => {\n  try {\n    await fs.access(MEMORY_FILE_PATH);\n  } catch (error) {\n    if (error instanceof Error && \"code\" in error && (error as { code?: string }).code === \"ENOENT\") {\n      await fs.writeFile(MEMORY_FILE_PATH, \"\");\n    } else {\n      throw error;\n    }\n  }\n})();\n\n// We are storing our memory using entities, relations, and observations in a graph structure\ninterface Entity {\n  name: string;\n  entityType: string;\n  observations: string[];\n}\n\ninterface Relation {\n  from: string;\n  to: string;\n  relationType: string;\n}\n\ninterface KnowledgeGraph {\n  entities: Entity[];\n  relations: Relation[];\n}\n\n// The KnowledgeGraphManager class contains all operations to interact with the knowledge graph\nclass KnowledgeGraphManager {\n  private async loadGraph(): Promise<KnowledgeGraph> {\n    try {\n      const data = await fs.readFile(MEMORY_FILE_PATH, \"utf-8\");\n      const lines = data.split(\"\\n\").filter((line) => line.trim() !== \"\");\n      return lines.reduce(\n        (graph: KnowledgeGraph, line) => {\n          const item = JSON.parse(line);\n          if (item.type === \"entity\") graph.entities.push(item as Entity);\n          if (item.type === \"relation\") graph.relations.push(item as Relation);\n          return graph;\n        },\n        { entities: [], relations: [] },\n      );\n    } catch (error) {\n      if (error instanceof Error && \"code\" in error && (error as { code?: string }).code === \"ENOENT\") {\n        return { entities: [], relations: [] };\n      }\n      throw error;\n    }\n  }\n\n  private async saveGraph(graph: KnowledgeGraph): Promise<void> {\n    console.log(graph);\n    const lines = [\n      ...graph.entities.map((e) => JSON.stringify({ type: \"entity\", ...e })),\n      ...graph.relations.map((r) => JSON.stringify({ type: \"relation\", ...r })),\n    ];\n    await fs.writeFile(MEMORY_FILE_PATH, lines.join(\"\\n\"));\n  }\n\n  async createEntities(entities: Entity[]): Promise<Entity[]> {\n    const graph = await this.loadGraph();\n    const newEntities = entities.filter(\n      (e) => !graph.entities.some((existingEntity) => existingEntity.name === e.name),\n    );\n    graph.entities.push(...newEntities);\n    await this.saveGraph(graph);\n    return newEntities;\n  }\n\n  async createRelations(relations: Relation[]): Promise<Relation[]> {\n    const graph = await this.loadGraph();\n    const newRelations = relations.filter(\n      (r) =>\n        !graph.relations.some(\n          (existingRelation) =>\n            existingRelation.from === r.from &&\n            existingRelation.to === r.to &&\n            existingRelation.relationType === r.relationType,\n        ),\n    );\n    graph.relations.push(...newRelations);\n    await this.saveGraph(graph);\n    return newRelations;\n  }\n\n  async addObservations(\n    observations: { entityName: string; contents: string[] }[],\n  ): Promise<{ entityName: string; addedObservations: string[] }[]> {\n    const graph = await this.loadGraph();\n    const results = observations.map((o) => {\n      const entity = graph.entities.find((e) => e.name === o.entityName);\n      if (!entity) {\n        throw new Error(`Entity with name ${o.entityName} not found`);\n      }\n      const newObservations = o.contents.filter((content) => !entity.observations.includes(content));\n      entity.observations.push(...newObservations);\n      return { entityName: o.entityName, addedObservations: newObservations };\n    });\n    await this.saveGraph(graph);\n    return results;\n  }\n\n  async deleteEntities(entityNames: string[]): Promise<void> {\n    const graph = await this.loadGraph();\n    graph.entities = graph.entities.filter((e) => !entityNames.includes(e.name));\n    graph.relations = graph.relations.filter((r) => !entityNames.includes(r.from) && !entityNames.includes(r.to));\n    await this.saveGraph(graph);\n  }\n\n  async deleteObservations(deletions: { entityName: string; observations: string[] }[]): Promise<void> {\n    const graph = await this.loadGraph();\n    deletions.forEach((d) => {\n      const entity = graph.entities.find((e) => e.name === d.entityName);\n      if (entity) {\n        entity.observations = entity.observations.filter((o) => !d.observations.includes(o));\n      }\n    });\n    await this.saveGraph(graph);\n  }\n\n  async deleteRelations(relations: Relation[]): Promise<void> {\n    const graph = await this.loadGraph();\n    graph.relations = graph.relations.filter(\n      (r) =>\n        !relations.some(\n          (delRelation) =>\n            r.from === delRelation.from && r.to === delRelation.to && r.relationType === delRelation.relationType,\n        ),\n    );\n    await this.saveGraph(graph);\n  }\n\n  async readGraph(): Promise<KnowledgeGraph> {\n    return this.loadGraph();\n  }\n\n  // Very basic search function\n  async searchNodes(query: string): Promise<KnowledgeGraph> {\n    const graph = await this.loadGraph();\n\n    // Filter entities\n    const filteredEntities = graph.entities.filter(\n      (e) =>\n        e.name.toLowerCase().includes(query.toLowerCase()) ||\n        e.entityType.toLowerCase().includes(query.toLowerCase()) ||\n        e.observations.some((o) => o.toLowerCase().includes(query.toLowerCase())),\n    );\n\n    // Create a Set of filtered entity names for quick lookup\n    const filteredEntityNames = new Set(filteredEntities.map((e) => e.name));\n\n    // Filter relations to only include those between filtered entities\n    const filteredRelations = graph.relations.filter(\n      (r) => filteredEntityNames.has(r.from) && filteredEntityNames.has(r.to),\n    );\n\n    const filteredGraph: KnowledgeGraph = {\n      entities: filteredEntities,\n      relations: filteredRelations,\n    };\n\n    return filteredGraph;\n  }\n\n  async openNodes(names: string[]): Promise<KnowledgeGraph> {\n    const graph = await this.loadGraph();\n\n    // Filter entities\n    const filteredEntities = graph.entities.filter((e) => names.includes(e.name));\n\n    // Create a Set of filtered entity names for quick lookup\n    const filteredEntityNames = new Set(filteredEntities.map((e) => e.name));\n\n    // Filter relations to only include those between filtered entities\n    const filteredRelations = graph.relations.filter(\n      (r) => filteredEntityNames.has(r.from) && filteredEntityNames.has(r.to),\n    );\n\n    const filteredGraph: KnowledgeGraph = {\n      entities: filteredEntities,\n      relations: filteredRelations,\n    };\n\n    return filteredGraph;\n  }\n}\n\nexport const knowledgeGraphManager = new KnowledgeGraphManager();\n"],
  "mappings": "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",
  "names": ["create_relations_exports", "__export", "create_relations_default", "__toCommonJS", "import_fs", "import_path", "import_api", "MEMORY_FILE_PATH", "path", "fs", "error", "KnowledgeGraphManager", "line", "graph", "item", "lines", "e", "r", "entities", "newEntities", "existingEntity", "relations", "newRelations", "existingRelation", "observations", "results", "o", "entity", "newObservations", "content", "entityNames", "deletions", "d", "delRelation", "query", "filteredEntities", "filteredEntityNames", "filteredRelations", "names", "knowledgeGraphManager", "create_relations_default", "input", "knowledgeGraphManager"]
}
