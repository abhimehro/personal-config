{
  "version": 3,
  "sources": ["../src/history.tsx", "../src/classes/history.ts", "../src/classes/dictionary.ts"],
  "sourcesContent": ["import {\n  List,\n  ActionPanel,\n  Action,\n  Icon,\n  Alert,\n  showToast,\n  confirmAlert,\n  Toast,\n  launchCommand,\n  LaunchType,\n  Keyboard,\n} from \"@raycast/api\";\nimport { JSX, useEffect, useState } from \"react\";\nimport History, { HistoryEntry } from \"./classes/history\";\nimport Dictionary from \"./classes/dictionary\";\n\nexport default function Command(): JSX.Element {\n  const [history, setHistory] = useState<HistoryEntry[]>([]);\n  const [searchText, setSearchText] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n  const [selectedLanguage, setSelectedLanguage] = useState<string>(\"All\");\n\n  useEffect(() => {\n    const fetchHistory = async () => {\n      const entries: HistoryEntry[] = await History.getEntries();\n      setHistory(entries);\n      setLoading(false);\n    };\n    fetchHistory();\n  }, []);\n\n  const langs: string[] = Array.from(new Set(history.map((h) => h.language)));\n\n  return (\n    <List\n      isLoading={loading}\n      searchText={searchText}\n      onSearchTextChange={setSearchText}\n      searchBarPlaceholder=\"Filter history entries by word...\"\n      filtering={true}\n      searchBarAccessory={\n        <List.Dropdown tooltip=\"Filter by language\" storeValue={true} onChange={setSelectedLanguage} defaultValue=\"All\">\n          <List.Dropdown.Item title=\"All\" value=\"All\" />\n          {langs.map((lang: string) => (\n            <List.Dropdown.Item key={lang} title={Dictionary.capitalize(lang)} value={lang} />\n          ))}\n        </List.Dropdown>\n      }\n    >\n      {!history.length ? (\n        <List.EmptyView title=\"No history\" />\n      ) : (\n        Object.entries(\n          history.reduce(\n            (\n              acc: {\n                [lang: string]: { word: string; epoch: number }[];\n              },\n              h: HistoryEntry,\n            ) => {\n              if (!acc[`${h.language}-${h.languageCode}`]) acc[`${h.language}-${h.languageCode}`] = [];\n              acc[`${h.language}-${h.languageCode}`].push({ word: h.word, epoch: h.epoch });\n              return acc;\n            },\n            {},\n          ),\n        )\n          .filter(([lang]) => selectedLanguage === \"All\" || lang === selectedLanguage)\n          .sort(([langA], [langB]) => langA.localeCompare(langB))\n          .map(([langString, wordInfo]: [string, { word: string; epoch: number }[]]) => {\n            const [lang, langCode] = langString.split(\"-\");\n            return (\n              <List.Section key={lang} title={`${Dictionary.capitalize(lang)} (${wordInfo.length})`}>\n                {wordInfo\n                  .filter(({ word }) => word.toLowerCase().includes(searchText.toLowerCase()))\n                  .map(({ word, epoch }) => (\n                    <List.Item\n                      key={word}\n                      title={word}\n                      accessories={[{ icon: Icon.Clock, date: new Date(epoch) }]}\n                      actions={\n                        <ActionPanel>\n                          <Action\n                            title=\"Search Word\"\n                            icon={Icon.MagnifyingGlass}\n                            shortcut={Keyboard.Shortcut.Common.Open}\n                            onAction={async (): Promise<void> => {\n                              try {\n                                await launchCommand({\n                                  name: \"search\",\n                                  type: LaunchType.UserInitiated,\n                                  arguments: {\n                                    language: langCode,\n                                    word: word,\n                                  },\n                                });\n                              } catch {\n                                await showToast({\n                                  style: Toast.Style.Failure,\n                                  title: \"Failed to search word\",\n                                  message: `There was an error searching for \"${word}\" (${Dictionary.capitalize(lang)})`,\n                                });\n                              }\n                            }}\n                          />\n                          <ActionPanel.Section>\n                            <Action\n                              title=\"Remove from History\"\n                              icon={Icon.Trash}\n                              style={Action.Style.Destructive}\n                              shortcut={Keyboard.Shortcut.Common.Remove}\n                              onAction={async (): Promise<void> => {\n                                const options: Alert.Options = {\n                                  title: \"Remove from History\",\n                                  message: `\"${word}\" (${Dictionary.capitalize(lang)}) will be removed from your history`,\n                                  primaryAction: {\n                                    title: \"Delete\",\n                                    style: Alert.ActionStyle.Destructive,\n                                    onAction: async (): Promise<void> => {\n                                      const success: boolean = await History.removeEntry(lang, word);\n\n                                      if (success) {\n                                        const entries: HistoryEntry[] = await History.getEntries();\n                                        setHistory(entries);\n\n                                        await showToast({\n                                          style: Toast.Style.Success,\n                                          title: \"Removed from History\",\n                                          message: `\"${word}\" (${Dictionary.capitalize(lang)}) has been removed from your history`,\n                                        });\n                                      } else {\n                                        await showToast({\n                                          style: Toast.Style.Failure,\n                                          title: \"Failed to remove from History\",\n                                          message: `\"${word}\" (${Dictionary.capitalize(lang)}) could not be found in your history`,\n                                        });\n                                      }\n                                    },\n                                  },\n                                };\n\n                                await confirmAlert(options);\n                              }}\n                            />\n                            <Action\n                              title=\"Clear History\"\n                              icon={Icon.Trash}\n                              style={Action.Style.Destructive}\n                              shortcut={Keyboard.Shortcut.Common.RemoveAll}\n                              onAction={async (): Promise<void> => {\n                                const options: Alert.Options = {\n                                  title: \"Clear History\",\n                                  message: `All history will be removed`,\n                                  primaryAction: {\n                                    title: \"Delete\",\n                                    style: Alert.ActionStyle.Destructive,\n                                    onAction: async (): Promise<void> => {\n                                      const success: boolean = await History.removeAll();\n\n                                      if (success) {\n                                        setHistory([]);\n                                        await showToast({\n                                          style: Toast.Style.Success,\n                                          title: \"History Cleared\",\n                                          message: `All history has been removed`,\n                                        });\n                                      } else {\n                                        await showToast({\n                                          style: Toast.Style.Failure,\n                                          title: \"Failed to clear history\",\n                                          message: `Could not remove all history`,\n                                        });\n                                      }\n                                    },\n                                  },\n                                };\n\n                                await confirmAlert(options);\n                              }}\n                            />\n                          </ActionPanel.Section>\n                        </ActionPanel>\n                      }\n                    />\n                  ))}\n              </List.Section>\n            );\n          })\n      )}\n    </List>\n  );\n}\n", "import { LocalStorage } from \"@raycast/api\";\n\ninterface HistoryEntry {\n  language: string;\n  languageCode: string;\n  word: string;\n  epoch: number;\n}\n\nclass History {\n  private static key: string = \"history\";\n  private static maxEntries: number = 50;\n\n  /**\n   * Retrieves all history entries from local storage.\n   *\n   * @returns {Promise<HistoryEntry[]>} A promise that resolves to an array of history entries.\n   */\n  public static async getEntries(): Promise<HistoryEntry[]> {\n    const data = await LocalStorage.getItem<string>(History.key);\n    return data ? (JSON.parse(data) as HistoryEntry[]) : [];\n  }\n\n  /**\n   * Adds a new entry to the history list if it does not already exist.\n   *\n   * @param {string} language The language of the word to add.\n   * @param {string} languageCode The language code of the word to add.\n   * @param {string} word The word to add to the history.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async addEntry(language: string, languageCode: string, word: string): Promise<boolean> {\n    let result: boolean = true;\n    try {\n      const history: HistoryEntry[] = await this.getEntries();\n      const exists: boolean = await History.exist(language.toLowerCase(), word);\n\n      if (!exists) {\n        history.push({\n          language: language.trim().toLowerCase().replace(\"  \", \" \"),\n          languageCode: languageCode.toLowerCase(),\n          word: word,\n          epoch: Date.now(),\n        });\n        history.sort((a: HistoryEntry, b: HistoryEntry) => b.epoch - a.epoch);\n        LocalStorage.setItem(History.key, JSON.stringify(history.slice(0, History.maxEntries)));\n      } else {\n        result = true;\n      }\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Removes an entry matching the specified language and word from the history.\n   *\n   * @param {string} language The language of the entry to remove.\n   * @param {string} word The word of the entry to remove.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async removeEntry(language: string, word: string): Promise<boolean> {\n    let result: boolean = true;\n    try {\n      const history: HistoryEntry[] = await this.getEntries();\n      const updatedHistory = history.filter(\n        (he: HistoryEntry) =>\n          he.language.toLowerCase() !== language.toLowerCase() || he.word.toLowerCase() !== word.toLowerCase(),\n      );\n      LocalStorage.setItem(History.key, JSON.stringify(updatedHistory));\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Removes all entries in the history from local storage.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async removeAll(): Promise<boolean> {\n    let result = true;\n    try {\n      await LocalStorage.removeItem(History.key);\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Determines whether a given word in a specified language is in the last 10 history entries.\n   *\n   * @param {string} language The language of the word to check.\n   * @param {string} word The word to check for in the history.\n   *\n   * @returns {boolean} Wether the word and language combination is in the last 10 history entries.\n   */\n  public static async exist(language: string, word: string): Promise<boolean> {\n    const history: HistoryEntry[] = await this.getEntries();\n    const lastTen: HistoryEntry[] = history.slice(-10);\n    return lastTen.some((fav: HistoryEntry) => fav.language === language && fav.word === word);\n  }\n}\n\nexport default History;\nexport type { HistoryEntry };\n", "import { Cache } from \"@raycast/api\";\n\ninterface Sense {\n  definition: string;\n  tags: string[];\n  examples: string[];\n  quotes: {\n    text: string;\n    reference: string;\n  }[];\n  synonyms: string[];\n  antonyms: string[];\n  translations: string[];\n  subsenses: Sense[];\n  markdown?: string;\n}\n\ninterface Entry {\n  language: {\n    code: string;\n    name: string;\n  };\n  partOfSpeech: string;\n  pronunciations: {\n    type: string;\n    text: string;\n    tags: string[];\n  }[];\n  forms: {\n    word: string;\n    tags: string[];\n  }[];\n  senses: Sense[];\n}\n\ninterface DictionaryResponse {\n  word: string;\n  entries: Entry[];\n  source: {\n    url: string;\n    license: {\n      name: string;\n      url: string;\n    };\n  };\n}\n\ninterface GroupedEntry {\n  [partOfSpeech: string]: Entry;\n}\n\nclass Dictionary {\n  private static cache: Cache = new Cache();\n\n  private url: string = \"https://freedictionaryapi.com/api/v1/entries\";\n  private urlWord: string = \"\";\n\n  private language: string = \"\";\n  private word: string = \"\";\n\n  private languageCode: string = \"\";\n  private wordQuery: string = \"\";\n\n  public get getURL(): string {\n    return this.urlWord;\n  }\n  public get getLanguage(): string {\n    return this.language;\n  }\n\n  constructor(languageCode: string, wordQuery: string) {\n    this.languageCode = languageCode;\n    this.wordQuery = wordQuery;\n  }\n\n  /**\n   * Capitalizes the first letter of the input string and lowercases the rest.\n   *\n   * @param {string} text The input string to capitalize.\n   * @returns {string} The capitalized string.\n   */\n  public static capitalize(text: string): string {\n    return text.slice(0, 1).toUpperCase() + text.slice(1).toLowerCase();\n  }\n\n  public async getEntry(): Promise<GroupedEntry | undefined> {\n    let result: GroupedEntry | undefined = {};\n\n    try {\n      const ge: GroupedEntry | undefined = this.checkCache();\n\n      if (!ge || !Object.keys(ge).length) {\n        result = await this.fetchEntry();\n      } else {\n        result = ge;\n      }\n    } catch (err) {\n      console.error(err);\n      result = await this.fetchEntry();\n    }\n\n    return result;\n  }\n\n  /**\n   * Checks the cache for a previously fetched dictionary entry.\n   *\n   * @returns {GroupedEntry | undefined} The cached grouped entry if it exists. If there is no cached entry, it returns an empty object. If there is an error accessing the cache, it returns `undefined`.\n   */\n  private checkCache(): GroupedEntry | undefined {\n    let result: GroupedEntry | undefined = {};\n\n    try {\n      const cachedResult: string | undefined = Dictionary.cache.get(`${this.languageCode}-${this.wordQuery}`);\n\n      if (cachedResult) {\n        const ge: GroupedEntry = JSON.parse(cachedResult);\n\n        this.language = Dictionary.capitalize(ge[Object.keys(ge)?.[0]]?.language?.name || this.languageCode);\n        this.word = ge[Object.keys(ge)?.[0]]?.forms[0]?.word || this.wordQuery;\n\n        result = ge;\n      } else {\n        result = {};\n      }\n    } catch {\n      result = undefined;\n    }\n\n    return result;\n  }\n\n  /**\n   * Fetches a dictionary entry for the specified word and language from the configured URL.\n   * If the fetch is successful, it processes and formats the entry, updating internal properties.\n   *\n   * @returns {Promise<GroupedEntry | undefined>} A promise that resolves to the grouped entry data or an empty object. If there are no definitions, it returns an empty object. If the fetch fails, it returns `undefined`.\n   */\n  private async fetchEntry(): Promise<GroupedEntry | undefined> {\n    let result: GroupedEntry | undefined = {};\n\n    try {\n      const res: Response = await fetch(`${this.url}/${this.languageCode}/${this.wordQuery}`);\n\n      if (res.ok) {\n        const entry: DictionaryResponse = (await res.json()) as DictionaryResponse;\n\n        if (entry.entries.length) {\n          // Updating the word and language to ensure proper formatting\n\n          this.language = Dictionary.capitalize(entry.entries[0]?.language?.name);\n          this.word = entry.word;\n          this.urlWord = entry.source.url.replaceAll(\" \", \"%20\");\n\n          const ge: GroupedEntry = this.groupEntries(entry);\n\n          try {\n            Dictionary.cache.set(`${this.languageCode}-${this.wordQuery}`, JSON.stringify(ge));\n          } catch (error) {\n            console.error(\"Failed to cache dictionary entry:\", error);\n          }\n\n          result = ge;\n        }\n      } else {\n        result = undefined;\n      }\n    } catch {\n      result = undefined;\n    }\n\n    return result;\n  }\n\n  /**\n   * Groups dictionary entries by their part of speech and enriches each sense with markdown content.\n   *\n   * Iterates through the provided dictionary response, organizing entries into a structure keyed by part of speech.\n   * For each entry, it initializes the group if necessary, collects pronunciations and forms, and generates markdown\n   * for each sense, including title, pronunciations, forms, and rendered sense details.\n   *\n   * @param {DictionaryResponse} entryThe dictionary response containing entries to be grouped.\n   * @returns {GroupedEntry} An object mapping each part of speech to its grouped entries, including enriched senses.\n   */\n  private groupEntries(entry: DictionaryResponse): GroupedEntry {\n    const groupedEntries: GroupedEntry = {};\n\n    let title: string = \"\";\n    let pronunciations: string = \"\";\n    let forms: string = \"\";\n\n    // Group senses by parts of speech\n\n    entry.entries.forEach((e: Entry) => {\n      if (!groupedEntries[e.partOfSpeech]) {\n        // Initialize the part of speech entry\n\n        groupedEntries[e.partOfSpeech] = {\n          language: e.language,\n          partOfSpeech: e.partOfSpeech,\n          pronunciations: [],\n          forms: [],\n          senses: [],\n        };\n\n        // Parts of Speech\n\n        title = `# ${this.word} (_${e.partOfSpeech}_)\\n### Definition:\\n`;\n\n        // Pronunciations\n\n        pronunciations = this.renderPronunciations(e);\n        forms = this.renderForms(e);\n      }\n\n      groupedEntries[e.partOfSpeech].pronunciations.push(...e.pronunciations);\n      groupedEntries[e.partOfSpeech].forms.push(...e.forms);\n      e.senses.forEach((sense: Sense) => {\n        const senseWithMarkdown = {\n          ...sense,\n          markdown: (title + this.renderSenses(sense) + pronunciations + forms).replaceAll(\"..\", \".\"),\n        };\n        groupedEntries[e.partOfSpeech].senses.push(senseWithMarkdown);\n      });\n    });\n\n    return groupedEntries;\n  }\n\n  /**\n   * Renders the pronunciations of a dictionary entry as a Markdown table.\n   * Groups pronunciations by region (tags) and phonetic system type.\n   *\n   * @param {Entry} entry The dictionary entry containing pronunciation data.\n   * @returns {string} Markdown-formatted string representing the pronunciations table,\n   * or an empty string if no pronunciations are available.\n   */\n  private renderPronunciations(entry: Entry): string {\n    if (!entry.pronunciations || !entry.pronunciations.length) return \"\";\n\n    let md = `### Pronunciations\\n`;\n\n    // Group pronunciations by region (tags) and type\n\n    const grouped: Record<string, { type: string; text: string[] }> = {};\n    entry.pronunciations.forEach((p) => {\n      if (p.tags.length) {\n        p.tags.forEach((tag: string) => {\n          if (!grouped[tag]) grouped[tag] = { type: p.type, text: [] };\n          grouped[tag].text.push(p.text);\n        });\n      } else {\n        if (!grouped[\"-\"]) grouped[\"-\"] = { type: p.type, text: [] };\n        grouped[\"-\"].text.push(p.text);\n      }\n    });\n\n    if (!Object.entries(grouped).length) return \"\";\n\n    // Render table of pronunciations\n\n    md += `| Dialect | Pronunciation | Phonetic System | \\n|---|---|---|\\n`;\n\n    Object.entries(grouped).forEach(([region, group]) => {\n      md += `| ${region} | ${group.text.join(\", \")} | ${group.type} |\\n`;\n    });\n\n    md += `\\n\\n`;\n\n    return md;\n  }\n\n  /**\n   * Renders the forms of a dictionary entry as a Markdown string.\n   * For languages with complex conjugation systems, forms are grouped and displayed in tables by mood, tense, number, and person.\n   * For other languages, forms are listed as bullet points.\n   *\n   * @param {Entry} entry The dictionary entry containing forms to render.\n   * @returns {string} A Markdown-formatted string representing the forms of the entry.\n   */\n  private renderForms(entry: Entry): string {\n    if (!entry.forms || !entry.forms.length) return \"\";\n\n    let md = `### Forms\\n`;\n\n    const invalidTags: string[] = [\"inflection-template\", \"table-tags\", \"class\"];\n    const complexConjugationsLanguages: string[] = [\n      \"ca\",\n      \"cs\",\n      \"fr\",\n      \"de\",\n      \"el\",\n      \"hu\",\n      \"it\",\n      \"la\",\n      \"pt\",\n      \"ro\",\n      \"ru\",\n      \"sh\",\n      \"es\",\n      \"nl\",\n    ];\n    const rows: string[] = [];\n\n    // Languages with complex conjugation systems will have their forms grouped by mood, tense, number, and person in tables\n\n    if (complexConjugationsLanguages.includes(this.languageCode)) {\n      const nonfiniteMoods: string[] = [\"gerund\", \"participle\", \"infinitive\"];\n      const moods: string[] = [\"indicative\", \"subjunctive-i\", \"subjunctive-ii\", \"subjunctive\", \"imperative\"];\n      const tenses: string[] = [\n        \"future-i\",\n        \"future-ii\",\n        \"present\",\n        \"imperfect\",\n        \"preterite\",\n        \"future\",\n        \"conditional\",\n        \"perfect\",\n        \"pluperfect\",\n        \"past perfect\",\n        \"future perfect\",\n        \"conditional perfect\",\n      ];\n      const numbers: string[] = [\"singular\", \"plural\"];\n      const persons: string[] = [\"first-person\", \"second-person\", \"third-person\"];\n\n      const grouped: Record<\n        string,\n        Record<string, Record<string, Record<string, { word: string; tags: string[] }[]>>>\n      > = {};\n\n      entry.forms.forEach((f) => {\n        // If the form has no tags, skip it\n\n        if (!f.tags.length) return;\n\n        // If the tags contain any invalid tags, skip this form\n\n        if (f.tags.some((tag) => invalidTags.includes(tag))) return;\n\n        // If the word contains any tense, number, or person keywords, skip this form\n\n        for (const t of tenses) {\n          if (f.word.includes(t.toLowerCase())) return;\n        }\n\n        for (const n of numbers) {\n          if (f.word.includes(n.toLowerCase())) return;\n        }\n\n        for (const p of persons) {\n          if (f.word.includes(p.toLowerCase())) return;\n        }\n\n        // Group the form by mood, tense, number, and person\n\n        const mood: string =\n          moods.find((m) => f.tags.includes(m)) ||\n          (nonfiniteMoods.find((nm) => f.tags.includes(nm)) ? \"non-finite\" : \"indicative\");\n        const tense: string = tenses.find((t) => f.tags.includes(t)) || \"\";\n        const number: string = numbers.find((n) => f.tags.includes(n)) || \"\";\n        const person: string = persons.find((p) => f.tags.includes(p)) || \"\";\n\n        if (!grouped[mood]) grouped[mood] = {};\n        if (!grouped[mood][tense]) grouped[mood][tense] = {};\n        if (!grouped[mood][tense][number]) grouped[mood][tense][number] = {};\n        if (!grouped[mood][tense][number][person]) grouped[mood][tense][number][person] = [];\n\n        grouped[mood][tense][number][person].push(f);\n      });\n\n      Object.entries(grouped).forEach(([mood, tensesObj]) => {\n        const nonFinite: boolean = mood === \"non-finite\";\n\n        md += `#### ${nonFinite ? \"Non-finite forms\" : `Mood: ${mood}`}\\n`;\n        if (nonFinite) md += `| Name | Form |\\n|---|---|\\n`;\n\n        Object.entries(tensesObj).forEach(([tense, numbersObj]) => {\n          // Non-finite forms don't have tense, number, or person, so they are rendered in a single table\n\n          if (nonFinite) {\n            if (tense && mood !== \"imperative\") return;\n\n            Object.entries(numbersObj).forEach(([, personsObj]) => {\n              Object.entries(personsObj).forEach(([, formsArr]) => {\n                formsArr.forEach((f) => {\n                  const row: string = `| ${f.tags.join(\", \")} | ${f.word} |\\n`;\n\n                  if (!rows.includes(row)) {\n                    md += row;\n                    rows.push(row);\n                  }\n                });\n              });\n            });\n\n            rows.length = 0;\n          } else {\n            if (!tense && mood !== \"imperative\") return;\n\n            md += `##### Tense: ${mood === \"imperative\" ? \"present\" : tense}\\n`;\n            md += `| Person & Number | Form |\\n|---|---|\\n`;\n\n            Object.entries(numbersObj).forEach(([number, personsObj]) => {\n              Object.entries(personsObj).forEach(([person, formsArr]) => {\n                formsArr.forEach((f) => {\n                  const row: string = `| ${person} ${number} | ${f.word} |\\n`;\n\n                  if (!rows.includes(row)) {\n                    md += row;\n                    rows.push(row);\n                  }\n                });\n              });\n            });\n\n            rows.length = 0;\n          }\n        });\n\n        md += `\\n`;\n      });\n    } else {\n      entry.forms.forEach((f) => {\n        if (!f.tags.some((tag) => invalidTags.includes(tag))) {\n          md += `- ${f.word} (${f.tags.join(\", \")})\\n`;\n        }\n      });\n    }\n\n    md += `\\n\\n`;\n\n    return md;\n  }\n\n  /**\n   * Renders a sense and its subsenses into a formatted Markdown string.\n   *\n   * This method takes a {@link Sense} object and recursively formats its definition,\n   * examples, quotes, synonyms, antonyms, and any nested subsenses into a readable\n   * Markdown structure. Subsenses are indented and numbered for clarity.\n   *\n   * @param sense The {@link Sense} object to render.\n   * @returns {string} A Markdown-formatted string representing the sense and its subsenses.\n   */\n  private renderSenses(sense: Sense): string {\n    if (!sense) return \"\";\n\n    let md = \"\";\n\n    const renderSubsenses = (subsenses: Sense[], indent: number = 1): string => {\n      let subMd = \"\";\n      const indentStr = \"  \".repeat(indent);\n\n      subsenses.forEach((s, idx, arr) => {\n        subMd += `${indentStr}${idx + 1}. ${s.definition}\\n`;\n        if (s.synonyms && s.synonyms.length) subMd += `${indentStr}   - **Synonyms:** ${s.synonyms.join(\", \")}\\n`;\n        if (s.antonyms && s.antonyms.length) subMd += `${indentStr}   - **Antonyms:** ${s.antonyms.join(\", \")}\\n`;\n        if (s.examples && s.examples.length) {\n          if (s.examples.length > 1)\n            s.examples.forEach((ex: string, i: number) => {\n              subMd += `${indentStr}   - **Example ${i + 1}:** \"${ex}\"\\n`;\n            });\n          else subMd += `${indentStr}   - **Example:** \"${s.examples[0]}\"\\n`;\n        }\n        if (s.quotes && s.quotes.length) {\n          if (s.quotes.length > 1)\n            s.quotes.forEach((q: { text: string; reference: string }, i: number) => {\n              subMd += `${indentStr}   - **Quote ${i + 1}:** \"${q.text}\" - _${q.reference}_\\n`;\n            });\n          else subMd += `${indentStr}   - **Quote:** \"${s.quotes[0].text}\" - _${s.quotes[0].reference}_\\n`;\n        }\n        if (s.subsenses && s.subsenses.length) {\n          subMd += renderSubsenses(s.subsenses, indent + 1);\n        }\n        if (idx + 1 === arr.length) subMd += \"\\n\";\n      });\n\n      return subMd;\n    };\n\n    md += `${sense.definition}\\n`;\n\n    if (sense.examples && sense.examples.length) {\n      if (sense.examples.length > 1)\n        sense.examples.forEach((ex: string, i: number) => {\n          md += `- **Example ${i + 1}:** \"${ex}\"\\n`;\n        });\n      else md += `- **Example:** \"${sense.examples[0]}\"\\n`;\n    }\n    if (sense.quotes && sense.quotes.length) {\n      if (sense.quotes.length > 1)\n        sense.quotes.forEach((q: { text: string; reference: string }, i: number) => {\n          md += `- **Quote ${i + 1}:** \"${q.text}\" - _${q.reference}_\\n`;\n        });\n      else md += `- **Quote:** \"${sense.quotes[0].text}\" - _${sense.quotes[0].reference}_\\n`;\n    }\n    if (sense.synonyms && sense.synonyms.length) md += `- **Synonyms:** ${sense.synonyms.join(\", \")}\\n`;\n    if (sense.antonyms && sense.antonyms.length) md += `- **Antonyms:** ${sense.antonyms.join(\", \")}\\n`;\n    if (sense.subsenses && sense.subsenses.length) {\n      md += renderSubsenses(sense.subsenses, 1);\n    }\n\n    md += \"\\n\\n\";\n\n    return md;\n  }\n}\n\nexport default Dictionary;\nexport type { GroupedEntry, Sense };\n"],
  "mappings": "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",
  "names": ["history_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "import_api", "History", "_History", "data", "language", "languageCode", "word", "result", "history", "a", "b", "updatedHistory", "he", "fav", "history_default", "import_api", "Dictionary", "_Dictionary", "languageCode", "wordQuery", "text", "result", "ge", "err", "cachedResult", "res", "entry", "error", "groupedEntries", "title", "pronunciations", "forms", "e", "sense", "senseWithMarkdown", "md", "grouped", "p", "tag", "region", "group", "invalidTags", "complexConjugationsLanguages", "rows", "nonfiniteMoods", "moods", "tenses", "numbers", "persons", "f", "t", "n", "mood", "m", "nm", "tense", "number", "person", "tensesObj", "nonFinite", "numbersObj", "personsObj", "formsArr", "row", "renderSubsenses", "subsenses", "indent", "subMd", "indentStr", "s", "idx", "arr", "ex", "i", "q", "dictionary_default", "import_jsx_runtime", "Command", "history", "setHistory", "searchText", "setSearchText", "loading", "setLoading", "selectedLanguage", "setSelectedLanguage", "entries", "history_default", "langs", "h", "lang", "dictionary_default", "acc", "langA", "langB", "langString", "wordInfo", "langCode", "word", "epoch", "options"]
}
