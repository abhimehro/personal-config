{
  "version": 3,
  "sources": ["../src/list.tsx", "../src/classes/favorite.ts", "../src/classes/dictionary.ts"],
  "sourcesContent": ["import { List, ActionPanel, Action, Icon, Alert, showToast, confirmAlert, Toast, open, Keyboard } from \"@raycast/api\";\nimport { JSX, useEffect, useState } from \"react\";\nimport Favorite, { FavoriteEntry } from \"./classes/favorite\";\nimport Dictionary from \"./classes/dictionary\";\n\nexport default function Command(): JSX.Element {\n  const [favorites, setFavorites] = useState<FavoriteEntry[]>([]);\n  const [searchText, setSearchText] = useState(\"\");\n  const [loading, setLoading] = useState(true);\n  const [selectedLanguage, setSelectedLanguage] = useState<string>(\"All\");\n\n  useEffect(() => {\n    const fetchFavorites = async () => {\n      const favs: FavoriteEntry[] = await Favorite.getEntries();\n      setFavorites(favs);\n      setLoading(false);\n    };\n\n    fetchFavorites();\n  }, []);\n\n  const langs: string[] = Array.from(new Set(favorites.map((fav) => fav.language)));\n\n  return (\n    <List\n      isLoading={loading}\n      searchText={searchText}\n      onSearchTextChange={setSearchText}\n      searchBarPlaceholder=\"Filter favorites by word...\"\n      filtering={true}\n      isShowingDetail={true}\n      searchBarAccessory={\n        <List.Dropdown tooltip=\"Filter by language\" storeValue={true} onChange={setSelectedLanguage} defaultValue=\"All\">\n          <List.Dropdown.Item title=\"All\" value=\"All\" />\n          {langs.map((lang: string) => (\n            <List.Dropdown.Item key={lang} title={Dictionary.capitalize(lang)} value={lang} />\n          ))}\n        </List.Dropdown>\n      }\n    >\n      {!favorites.length ? (\n        <List.EmptyView title=\"No favorites found\" />\n      ) : (\n        Object.entries(\n          favorites.reduce(\n            (\n              acc: {\n                [lang: string]: { word: string; markdown: string; url: string; partOfSpeech: string; entry: number }[];\n              },\n              fav: FavoriteEntry,\n            ) => {\n              if (!acc[fav.language]) acc[fav.language] = [];\n              acc[fav.language].push({\n                word: fav.word,\n                markdown: fav.markdown,\n                url: fav.url,\n                partOfSpeech: fav.partOfSpeech,\n                entry: fav.entry,\n              });\n              return acc;\n            },\n            {},\n          ),\n        )\n          .filter(([lang]) => selectedLanguage === \"All\" || lang === selectedLanguage)\n          .sort(([langA], [langB]) => langA.localeCompare(langB))\n          .map(\n            ([lang, wordDefinition]: [\n              string,\n              { word: string; markdown: string; url: string; partOfSpeech: string; entry: number }[],\n            ]) => (\n              <List.Section key={lang} title={Dictionary.capitalize(lang)}>\n                {wordDefinition\n                  .filter((entry) => entry.word.toLowerCase().includes(searchText.toLowerCase()))\n                  .map((entry) => (\n                    <List.Item\n                      key={`${entry.word}-${entry.partOfSpeech}-${entry.entry}`}\n                      title={entry.word}\n                      detail={<List.Item.Detail markdown={entry.markdown || \"No details available.\"} />}\n                      actions={\n                        <ActionPanel>\n                          <Action\n                            title=\"Open in Browser\"\n                            icon={Icon.Globe}\n                            shortcut={Keyboard.Shortcut.Common.Open}\n                            onAction={(): void => {\n                              const url: string = entry.url;\n                              if (url) open(url);\n                            }}\n                          />\n                          <ActionPanel.Section>\n                            <Action\n                              title=\"Remove from Favorites\"\n                              icon={Icon.StarDisabled}\n                              style={Action.Style.Destructive}\n                              shortcut={Keyboard.Shortcut.Common.Remove}\n                              onAction={async (): Promise<void> => {\n                                const options: Alert.Options = {\n                                  title: \"Remove from Favorites\",\n                                  message: `\"${entry.word}\" (${Dictionary.capitalize(lang)}) will be removed from your favorites`,\n                                  primaryAction: {\n                                    title: \"Delete\",\n                                    style: Alert.ActionStyle.Destructive,\n                                    onAction: async (): Promise<void> => {\n                                      const success: boolean = await Favorite.removeEntry(\n                                        lang,\n                                        entry.word,\n                                        entry.entry,\n                                        entry.partOfSpeech,\n                                      );\n\n                                      if (success) {\n                                        const favs: FavoriteEntry[] = await Favorite.getEntries();\n                                        setFavorites(favs);\n\n                                        await showToast({\n                                          style: Toast.Style.Success,\n                                          title: \"Removed from Favorites\",\n                                          message: `\"${entry.word}\" (${Dictionary.capitalize(lang)}) has been removed from your favorites`,\n                                        });\n                                      } else {\n                                        await showToast({\n                                          style: Toast.Style.Failure,\n                                          title: \"Failed to remove from Favorites\",\n                                          message: `\"${entry.word}\" (${Dictionary.capitalize(lang)}) could not be found in your favorites`,\n                                        });\n                                      }\n                                    },\n                                  },\n                                };\n\n                                await confirmAlert(options);\n                              }}\n                            />\n                            <Action\n                              title=\"Remove All Favorites\"\n                              icon={Icon.Trash}\n                              style={Action.Style.Destructive}\n                              shortcut={Keyboard.Shortcut.Common.RemoveAll}\n                              onAction={async (): Promise<void> => {\n                                const options: Alert.Options = {\n                                  title: \"Remove All Favorites\",\n                                  message: `All favorites will be removed`,\n                                  primaryAction: {\n                                    title: \"Delete\",\n                                    style: Alert.ActionStyle.Destructive,\n                                    onAction: async (): Promise<void> => {\n                                      const success: boolean = await Favorite.removeAll();\n\n                                      if (success) {\n                                        const favs: FavoriteEntry[] = await Favorite.getEntries();\n                                        setFavorites(favs);\n\n                                        await showToast({\n                                          style: Toast.Style.Success,\n                                          title: \"Removed from Favorites\",\n                                          message: `All favorites have been removed`,\n                                        });\n                                      } else {\n                                        await showToast({\n                                          style: Toast.Style.Failure,\n                                          title: \"Failed to remove from Favorites\",\n                                          message: `Could not remove all favorites`,\n                                        });\n                                      }\n                                    },\n                                  },\n                                };\n\n                                await confirmAlert(options);\n                              }}\n                            />\n                          </ActionPanel.Section>\n                        </ActionPanel>\n                      }\n                    />\n                  ))}\n              </List.Section>\n            ),\n          )\n      )}\n    </List>\n  );\n}\n", "import { LocalStorage } from \"@raycast/api\";\nimport { GroupedEntry } from \"./dictionary\";\n\ninterface FavoriteEntry {\n  language: string;\n  word: string;\n  markdown: string;\n  url: string;\n  entry: number;\n  partOfSpeech: string;\n}\n\nclass Favorite {\n  private static key: string = \"favorites\";\n\n  /**\n   * Retrieves the list of favorite entries from local storage.\n   *\n   * @returns {FavoriteEntry[]} An array of favorite entries. Returns an empty array if no entries are found or if the entry data is invalid.\n   */\n  public static async getEntries(): Promise<FavoriteEntry[]> {\n    try {\n      const entries = await LocalStorage.getItem(Favorite.key);\n      return entries ? JSON.parse(entries.toString()) : [];\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Adds a new entry to the favorites list if it does not already exist.\n   *\n   * @param {string} language The language of the word to add.\n   * @param {string} word The word to add to favorites.\n   * @param {string} markdown The markdown details associated with the word.\n   * @param {string} url The URL that the word was sourced from.\n   * @param {number} entry The entry number associated with the word.\n   *\n   * Checks if the combination of language and word already exists in the favorites.\n   * If not, formats the language and word, adds them to the favorites, and updates LocalStorage.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async addEntry(\n    language: string,\n    word: string,\n    markdown: string,\n    url: string,\n    entry: number,\n    partOfSpeech: string,\n  ): Promise<boolean> {\n    let result: boolean = true;\n    try {\n      const favorites: FavoriteEntry[] = await this.getEntries();\n      const exists: boolean = await Favorite.exist(language, word, entry, partOfSpeech);\n      if (!exists) {\n        favorites.push({\n          language: language.toLowerCase(),\n          word: word,\n          markdown,\n          url,\n          entry,\n          partOfSpeech,\n        });\n        favorites.sort((a: FavoriteEntry, b: FavoriteEntry) => a.word.localeCompare(b.word));\n        LocalStorage.setItem(Favorite.key, JSON.stringify(favorites));\n      } else {\n        result = true;\n      }\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Removes a favorite entry matching the specified language and word from the stored favorites.\n   *\n   * @param {string} language The language of the entry to remove.\n   * @param {string} word The word of the entry to remove.\n   * @param {number} entry The entry number of the entry to remove.\n   * @param {string} partOfSpeech The part of speech of the entry to remove.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async removeEntry(\n    language: string,\n    word: string,\n    entry: number,\n    partOfSpeech: string,\n  ): Promise<boolean> {\n    let result: boolean = true;\n    try {\n      const favorites: FavoriteEntry[] = await this.getEntries();\n      const updatedFavorites = favorites.filter(\n        (fav: FavoriteEntry) =>\n          fav.language !== language.toLowerCase() ||\n          fav.word !== word ||\n          fav.entry !== entry ||\n          fav.partOfSpeech !== partOfSpeech,\n      );\n      LocalStorage.setItem(Favorite.key, JSON.stringify(updatedFavorites));\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Removes all favorite items from local storage.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async removeAll(): Promise<boolean> {\n    let result = true;\n    try {\n      await LocalStorage.removeItem(Favorite.key);\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Determines whether a given word in a specified language is marked as a favorite.\n   *\n   * @param {string} language The language of the word to check.\n   * @param {string} word The word to check for favorite status.\n   * @param {number} entry The entry number associated with the word.\n   * @param {string} partOfSpeech The part of speech associated with the word.\n   * @returns {boolean} Wether the word and language combination is a favorite.\n   */\n  public static async exist(language: string, word: string, entry: number, partOfSpeech: string): Promise<boolean> {\n    const favorites: FavoriteEntry[] = await this.getEntries();\n    return favorites.some(\n      (fav: FavoriteEntry) =>\n        fav.language === language.toLowerCase() &&\n        fav.word === word &&\n        fav.entry === entry &&\n        fav.partOfSpeech === partOfSpeech,\n    );\n  }\n\n  /**\n   * Checks the existence of multiple grouped dictionary entries in the favorites list for a given word in a specific language.\n   *\n   * @param {GroupedEntry} groupedEntry The grouped dictionary entry to check.\n   * @param {string} word The word to check for favorite status.\n   *\n   * @returns {Promise<Record<string, boolean>>} A promise that resolves to a record where each key is a unique identifier for an entry (partOfSpeech-senseIndex), and the value is `true` if the entry exists in favorites, or `false` otherwise.\n   */\n  public static async existMultiple(groupedEntry: GroupedEntry, word: string): Promise<Record<string, boolean>> {\n    const result: Record<string, boolean> = {};\n    const entries: FavoriteEntry[] = await this.getEntries();\n\n    for (const [partOfSpeech, entry] of Object.entries(groupedEntry)) {\n      if (entry.senses && entry.senses.length) {\n        entry.senses.forEach((_, i: number) => {\n          const key = `${partOfSpeech}-${i}`;\n          const exists = entries.some(\n            (fav) =>\n              fav.language.toLowerCase() === entry.language.name.toLowerCase() &&\n              fav.word.toLowerCase() === word.toLowerCase() &&\n              fav.entry === i &&\n              fav.partOfSpeech === partOfSpeech,\n          );\n          result[key] = exists;\n        });\n      }\n    }\n\n    return result;\n  }\n}\n\nexport default Favorite;\nexport type { FavoriteEntry };\n", "import { Cache } from \"@raycast/api\";\n\ninterface Sense {\n  definition: string;\n  tags: string[];\n  examples: string[];\n  quotes: {\n    text: string;\n    reference: string;\n  }[];\n  synonyms: string[];\n  antonyms: string[];\n  translations: string[];\n  subsenses: Sense[];\n  markdown?: string;\n}\n\ninterface Entry {\n  language: {\n    code: string;\n    name: string;\n  };\n  partOfSpeech: string;\n  pronunciations: {\n    type: string;\n    text: string;\n    tags: string[];\n  }[];\n  forms: {\n    word: string;\n    tags: string[];\n  }[];\n  senses: Sense[];\n}\n\ninterface DictionaryResponse {\n  word: string;\n  entries: Entry[];\n  source: {\n    url: string;\n    license: {\n      name: string;\n      url: string;\n    };\n  };\n}\n\ninterface GroupedEntry {\n  [partOfSpeech: string]: Entry;\n}\n\nclass Dictionary {\n  private static cache: Cache = new Cache();\n\n  private url: string = \"https://freedictionaryapi.com/api/v1/entries\";\n  private urlWord: string = \"\";\n\n  private language: string = \"\";\n  private word: string = \"\";\n\n  private languageCode: string = \"\";\n  private wordQuery: string = \"\";\n\n  public get getURL(): string {\n    return this.urlWord;\n  }\n  public get getLanguage(): string {\n    return this.language;\n  }\n\n  constructor(languageCode: string, wordQuery: string) {\n    this.languageCode = languageCode;\n    this.wordQuery = wordQuery;\n  }\n\n  /**\n   * Capitalizes the first letter of the input string and lowercases the rest.\n   *\n   * @param {string} text The input string to capitalize.\n   * @returns {string} The capitalized string.\n   */\n  public static capitalize(text: string): string {\n    return text.slice(0, 1).toUpperCase() + text.slice(1).toLowerCase();\n  }\n\n  public async getEntry(): Promise<GroupedEntry | undefined> {\n    let result: GroupedEntry | undefined = {};\n\n    try {\n      const ge: GroupedEntry | undefined = this.checkCache();\n\n      if (!ge || !Object.keys(ge).length) {\n        result = await this.fetchEntry();\n      } else {\n        result = ge;\n      }\n    } catch (err) {\n      console.error(err);\n      result = await this.fetchEntry();\n    }\n\n    return result;\n  }\n\n  /**\n   * Checks the cache for a previously fetched dictionary entry.\n   *\n   * @returns {GroupedEntry | undefined} The cached grouped entry if it exists. If there is no cached entry, it returns an empty object. If there is an error accessing the cache, it returns `undefined`.\n   */\n  private checkCache(): GroupedEntry | undefined {\n    let result: GroupedEntry | undefined = {};\n\n    try {\n      const cachedResult: string | undefined = Dictionary.cache.get(`${this.languageCode}-${this.wordQuery}`);\n\n      if (cachedResult) {\n        const ge: GroupedEntry = JSON.parse(cachedResult);\n\n        this.language = Dictionary.capitalize(ge[Object.keys(ge)?.[0]]?.language?.name || this.languageCode);\n        this.word = ge[Object.keys(ge)?.[0]]?.forms[0]?.word || this.wordQuery;\n\n        result = ge;\n      } else {\n        result = {};\n      }\n    } catch {\n      result = undefined;\n    }\n\n    return result;\n  }\n\n  /**\n   * Fetches a dictionary entry for the specified word and language from the configured URL.\n   * If the fetch is successful, it processes and formats the entry, updating internal properties.\n   *\n   * @returns {Promise<GroupedEntry | undefined>} A promise that resolves to the grouped entry data or an empty object. If there are no definitions, it returns an empty object. If the fetch fails, it returns `undefined`.\n   */\n  private async fetchEntry(): Promise<GroupedEntry | undefined> {\n    let result: GroupedEntry | undefined = {};\n\n    try {\n      const res: Response = await fetch(`${this.url}/${this.languageCode}/${this.wordQuery}`);\n\n      if (res.ok) {\n        const entry: DictionaryResponse = (await res.json()) as DictionaryResponse;\n\n        if (entry.entries.length) {\n          // Updating the word and language to ensure proper formatting\n\n          this.language = Dictionary.capitalize(entry.entries[0]?.language?.name);\n          this.word = entry.word;\n          this.urlWord = entry.source.url.replaceAll(\" \", \"%20\");\n\n          const ge: GroupedEntry = this.groupEntries(entry);\n\n          try {\n            Dictionary.cache.set(`${this.languageCode}-${this.wordQuery}`, JSON.stringify(ge));\n          } catch (error) {\n            console.error(\"Failed to cache dictionary entry:\", error);\n          }\n\n          result = ge;\n        }\n      } else {\n        result = undefined;\n      }\n    } catch {\n      result = undefined;\n    }\n\n    return result;\n  }\n\n  /**\n   * Groups dictionary entries by their part of speech and enriches each sense with markdown content.\n   *\n   * Iterates through the provided dictionary response, organizing entries into a structure keyed by part of speech.\n   * For each entry, it initializes the group if necessary, collects pronunciations and forms, and generates markdown\n   * for each sense, including title, pronunciations, forms, and rendered sense details.\n   *\n   * @param {DictionaryResponse} entryThe dictionary response containing entries to be grouped.\n   * @returns {GroupedEntry} An object mapping each part of speech to its grouped entries, including enriched senses.\n   */\n  private groupEntries(entry: DictionaryResponse): GroupedEntry {\n    const groupedEntries: GroupedEntry = {};\n\n    let title: string = \"\";\n    let pronunciations: string = \"\";\n    let forms: string = \"\";\n\n    // Group senses by parts of speech\n\n    entry.entries.forEach((e: Entry) => {\n      if (!groupedEntries[e.partOfSpeech]) {\n        // Initialize the part of speech entry\n\n        groupedEntries[e.partOfSpeech] = {\n          language: e.language,\n          partOfSpeech: e.partOfSpeech,\n          pronunciations: [],\n          forms: [],\n          senses: [],\n        };\n\n        // Parts of Speech\n\n        title = `# ${this.word} (_${e.partOfSpeech}_)\\n### Definition:\\n`;\n\n        // Pronunciations\n\n        pronunciations = this.renderPronunciations(e);\n        forms = this.renderForms(e);\n      }\n\n      groupedEntries[e.partOfSpeech].pronunciations.push(...e.pronunciations);\n      groupedEntries[e.partOfSpeech].forms.push(...e.forms);\n      e.senses.forEach((sense: Sense) => {\n        const senseWithMarkdown = {\n          ...sense,\n          markdown: (title + this.renderSenses(sense) + pronunciations + forms).replaceAll(\"..\", \".\"),\n        };\n        groupedEntries[e.partOfSpeech].senses.push(senseWithMarkdown);\n      });\n    });\n\n    return groupedEntries;\n  }\n\n  /**\n   * Renders the pronunciations of a dictionary entry as a Markdown table.\n   * Groups pronunciations by region (tags) and phonetic system type.\n   *\n   * @param {Entry} entry The dictionary entry containing pronunciation data.\n   * @returns {string} Markdown-formatted string representing the pronunciations table,\n   * or an empty string if no pronunciations are available.\n   */\n  private renderPronunciations(entry: Entry): string {\n    if (!entry.pronunciations || !entry.pronunciations.length) return \"\";\n\n    let md = `### Pronunciations\\n`;\n\n    // Group pronunciations by region (tags) and type\n\n    const grouped: Record<string, { type: string; text: string[] }> = {};\n    entry.pronunciations.forEach((p) => {\n      if (p.tags.length) {\n        p.tags.forEach((tag: string) => {\n          if (!grouped[tag]) grouped[tag] = { type: p.type, text: [] };\n          grouped[tag].text.push(p.text);\n        });\n      } else {\n        if (!grouped[\"-\"]) grouped[\"-\"] = { type: p.type, text: [] };\n        grouped[\"-\"].text.push(p.text);\n      }\n    });\n\n    if (!Object.entries(grouped).length) return \"\";\n\n    // Render table of pronunciations\n\n    md += `| Dialect | Pronunciation | Phonetic System | \\n|---|---|---|\\n`;\n\n    Object.entries(grouped).forEach(([region, group]) => {\n      md += `| ${region} | ${group.text.join(\", \")} | ${group.type} |\\n`;\n    });\n\n    md += `\\n\\n`;\n\n    return md;\n  }\n\n  /**\n   * Renders the forms of a dictionary entry as a Markdown string.\n   * For languages with complex conjugation systems, forms are grouped and displayed in tables by mood, tense, number, and person.\n   * For other languages, forms are listed as bullet points.\n   *\n   * @param {Entry} entry The dictionary entry containing forms to render.\n   * @returns {string} A Markdown-formatted string representing the forms of the entry.\n   */\n  private renderForms(entry: Entry): string {\n    if (!entry.forms || !entry.forms.length) return \"\";\n\n    let md = `### Forms\\n`;\n\n    const invalidTags: string[] = [\"inflection-template\", \"table-tags\", \"class\"];\n    const complexConjugationsLanguages: string[] = [\n      \"ca\",\n      \"cs\",\n      \"fr\",\n      \"de\",\n      \"el\",\n      \"hu\",\n      \"it\",\n      \"la\",\n      \"pt\",\n      \"ro\",\n      \"ru\",\n      \"sh\",\n      \"es\",\n      \"nl\",\n    ];\n    const rows: string[] = [];\n\n    // Languages with complex conjugation systems will have their forms grouped by mood, tense, number, and person in tables\n\n    if (complexConjugationsLanguages.includes(this.languageCode)) {\n      const nonfiniteMoods: string[] = [\"gerund\", \"participle\", \"infinitive\"];\n      const moods: string[] = [\"indicative\", \"subjunctive-i\", \"subjunctive-ii\", \"subjunctive\", \"imperative\"];\n      const tenses: string[] = [\n        \"future-i\",\n        \"future-ii\",\n        \"present\",\n        \"imperfect\",\n        \"preterite\",\n        \"future\",\n        \"conditional\",\n        \"perfect\",\n        \"pluperfect\",\n        \"past perfect\",\n        \"future perfect\",\n        \"conditional perfect\",\n      ];\n      const numbers: string[] = [\"singular\", \"plural\"];\n      const persons: string[] = [\"first-person\", \"second-person\", \"third-person\"];\n\n      const grouped: Record<\n        string,\n        Record<string, Record<string, Record<string, { word: string; tags: string[] }[]>>>\n      > = {};\n\n      entry.forms.forEach((f) => {\n        // If the form has no tags, skip it\n\n        if (!f.tags.length) return;\n\n        // If the tags contain any invalid tags, skip this form\n\n        if (f.tags.some((tag) => invalidTags.includes(tag))) return;\n\n        // If the word contains any tense, number, or person keywords, skip this form\n\n        for (const t of tenses) {\n          if (f.word.includes(t.toLowerCase())) return;\n        }\n\n        for (const n of numbers) {\n          if (f.word.includes(n.toLowerCase())) return;\n        }\n\n        for (const p of persons) {\n          if (f.word.includes(p.toLowerCase())) return;\n        }\n\n        // Group the form by mood, tense, number, and person\n\n        const mood: string =\n          moods.find((m) => f.tags.includes(m)) ||\n          (nonfiniteMoods.find((nm) => f.tags.includes(nm)) ? \"non-finite\" : \"indicative\");\n        const tense: string = tenses.find((t) => f.tags.includes(t)) || \"\";\n        const number: string = numbers.find((n) => f.tags.includes(n)) || \"\";\n        const person: string = persons.find((p) => f.tags.includes(p)) || \"\";\n\n        if (!grouped[mood]) grouped[mood] = {};\n        if (!grouped[mood][tense]) grouped[mood][tense] = {};\n        if (!grouped[mood][tense][number]) grouped[mood][tense][number] = {};\n        if (!grouped[mood][tense][number][person]) grouped[mood][tense][number][person] = [];\n\n        grouped[mood][tense][number][person].push(f);\n      });\n\n      Object.entries(grouped).forEach(([mood, tensesObj]) => {\n        const nonFinite: boolean = mood === \"non-finite\";\n\n        md += `#### ${nonFinite ? \"Non-finite forms\" : `Mood: ${mood}`}\\n`;\n        if (nonFinite) md += `| Name | Form |\\n|---|---|\\n`;\n\n        Object.entries(tensesObj).forEach(([tense, numbersObj]) => {\n          // Non-finite forms don't have tense, number, or person, so they are rendered in a single table\n\n          if (nonFinite) {\n            if (tense && mood !== \"imperative\") return;\n\n            Object.entries(numbersObj).forEach(([, personsObj]) => {\n              Object.entries(personsObj).forEach(([, formsArr]) => {\n                formsArr.forEach((f) => {\n                  const row: string = `| ${f.tags.join(\", \")} | ${f.word} |\\n`;\n\n                  if (!rows.includes(row)) {\n                    md += row;\n                    rows.push(row);\n                  }\n                });\n              });\n            });\n\n            rows.length = 0;\n          } else {\n            if (!tense && mood !== \"imperative\") return;\n\n            md += `##### Tense: ${mood === \"imperative\" ? \"present\" : tense}\\n`;\n            md += `| Person & Number | Form |\\n|---|---|\\n`;\n\n            Object.entries(numbersObj).forEach(([number, personsObj]) => {\n              Object.entries(personsObj).forEach(([person, formsArr]) => {\n                formsArr.forEach((f) => {\n                  const row: string = `| ${person} ${number} | ${f.word} |\\n`;\n\n                  if (!rows.includes(row)) {\n                    md += row;\n                    rows.push(row);\n                  }\n                });\n              });\n            });\n\n            rows.length = 0;\n          }\n        });\n\n        md += `\\n`;\n      });\n    } else {\n      entry.forms.forEach((f) => {\n        if (!f.tags.some((tag) => invalidTags.includes(tag))) {\n          md += `- ${f.word} (${f.tags.join(\", \")})\\n`;\n        }\n      });\n    }\n\n    md += `\\n\\n`;\n\n    return md;\n  }\n\n  /**\n   * Renders a sense and its subsenses into a formatted Markdown string.\n   *\n   * This method takes a {@link Sense} object and recursively formats its definition,\n   * examples, quotes, synonyms, antonyms, and any nested subsenses into a readable\n   * Markdown structure. Subsenses are indented and numbered for clarity.\n   *\n   * @param sense The {@link Sense} object to render.\n   * @returns {string} A Markdown-formatted string representing the sense and its subsenses.\n   */\n  private renderSenses(sense: Sense): string {\n    if (!sense) return \"\";\n\n    let md = \"\";\n\n    const renderSubsenses = (subsenses: Sense[], indent: number = 1): string => {\n      let subMd = \"\";\n      const indentStr = \"  \".repeat(indent);\n\n      subsenses.forEach((s, idx, arr) => {\n        subMd += `${indentStr}${idx + 1}. ${s.definition}\\n`;\n        if (s.synonyms && s.synonyms.length) subMd += `${indentStr}   - **Synonyms:** ${s.synonyms.join(\", \")}\\n`;\n        if (s.antonyms && s.antonyms.length) subMd += `${indentStr}   - **Antonyms:** ${s.antonyms.join(\", \")}\\n`;\n        if (s.examples && s.examples.length) {\n          if (s.examples.length > 1)\n            s.examples.forEach((ex: string, i: number) => {\n              subMd += `${indentStr}   - **Example ${i + 1}:** \"${ex}\"\\n`;\n            });\n          else subMd += `${indentStr}   - **Example:** \"${s.examples[0]}\"\\n`;\n        }\n        if (s.quotes && s.quotes.length) {\n          if (s.quotes.length > 1)\n            s.quotes.forEach((q: { text: string; reference: string }, i: number) => {\n              subMd += `${indentStr}   - **Quote ${i + 1}:** \"${q.text}\" - _${q.reference}_\\n`;\n            });\n          else subMd += `${indentStr}   - **Quote:** \"${s.quotes[0].text}\" - _${s.quotes[0].reference}_\\n`;\n        }\n        if (s.subsenses && s.subsenses.length) {\n          subMd += renderSubsenses(s.subsenses, indent + 1);\n        }\n        if (idx + 1 === arr.length) subMd += \"\\n\";\n      });\n\n      return subMd;\n    };\n\n    md += `${sense.definition}\\n`;\n\n    if (sense.examples && sense.examples.length) {\n      if (sense.examples.length > 1)\n        sense.examples.forEach((ex: string, i: number) => {\n          md += `- **Example ${i + 1}:** \"${ex}\"\\n`;\n        });\n      else md += `- **Example:** \"${sense.examples[0]}\"\\n`;\n    }\n    if (sense.quotes && sense.quotes.length) {\n      if (sense.quotes.length > 1)\n        sense.quotes.forEach((q: { text: string; reference: string }, i: number) => {\n          md += `- **Quote ${i + 1}:** \"${q.text}\" - _${q.reference}_\\n`;\n        });\n      else md += `- **Quote:** \"${sense.quotes[0].text}\" - _${sense.quotes[0].reference}_\\n`;\n    }\n    if (sense.synonyms && sense.synonyms.length) md += `- **Synonyms:** ${sense.synonyms.join(\", \")}\\n`;\n    if (sense.antonyms && sense.antonyms.length) md += `- **Antonyms:** ${sense.antonyms.join(\", \")}\\n`;\n    if (sense.subsenses && sense.subsenses.length) {\n      md += renderSubsenses(sense.subsenses, 1);\n    }\n\n    md += \"\\n\\n\";\n\n    return md;\n  }\n}\n\nexport default Dictionary;\nexport type { GroupedEntry, Sense };\n"],
  "mappings": "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",
  "names": ["list_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "import_api", "Favorite", "_Favorite", "entries", "language", "word", "markdown", "url", "entry", "partOfSpeech", "result", "favorites", "a", "b", "updatedFavorites", "fav", "groupedEntry", "_", "i", "key", "exists", "favorite_default", "import_api", "Dictionary", "_Dictionary", "languageCode", "wordQuery", "text", "result", "ge", "err", "cachedResult", "res", "entry", "error", "groupedEntries", "title", "pronunciations", "forms", "e", "sense", "senseWithMarkdown", "md", "grouped", "p", "tag", "region", "group", "invalidTags", "complexConjugationsLanguages", "rows", "nonfiniteMoods", "moods", "tenses", "numbers", "persons", "f", "t", "n", "mood", "m", "nm", "tense", "number", "person", "tensesObj", "nonFinite", "numbersObj", "personsObj", "formsArr", "row", "renderSubsenses", "subsenses", "indent", "subMd", "indentStr", "idx", "arr", "ex", "i", "q", "dictionary_default", "import_jsx_runtime", "Command", "favorites", "setFavorites", "searchText", "setSearchText", "loading", "setLoading", "selectedLanguage", "setSelectedLanguage", "favs", "favorite_default", "langs", "fav", "lang", "dictionary_default", "acc", "langA", "langB", "wordDefinition", "entry", "url", "options"]
}
