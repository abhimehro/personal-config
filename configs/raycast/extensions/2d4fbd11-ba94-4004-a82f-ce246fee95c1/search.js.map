{
  "version": 3,
  "sources": ["../src/search.tsx", "../src/classes/dictionary.ts", "../src/classes/favorite.ts", "../src/classes/history.ts"],
  "sourcesContent": ["import {\n  LaunchProps,\n  ActionPanel,\n  Action,\n  Icon,\n  Alert,\n  confirmAlert,\n  showToast,\n  Toast,\n  open,\n  Clipboard,\n  showHUD,\n  List,\n  Color,\n  Keyboard,\n} from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport Dictionary, { GroupedEntry, Sense } from \"./classes/dictionary\";\nimport Favorite from \"./classes/favorite\";\nimport History from \"./classes/history\";\n\nexport default function Command(props: LaunchProps<{ arguments: Arguments.Search }>) {\n  let d: Dictionary;\n\n  const colors: Color[] = [Color.Blue, Color.Green, Color.Magenta, Color.Orange, Color.Purple, Color.Red, Color.Yellow];\n\n  const language: string = props.arguments.language;\n  const word: string = props.arguments.word;\n\n  const [groupedEntries, setGroupedEntries] = useState<GroupedEntry>({});\n  const [searchText, setSearchText] = useState(\"\");\n  const [entryURL, setEntryURL] = useState<string>(\"\");\n  const [languageFull, setLanguageFull] = useState<string>(language);\n  const [loading, setLoading] = useState(true);\n  const [favorites, setFavorites] = useState<Record<string, boolean>>({}); // key: `${partOfSpeech}-${j}`\n\n  useEffect(() => {\n    d = new Dictionary(language, word);\n    d.getEntry()\n      .then(async (ge: GroupedEntry | undefined) => {\n        if (ge) {\n          setGroupedEntries(ge);\n          setEntryURL(d.getURL);\n          setLanguageFull(d.getLanguage);\n          setLoading(false);\n\n          if (Object.entries(ge).length && d.getLanguage) {\n            const success: boolean = await History.addEntry(d.getLanguage, language, word);\n\n            if (!success) {\n              showToast({\n                style: Toast.Style.Failure,\n                title: \"There was an error saving the entry to your history\",\n                message: \"Please try again later\",\n              });\n            }\n          }\n        } else {\n          setLoading(false);\n          setGroupedEntries({});\n          showToast({\n            style: Toast.Style.Failure,\n            title: \"There was an error searching the word\",\n            message: \"Please try again later\",\n          });\n        }\n      })\n      .catch(() => {\n        setLoading(false);\n        setGroupedEntries({});\n        showToast({\n          style: Toast.Style.Failure,\n          title: \"There was an error searching the word\",\n          message: \"Please try again later\",\n        });\n      });\n  }, [language, word]);\n\n  useEffect(() => {\n    const checkFavorites = async () => {\n      const favs: Record<string, boolean> = await Favorite.existMultiple(groupedEntries, word);\n      setFavorites({ ...favs });\n    };\n\n    if (Object.keys(groupedEntries).length) checkFavorites();\n  }, [groupedEntries, languageFull, word]);\n\n  return (\n    <List\n      isLoading={loading}\n      searchText={searchText}\n      onSearchTextChange={setSearchText}\n      searchBarPlaceholder={loading ? \"Loading. Please wait...\" : \"Filter by definition...\"}\n      filtering={true}\n      isShowingDetail={true}\n    >\n      {!Object.keys(groupedEntries).length ? (\n        <List.EmptyView title=\"No definitions found\" />\n      ) : (\n        Object.entries(groupedEntries).map(([partOfSpeech, entry], i: number) => {\n          const color: Color = colors[i % colors.length];\n\n          return (\n            <List.Section key={partOfSpeech} title={`${Dictionary.capitalize(partOfSpeech)} (${entry.senses.length})`}>\n              {entry.senses.map((sense: Sense, j: number) => {\n                const favKey = `${partOfSpeech}-${j}`;\n                const isFavorite = favorites[favKey] || false;\n\n                return (\n                  <List.Item\n                    key={`${word}-${partOfSpeech}-${j}`}\n                    title={\"\"}\n                    accessories={isFavorite ? [{ icon: Icon.Star }] : []}\n                    icon={{\n                      source: Icon.Dot,\n                      tintColor: color,\n                    }}\n                    subtitle={sense.definition}\n                    detail={<List.Item.Detail markdown={sense.markdown || \"No details available.\"} />}\n                    actions={\n                      <ActionPanel>\n                        <Action\n                          title=\"Open in Browser\"\n                          icon={Icon.Globe}\n                          onAction={(): void => {\n                            if (entryURL) open(entryURL);\n                          }}\n                        />\n                        <Action\n                          title={isFavorite ? \"Remove from Favorites\" : \"Add to Favorites\"}\n                          icon={isFavorite ? Icon.StarDisabled : Icon.Star}\n                          style={isFavorite ? Action.Style.Destructive : Action.Style.Regular}\n                          shortcut={isFavorite ? Keyboard.Shortcut.Common.Remove : Keyboard.Shortcut.Common.Pin}\n                          onAction={async (): Promise<void> => {\n                            if (!isFavorite) {\n                              const success: boolean = await Favorite.addEntry(\n                                languageFull,\n                                word,\n                                sense.markdown || \"\",\n                                entryURL || \"\",\n                                j,\n                                partOfSpeech,\n                              );\n                              if (success) {\n                                await showToast({\n                                  style: Toast.Style.Success,\n                                  title: \"Added to Favorites\",\n                                  message: `\"${word}\" (${Dictionary.capitalize(languageFull)}) has been added to your favorites`,\n                                });\n                                setFavorites((prev) => ({ ...prev, [favKey]: true }));\n                              } else {\n                                await showToast({\n                                  style: Toast.Style.Failure,\n                                  title: \"Failed to add to Favorites\",\n                                  message: `\"${word}\" (${Dictionary.capitalize(languageFull)}) is already in your favorites`,\n                                });\n                              }\n                            } else {\n                              const options: Alert.Options = {\n                                title: \"Remove from Favorites\",\n                                message: `\"${word}\" (${Dictionary.capitalize(languageFull)}) will be removed from your favorites`,\n                                primaryAction: {\n                                  title: \"Delete\",\n                                  style: Alert.ActionStyle.Destructive,\n                                  onAction: async (): Promise<void> => {\n                                    await showToast({\n                                      style: Toast.Style.Success,\n                                      title: \"Removed from Favorites\",\n                                      message: `\"${word}\" (${Dictionary.capitalize(languageFull)}) has been removed from your favorites`,\n                                    });\n                                  },\n                                },\n                              };\n                              if (await confirmAlert(options)) {\n                                const success: boolean = await Favorite.removeEntry(\n                                  languageFull,\n                                  word,\n                                  j,\n                                  partOfSpeech,\n                                );\n                                if (success) {\n                                  setFavorites((prev) => ({ ...prev, [favKey]: false }));\n                                } else {\n                                  await showToast({\n                                    style: Toast.Style.Failure,\n                                    title: \"Failed to remove from Favorites\",\n                                    message: `\"${word}\" (${Dictionary.capitalize(languageFull)}) is not in your favorites`,\n                                  });\n                                }\n                              }\n                            }\n                          }}\n                        />\n                        <Action\n                          title=\"Copy to Clipboard\"\n                          icon={Icon.Clipboard}\n                          shortcut={Keyboard.Shortcut.Common.Copy}\n                          onAction={(): void => {\n                            Clipboard.copy(sense.definition);\n                            showHUD(\n                              `The definitions for \"${word}\" (${Dictionary.capitalize(languageFull)}) have been copied to clipboard`,\n                            );\n                          }}\n                        />\n                      </ActionPanel>\n                    }\n                  />\n                );\n              })}\n            </List.Section>\n          );\n        })\n      )}\n    </List>\n  );\n}\n", "import { Cache } from \"@raycast/api\";\n\ninterface Sense {\n  definition: string;\n  tags: string[];\n  examples: string[];\n  quotes: {\n    text: string;\n    reference: string;\n  }[];\n  synonyms: string[];\n  antonyms: string[];\n  translations: string[];\n  subsenses: Sense[];\n  markdown?: string;\n}\n\ninterface Entry {\n  language: {\n    code: string;\n    name: string;\n  };\n  partOfSpeech: string;\n  pronunciations: {\n    type: string;\n    text: string;\n    tags: string[];\n  }[];\n  forms: {\n    word: string;\n    tags: string[];\n  }[];\n  senses: Sense[];\n}\n\ninterface DictionaryResponse {\n  word: string;\n  entries: Entry[];\n  source: {\n    url: string;\n    license: {\n      name: string;\n      url: string;\n    };\n  };\n}\n\ninterface GroupedEntry {\n  [partOfSpeech: string]: Entry;\n}\n\nclass Dictionary {\n  private static cache: Cache = new Cache();\n\n  private url: string = \"https://freedictionaryapi.com/api/v1/entries\";\n  private urlWord: string = \"\";\n\n  private language: string = \"\";\n  private word: string = \"\";\n\n  private languageCode: string = \"\";\n  private wordQuery: string = \"\";\n\n  public get getURL(): string {\n    return this.urlWord;\n  }\n  public get getLanguage(): string {\n    return this.language;\n  }\n\n  constructor(languageCode: string, wordQuery: string) {\n    this.languageCode = languageCode;\n    this.wordQuery = wordQuery;\n  }\n\n  /**\n   * Capitalizes the first letter of the input string and lowercases the rest.\n   *\n   * @param {string} text The input string to capitalize.\n   * @returns {string} The capitalized string.\n   */\n  public static capitalize(text: string): string {\n    return text.slice(0, 1).toUpperCase() + text.slice(1).toLowerCase();\n  }\n\n  public async getEntry(): Promise<GroupedEntry | undefined> {\n    let result: GroupedEntry | undefined = {};\n\n    try {\n      const ge: GroupedEntry | undefined = this.checkCache();\n\n      if (!ge || !Object.keys(ge).length) {\n        result = await this.fetchEntry();\n      } else {\n        result = ge;\n      }\n    } catch (err) {\n      console.error(err);\n      result = await this.fetchEntry();\n    }\n\n    return result;\n  }\n\n  /**\n   * Checks the cache for a previously fetched dictionary entry.\n   *\n   * @returns {GroupedEntry | undefined} The cached grouped entry if it exists. If there is no cached entry, it returns an empty object. If there is an error accessing the cache, it returns `undefined`.\n   */\n  private checkCache(): GroupedEntry | undefined {\n    let result: GroupedEntry | undefined = {};\n\n    try {\n      const cachedResult: string | undefined = Dictionary.cache.get(`${this.languageCode}-${this.wordQuery}`);\n\n      if (cachedResult) {\n        const ge: GroupedEntry = JSON.parse(cachedResult);\n\n        this.language = Dictionary.capitalize(ge[Object.keys(ge)?.[0]]?.language?.name || this.languageCode);\n        this.word = ge[Object.keys(ge)?.[0]]?.forms[0]?.word || this.wordQuery;\n\n        result = ge;\n      } else {\n        result = {};\n      }\n    } catch {\n      result = undefined;\n    }\n\n    return result;\n  }\n\n  /**\n   * Fetches a dictionary entry for the specified word and language from the configured URL.\n   * If the fetch is successful, it processes and formats the entry, updating internal properties.\n   *\n   * @returns {Promise<GroupedEntry | undefined>} A promise that resolves to the grouped entry data or an empty object. If there are no definitions, it returns an empty object. If the fetch fails, it returns `undefined`.\n   */\n  private async fetchEntry(): Promise<GroupedEntry | undefined> {\n    let result: GroupedEntry | undefined = {};\n\n    try {\n      const res: Response = await fetch(`${this.url}/${this.languageCode}/${this.wordQuery}`);\n\n      if (res.ok) {\n        const entry: DictionaryResponse = (await res.json()) as DictionaryResponse;\n\n        if (entry.entries.length) {\n          // Updating the word and language to ensure proper formatting\n\n          this.language = Dictionary.capitalize(entry.entries[0]?.language?.name);\n          this.word = entry.word;\n          this.urlWord = entry.source.url.replaceAll(\" \", \"%20\");\n\n          const ge: GroupedEntry = this.groupEntries(entry);\n\n          try {\n            Dictionary.cache.set(`${this.languageCode}-${this.wordQuery}`, JSON.stringify(ge));\n          } catch (error) {\n            console.error(\"Failed to cache dictionary entry:\", error);\n          }\n\n          result = ge;\n        }\n      } else {\n        result = undefined;\n      }\n    } catch {\n      result = undefined;\n    }\n\n    return result;\n  }\n\n  /**\n   * Groups dictionary entries by their part of speech and enriches each sense with markdown content.\n   *\n   * Iterates through the provided dictionary response, organizing entries into a structure keyed by part of speech.\n   * For each entry, it initializes the group if necessary, collects pronunciations and forms, and generates markdown\n   * for each sense, including title, pronunciations, forms, and rendered sense details.\n   *\n   * @param {DictionaryResponse} entryThe dictionary response containing entries to be grouped.\n   * @returns {GroupedEntry} An object mapping each part of speech to its grouped entries, including enriched senses.\n   */\n  private groupEntries(entry: DictionaryResponse): GroupedEntry {\n    const groupedEntries: GroupedEntry = {};\n\n    let title: string = \"\";\n    let pronunciations: string = \"\";\n    let forms: string = \"\";\n\n    // Group senses by parts of speech\n\n    entry.entries.forEach((e: Entry) => {\n      if (!groupedEntries[e.partOfSpeech]) {\n        // Initialize the part of speech entry\n\n        groupedEntries[e.partOfSpeech] = {\n          language: e.language,\n          partOfSpeech: e.partOfSpeech,\n          pronunciations: [],\n          forms: [],\n          senses: [],\n        };\n\n        // Parts of Speech\n\n        title = `# ${this.word} (_${e.partOfSpeech}_)\\n### Definition:\\n`;\n\n        // Pronunciations\n\n        pronunciations = this.renderPronunciations(e);\n        forms = this.renderForms(e);\n      }\n\n      groupedEntries[e.partOfSpeech].pronunciations.push(...e.pronunciations);\n      groupedEntries[e.partOfSpeech].forms.push(...e.forms);\n      e.senses.forEach((sense: Sense) => {\n        const senseWithMarkdown = {\n          ...sense,\n          markdown: (title + this.renderSenses(sense) + pronunciations + forms).replaceAll(\"..\", \".\"),\n        };\n        groupedEntries[e.partOfSpeech].senses.push(senseWithMarkdown);\n      });\n    });\n\n    return groupedEntries;\n  }\n\n  /**\n   * Renders the pronunciations of a dictionary entry as a Markdown table.\n   * Groups pronunciations by region (tags) and phonetic system type.\n   *\n   * @param {Entry} entry The dictionary entry containing pronunciation data.\n   * @returns {string} Markdown-formatted string representing the pronunciations table,\n   * or an empty string if no pronunciations are available.\n   */\n  private renderPronunciations(entry: Entry): string {\n    if (!entry.pronunciations || !entry.pronunciations.length) return \"\";\n\n    let md = `### Pronunciations\\n`;\n\n    // Group pronunciations by region (tags) and type\n\n    const grouped: Record<string, { type: string; text: string[] }> = {};\n    entry.pronunciations.forEach((p) => {\n      if (p.tags.length) {\n        p.tags.forEach((tag: string) => {\n          if (!grouped[tag]) grouped[tag] = { type: p.type, text: [] };\n          grouped[tag].text.push(p.text);\n        });\n      } else {\n        if (!grouped[\"-\"]) grouped[\"-\"] = { type: p.type, text: [] };\n        grouped[\"-\"].text.push(p.text);\n      }\n    });\n\n    if (!Object.entries(grouped).length) return \"\";\n\n    // Render table of pronunciations\n\n    md += `| Dialect | Pronunciation | Phonetic System | \\n|---|---|---|\\n`;\n\n    Object.entries(grouped).forEach(([region, group]) => {\n      md += `| ${region} | ${group.text.join(\", \")} | ${group.type} |\\n`;\n    });\n\n    md += `\\n\\n`;\n\n    return md;\n  }\n\n  /**\n   * Renders the forms of a dictionary entry as a Markdown string.\n   * For languages with complex conjugation systems, forms are grouped and displayed in tables by mood, tense, number, and person.\n   * For other languages, forms are listed as bullet points.\n   *\n   * @param {Entry} entry The dictionary entry containing forms to render.\n   * @returns {string} A Markdown-formatted string representing the forms of the entry.\n   */\n  private renderForms(entry: Entry): string {\n    if (!entry.forms || !entry.forms.length) return \"\";\n\n    let md = `### Forms\\n`;\n\n    const invalidTags: string[] = [\"inflection-template\", \"table-tags\", \"class\"];\n    const complexConjugationsLanguages: string[] = [\n      \"ca\",\n      \"cs\",\n      \"fr\",\n      \"de\",\n      \"el\",\n      \"hu\",\n      \"it\",\n      \"la\",\n      \"pt\",\n      \"ro\",\n      \"ru\",\n      \"sh\",\n      \"es\",\n      \"nl\",\n    ];\n    const rows: string[] = [];\n\n    // Languages with complex conjugation systems will have their forms grouped by mood, tense, number, and person in tables\n\n    if (complexConjugationsLanguages.includes(this.languageCode)) {\n      const nonfiniteMoods: string[] = [\"gerund\", \"participle\", \"infinitive\"];\n      const moods: string[] = [\"indicative\", \"subjunctive-i\", \"subjunctive-ii\", \"subjunctive\", \"imperative\"];\n      const tenses: string[] = [\n        \"future-i\",\n        \"future-ii\",\n        \"present\",\n        \"imperfect\",\n        \"preterite\",\n        \"future\",\n        \"conditional\",\n        \"perfect\",\n        \"pluperfect\",\n        \"past perfect\",\n        \"future perfect\",\n        \"conditional perfect\",\n      ];\n      const numbers: string[] = [\"singular\", \"plural\"];\n      const persons: string[] = [\"first-person\", \"second-person\", \"third-person\"];\n\n      const grouped: Record<\n        string,\n        Record<string, Record<string, Record<string, { word: string; tags: string[] }[]>>>\n      > = {};\n\n      entry.forms.forEach((f) => {\n        // If the form has no tags, skip it\n\n        if (!f.tags.length) return;\n\n        // If the tags contain any invalid tags, skip this form\n\n        if (f.tags.some((tag) => invalidTags.includes(tag))) return;\n\n        // If the word contains any tense, number, or person keywords, skip this form\n\n        for (const t of tenses) {\n          if (f.word.includes(t.toLowerCase())) return;\n        }\n\n        for (const n of numbers) {\n          if (f.word.includes(n.toLowerCase())) return;\n        }\n\n        for (const p of persons) {\n          if (f.word.includes(p.toLowerCase())) return;\n        }\n\n        // Group the form by mood, tense, number, and person\n\n        const mood: string =\n          moods.find((m) => f.tags.includes(m)) ||\n          (nonfiniteMoods.find((nm) => f.tags.includes(nm)) ? \"non-finite\" : \"indicative\");\n        const tense: string = tenses.find((t) => f.tags.includes(t)) || \"\";\n        const number: string = numbers.find((n) => f.tags.includes(n)) || \"\";\n        const person: string = persons.find((p) => f.tags.includes(p)) || \"\";\n\n        if (!grouped[mood]) grouped[mood] = {};\n        if (!grouped[mood][tense]) grouped[mood][tense] = {};\n        if (!grouped[mood][tense][number]) grouped[mood][tense][number] = {};\n        if (!grouped[mood][tense][number][person]) grouped[mood][tense][number][person] = [];\n\n        grouped[mood][tense][number][person].push(f);\n      });\n\n      Object.entries(grouped).forEach(([mood, tensesObj]) => {\n        const nonFinite: boolean = mood === \"non-finite\";\n\n        md += `#### ${nonFinite ? \"Non-finite forms\" : `Mood: ${mood}`}\\n`;\n        if (nonFinite) md += `| Name | Form |\\n|---|---|\\n`;\n\n        Object.entries(tensesObj).forEach(([tense, numbersObj]) => {\n          // Non-finite forms don't have tense, number, or person, so they are rendered in a single table\n\n          if (nonFinite) {\n            if (tense && mood !== \"imperative\") return;\n\n            Object.entries(numbersObj).forEach(([, personsObj]) => {\n              Object.entries(personsObj).forEach(([, formsArr]) => {\n                formsArr.forEach((f) => {\n                  const row: string = `| ${f.tags.join(\", \")} | ${f.word} |\\n`;\n\n                  if (!rows.includes(row)) {\n                    md += row;\n                    rows.push(row);\n                  }\n                });\n              });\n            });\n\n            rows.length = 0;\n          } else {\n            if (!tense && mood !== \"imperative\") return;\n\n            md += `##### Tense: ${mood === \"imperative\" ? \"present\" : tense}\\n`;\n            md += `| Person & Number | Form |\\n|---|---|\\n`;\n\n            Object.entries(numbersObj).forEach(([number, personsObj]) => {\n              Object.entries(personsObj).forEach(([person, formsArr]) => {\n                formsArr.forEach((f) => {\n                  const row: string = `| ${person} ${number} | ${f.word} |\\n`;\n\n                  if (!rows.includes(row)) {\n                    md += row;\n                    rows.push(row);\n                  }\n                });\n              });\n            });\n\n            rows.length = 0;\n          }\n        });\n\n        md += `\\n`;\n      });\n    } else {\n      entry.forms.forEach((f) => {\n        if (!f.tags.some((tag) => invalidTags.includes(tag))) {\n          md += `- ${f.word} (${f.tags.join(\", \")})\\n`;\n        }\n      });\n    }\n\n    md += `\\n\\n`;\n\n    return md;\n  }\n\n  /**\n   * Renders a sense and its subsenses into a formatted Markdown string.\n   *\n   * This method takes a {@link Sense} object and recursively formats its definition,\n   * examples, quotes, synonyms, antonyms, and any nested subsenses into a readable\n   * Markdown structure. Subsenses are indented and numbered for clarity.\n   *\n   * @param sense The {@link Sense} object to render.\n   * @returns {string} A Markdown-formatted string representing the sense and its subsenses.\n   */\n  private renderSenses(sense: Sense): string {\n    if (!sense) return \"\";\n\n    let md = \"\";\n\n    const renderSubsenses = (subsenses: Sense[], indent: number = 1): string => {\n      let subMd = \"\";\n      const indentStr = \"  \".repeat(indent);\n\n      subsenses.forEach((s, idx, arr) => {\n        subMd += `${indentStr}${idx + 1}. ${s.definition}\\n`;\n        if (s.synonyms && s.synonyms.length) subMd += `${indentStr}   - **Synonyms:** ${s.synonyms.join(\", \")}\\n`;\n        if (s.antonyms && s.antonyms.length) subMd += `${indentStr}   - **Antonyms:** ${s.antonyms.join(\", \")}\\n`;\n        if (s.examples && s.examples.length) {\n          if (s.examples.length > 1)\n            s.examples.forEach((ex: string, i: number) => {\n              subMd += `${indentStr}   - **Example ${i + 1}:** \"${ex}\"\\n`;\n            });\n          else subMd += `${indentStr}   - **Example:** \"${s.examples[0]}\"\\n`;\n        }\n        if (s.quotes && s.quotes.length) {\n          if (s.quotes.length > 1)\n            s.quotes.forEach((q: { text: string; reference: string }, i: number) => {\n              subMd += `${indentStr}   - **Quote ${i + 1}:** \"${q.text}\" - _${q.reference}_\\n`;\n            });\n          else subMd += `${indentStr}   - **Quote:** \"${s.quotes[0].text}\" - _${s.quotes[0].reference}_\\n`;\n        }\n        if (s.subsenses && s.subsenses.length) {\n          subMd += renderSubsenses(s.subsenses, indent + 1);\n        }\n        if (idx + 1 === arr.length) subMd += \"\\n\";\n      });\n\n      return subMd;\n    };\n\n    md += `${sense.definition}\\n`;\n\n    if (sense.examples && sense.examples.length) {\n      if (sense.examples.length > 1)\n        sense.examples.forEach((ex: string, i: number) => {\n          md += `- **Example ${i + 1}:** \"${ex}\"\\n`;\n        });\n      else md += `- **Example:** \"${sense.examples[0]}\"\\n`;\n    }\n    if (sense.quotes && sense.quotes.length) {\n      if (sense.quotes.length > 1)\n        sense.quotes.forEach((q: { text: string; reference: string }, i: number) => {\n          md += `- **Quote ${i + 1}:** \"${q.text}\" - _${q.reference}_\\n`;\n        });\n      else md += `- **Quote:** \"${sense.quotes[0].text}\" - _${sense.quotes[0].reference}_\\n`;\n    }\n    if (sense.synonyms && sense.synonyms.length) md += `- **Synonyms:** ${sense.synonyms.join(\", \")}\\n`;\n    if (sense.antonyms && sense.antonyms.length) md += `- **Antonyms:** ${sense.antonyms.join(\", \")}\\n`;\n    if (sense.subsenses && sense.subsenses.length) {\n      md += renderSubsenses(sense.subsenses, 1);\n    }\n\n    md += \"\\n\\n\";\n\n    return md;\n  }\n}\n\nexport default Dictionary;\nexport type { GroupedEntry, Sense };\n", "import { LocalStorage } from \"@raycast/api\";\nimport { GroupedEntry } from \"./dictionary\";\n\ninterface FavoriteEntry {\n  language: string;\n  word: string;\n  markdown: string;\n  url: string;\n  entry: number;\n  partOfSpeech: string;\n}\n\nclass Favorite {\n  private static key: string = \"favorites\";\n\n  /**\n   * Retrieves the list of favorite entries from local storage.\n   *\n   * @returns {FavoriteEntry[]} An array of favorite entries. Returns an empty array if no entries are found or if the entry data is invalid.\n   */\n  public static async getEntries(): Promise<FavoriteEntry[]> {\n    try {\n      const entries = await LocalStorage.getItem(Favorite.key);\n      return entries ? JSON.parse(entries.toString()) : [];\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Adds a new entry to the favorites list if it does not already exist.\n   *\n   * @param {string} language The language of the word to add.\n   * @param {string} word The word to add to favorites.\n   * @param {string} markdown The markdown details associated with the word.\n   * @param {string} url The URL that the word was sourced from.\n   * @param {number} entry The entry number associated with the word.\n   *\n   * Checks if the combination of language and word already exists in the favorites.\n   * If not, formats the language and word, adds them to the favorites, and updates LocalStorage.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async addEntry(\n    language: string,\n    word: string,\n    markdown: string,\n    url: string,\n    entry: number,\n    partOfSpeech: string,\n  ): Promise<boolean> {\n    let result: boolean = true;\n    try {\n      const favorites: FavoriteEntry[] = await this.getEntries();\n      const exists: boolean = await Favorite.exist(language, word, entry, partOfSpeech);\n      if (!exists) {\n        favorites.push({\n          language: language.toLowerCase(),\n          word: word,\n          markdown,\n          url,\n          entry,\n          partOfSpeech,\n        });\n        favorites.sort((a: FavoriteEntry, b: FavoriteEntry) => a.word.localeCompare(b.word));\n        LocalStorage.setItem(Favorite.key, JSON.stringify(favorites));\n      } else {\n        result = true;\n      }\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Removes a favorite entry matching the specified language and word from the stored favorites.\n   *\n   * @param {string} language The language of the entry to remove.\n   * @param {string} word The word of the entry to remove.\n   * @param {number} entry The entry number of the entry to remove.\n   * @param {string} partOfSpeech The part of speech of the entry to remove.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async removeEntry(\n    language: string,\n    word: string,\n    entry: number,\n    partOfSpeech: string,\n  ): Promise<boolean> {\n    let result: boolean = true;\n    try {\n      const favorites: FavoriteEntry[] = await this.getEntries();\n      const updatedFavorites = favorites.filter(\n        (fav: FavoriteEntry) =>\n          fav.language !== language.toLowerCase() ||\n          fav.word !== word ||\n          fav.entry !== entry ||\n          fav.partOfSpeech !== partOfSpeech,\n      );\n      LocalStorage.setItem(Favorite.key, JSON.stringify(updatedFavorites));\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Removes all favorite items from local storage.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async removeAll(): Promise<boolean> {\n    let result = true;\n    try {\n      await LocalStorage.removeItem(Favorite.key);\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Determines whether a given word in a specified language is marked as a favorite.\n   *\n   * @param {string} language The language of the word to check.\n   * @param {string} word The word to check for favorite status.\n   * @param {number} entry The entry number associated with the word.\n   * @param {string} partOfSpeech The part of speech associated with the word.\n   * @returns {boolean} Wether the word and language combination is a favorite.\n   */\n  public static async exist(language: string, word: string, entry: number, partOfSpeech: string): Promise<boolean> {\n    const favorites: FavoriteEntry[] = await this.getEntries();\n    return favorites.some(\n      (fav: FavoriteEntry) =>\n        fav.language === language.toLowerCase() &&\n        fav.word === word &&\n        fav.entry === entry &&\n        fav.partOfSpeech === partOfSpeech,\n    );\n  }\n\n  /**\n   * Checks the existence of multiple grouped dictionary entries in the favorites list for a given word in a specific language.\n   *\n   * @param {GroupedEntry} groupedEntry The grouped dictionary entry to check.\n   * @param {string} word The word to check for favorite status.\n   *\n   * @returns {Promise<Record<string, boolean>>} A promise that resolves to a record where each key is a unique identifier for an entry (partOfSpeech-senseIndex), and the value is `true` if the entry exists in favorites, or `false` otherwise.\n   */\n  public static async existMultiple(groupedEntry: GroupedEntry, word: string): Promise<Record<string, boolean>> {\n    const result: Record<string, boolean> = {};\n    const entries: FavoriteEntry[] = await this.getEntries();\n\n    for (const [partOfSpeech, entry] of Object.entries(groupedEntry)) {\n      if (entry.senses && entry.senses.length) {\n        entry.senses.forEach((_, i: number) => {\n          const key = `${partOfSpeech}-${i}`;\n          const exists = entries.some(\n            (fav) =>\n              fav.language.toLowerCase() === entry.language.name.toLowerCase() &&\n              fav.word.toLowerCase() === word.toLowerCase() &&\n              fav.entry === i &&\n              fav.partOfSpeech === partOfSpeech,\n          );\n          result[key] = exists;\n        });\n      }\n    }\n\n    return result;\n  }\n}\n\nexport default Favorite;\nexport type { FavoriteEntry };\n", "import { LocalStorage } from \"@raycast/api\";\n\ninterface HistoryEntry {\n  language: string;\n  languageCode: string;\n  word: string;\n  epoch: number;\n}\n\nclass History {\n  private static key: string = \"history\";\n  private static maxEntries: number = 50;\n\n  /**\n   * Retrieves all history entries from local storage.\n   *\n   * @returns {Promise<HistoryEntry[]>} A promise that resolves to an array of history entries.\n   */\n  public static async getEntries(): Promise<HistoryEntry[]> {\n    const data = await LocalStorage.getItem<string>(History.key);\n    return data ? (JSON.parse(data) as HistoryEntry[]) : [];\n  }\n\n  /**\n   * Adds a new entry to the history list if it does not already exist.\n   *\n   * @param {string} language The language of the word to add.\n   * @param {string} languageCode The language code of the word to add.\n   * @param {string} word The word to add to the history.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async addEntry(language: string, languageCode: string, word: string): Promise<boolean> {\n    let result: boolean = true;\n    try {\n      const history: HistoryEntry[] = await this.getEntries();\n      const exists: boolean = await History.exist(language.toLowerCase(), word);\n\n      if (!exists) {\n        history.push({\n          language: language.trim().toLowerCase().replace(\"  \", \" \"),\n          languageCode: languageCode.toLowerCase(),\n          word: word,\n          epoch: Date.now(),\n        });\n        history.sort((a: HistoryEntry, b: HistoryEntry) => b.epoch - a.epoch);\n        LocalStorage.setItem(History.key, JSON.stringify(history.slice(0, History.maxEntries)));\n      } else {\n        result = true;\n      }\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Removes an entry matching the specified language and word from the history.\n   *\n   * @param {string} language The language of the entry to remove.\n   * @param {string} word The word of the entry to remove.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async removeEntry(language: string, word: string): Promise<boolean> {\n    let result: boolean = true;\n    try {\n      const history: HistoryEntry[] = await this.getEntries();\n      const updatedHistory = history.filter(\n        (he: HistoryEntry) =>\n          he.language.toLowerCase() !== language.toLowerCase() || he.word.toLowerCase() !== word.toLowerCase(),\n      );\n      LocalStorage.setItem(History.key, JSON.stringify(updatedHistory));\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Removes all entries in the history from local storage.\n   *\n   * @returns {Promise<boolean>} A promise that resolves to `true` if the operation was successful, `false` otherwise.\n   */\n  public static async removeAll(): Promise<boolean> {\n    let result = true;\n    try {\n      await LocalStorage.removeItem(History.key);\n    } catch {\n      result = false;\n    }\n    return result;\n  }\n\n  /**\n   * Determines whether a given word in a specified language is in the last 10 history entries.\n   *\n   * @param {string} language The language of the word to check.\n   * @param {string} word The word to check for in the history.\n   *\n   * @returns {boolean} Wether the word and language combination is in the last 10 history entries.\n   */\n  public static async exist(language: string, word: string): Promise<boolean> {\n    const history: HistoryEntry[] = await this.getEntries();\n    const lastTen: HistoryEntry[] = history.slice(-10);\n    return lastTen.some((fav: HistoryEntry) => fav.language === language && fav.word === word);\n  }\n}\n\nexport default History;\nexport type { HistoryEntry };\n"],
  "mappings": "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",
  "names": ["search_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "import_api", "Dictionary", "_Dictionary", "languageCode", "wordQuery", "text", "result", "ge", "err", "cachedResult", "res", "entry", "error", "groupedEntries", "title", "pronunciations", "forms", "e", "sense", "senseWithMarkdown", "md", "grouped", "p", "tag", "region", "group", "invalidTags", "complexConjugationsLanguages", "rows", "nonfiniteMoods", "moods", "tenses", "numbers", "persons", "f", "t", "n", "mood", "m", "nm", "tense", "number", "person", "tensesObj", "nonFinite", "numbersObj", "personsObj", "formsArr", "row", "renderSubsenses", "subsenses", "indent", "subMd", "indentStr", "s", "idx", "arr", "ex", "i", "q", "dictionary_default", "import_api", "Favorite", "_Favorite", "entries", "language", "word", "markdown", "url", "entry", "partOfSpeech", "result", "favorites", "a", "b", "updatedFavorites", "fav", "groupedEntry", "_", "i", "key", "exists", "favorite_default", "import_api", "History", "_History", "data", "language", "languageCode", "word", "result", "history", "a", "b", "updatedHistory", "he", "fav", "history_default", "import_jsx_runtime", "Command", "props", "d", "colors", "language", "word", "groupedEntries", "setGroupedEntries", "searchText", "setSearchText", "entryURL", "setEntryURL", "languageFull", "setLanguageFull", "loading", "setLoading", "favorites", "setFavorites", "dictionary_default", "ge", "history_default", "checkFavorites", "favs", "favorite_default", "partOfSpeech", "entry", "i", "color", "sense", "j", "favKey", "isFavorite", "prev", "options"]
}
