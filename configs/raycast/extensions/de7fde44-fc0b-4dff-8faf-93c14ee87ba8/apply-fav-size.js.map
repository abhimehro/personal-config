{
  "version": 3,
  "sources": ["../src/apply-fav-size.tsx", "../src/hooks/useFavWindowResize.ts", "../src/hooks/useBaseWindowResize.ts", "../src/hooks/useWindowInfo.tsx", "swift:/Users/runner/work/extensions/extensions/extensions/window-sizer/swift", "../src/swift-app.ts", "../src/utils/logger.ts", "../src/hooks/useWindowStateManager.ts", "../src/utils/storageUtils.ts", "../src/components/FavResolutionEmptyView.tsx", "../src/hooks/useSavedFavResolution.ts"],
  "sourcesContent": ["import { showToast, Toast } from \"@raycast/api\";\nimport { useFavWindowResize } from \"./hooks/useFavWindowResize\";\nimport { popToRoot } from \"@raycast/api\";\nimport { useEffect, useState, useRef } from \"react\";\nimport { FavResolutionEmptyView } from \"./components/FavResolutionEmptyView\";\nimport { useSavedFavResolution } from \"./hooks/useSavedFavResolution\";\n\nexport default function Command() {\n  const { resizeWindow } = useFavWindowResize();\n  const [isResizing, setIsResizing] = useState(false);\n  const { savedResolution, isLoading, isValid } = useSavedFavResolution();\n  const isExecuting = useRef(false);\n  const hasResized = useRef(false);\n\n  useEffect(() => {\n    // Prevent multiple simultaneous executions or re-executions\n    if (isExecuting.current || hasResized.current) {\n      return;\n    }\n\n    async function applySavedResolution() {\n      if (savedResolution) {\n        isExecuting.current = true;\n        try {\n          setIsResizing(true);\n          await resizeWindow(savedResolution.width, savedResolution.height);\n          await popToRoot();\n          hasResized.current = true;\n        } catch (error) {\n          console.error(\"Error applying saved resolution:\", error);\n          await showToast({\n            style: Toast.Style.Failure,\n            title: \"Resize failed\",\n          });\n        } finally {\n          setIsResizing(false);\n          isExecuting.current = false;\n        }\n      }\n    }\n    applySavedResolution();\n  }, [savedResolution, resizeWindow]);\n\n  if (isResizing) {\n    return <FavResolutionEmptyView isResizing={true} />;\n  }\n\n  if (isLoading) {\n    return <FavResolutionEmptyView />;\n  }\n\n  if (!isValid) {\n    return <FavResolutionEmptyView isInvalidSize={true} />;\n  }\n\n  if (!savedResolution) {\n    return <FavResolutionEmptyView />;\n  }\n\n  return <FavResolutionEmptyView isResizing={true} />;\n}\n", "import { showHUD, PopToRootType } from \"@raycast/api\";\nimport { useBaseWindowResize } from \"./useBaseWindowResize\";\n\nexport function useFavWindowResize() {\n  const { adjustWindowSize } = useBaseWindowResize();\n\n  async function resizeWindow(width: number, height: number) {\n    await adjustWindowSize(width, height, {\n      onNoWindow: async () => {\n        await showHUD(\"\uD83D\uDED1 No focused window\", {\n          popToRootType: PopToRootType.Immediate,\n        });\n      },\n      onAlreadyResized: async (width, height) => {\n        await showHUD(`\u2714\uFE0F Already in ${width}\u00D7${height}`, {\n          popToRootType: PopToRootType.Immediate,\n        });\n      },\n      onResizeComplete: async (width, height, isRestricted) => {\n        const appRestrictionInfo = isRestricted ? \" (Restricted)\" : \"\";\n        await showHUD(`\u2199\u2197 Resized to ${width}\u00D7${height}${appRestrictionInfo}`, {\n          popToRootType: PopToRootType.Immediate,\n        });\n      },\n      onError: async (err) => {\n        const errorStr = String(err);\n        if (\n          errorStr.includes(\"frontmost\") ||\n          errorStr.includes(\"window\") ||\n          errorStr.includes(\"process\") ||\n          errorStr.includes(\"Failed to get screen information\")\n        ) {\n          await showHUD(\"\uD83D\uDED1 No focused window\", { popToRootType: PopToRootType.Immediate });\n        } else {\n          await showHUD(\"\uD83D\uDED1 Resize failed\", { popToRootType: PopToRootType.Immediate });\n        }\n      },\n    });\n  }\n\n  return {\n    resizeWindow,\n  };\n}\n", "import { closeMainWindow } from \"@raycast/api\";\nimport { useWindowInfo } from \"./useWindowInfo\";\nimport { useWindowStateManager } from \"./useWindowStateManager\";\nimport { resizeWindow } from \"../swift-app\";\nimport { log, error as logError } from \"../utils/logger\";\n\ninterface WindowResizeOptions {\n  onNoWindow: () => Promise<void>;\n  onAlreadyResized: (width: number, height: number) => Promise<void>;\n  onResizeComplete: (width: number, height: number, isRestricted: boolean) => Promise<void>;\n  onError: (error: unknown) => Promise<void>;\n}\n\nexport function useBaseWindowResize() {\n  const { getWindowInfo } = useWindowInfo();\n  const { saveWindowState } = useWindowStateManager();\n\n  async function adjustWindowSize(width: number, height: number, options: WindowResizeOptions) {\n    try {\n      // First, get the current window info - this is always needed for the size check\n      const windowInfo = await getWindowInfo();\n      if (!windowInfo) {\n        await options.onNoWindow();\n        return;\n      }\n      const { x: currentX, y: currentY, width: currentWidth, height: currentHeight } = windowInfo;\n\n      // Check if the window is already at the requested size - if so, just return early\n      if (currentWidth === width && currentHeight === height) {\n        await options.onAlreadyResized(width, height);\n        return;\n      }\n\n      // Save current window state before resize\n      const saveResult = await saveWindowState();\n      if (!saveResult) {\n        logError(\"Failed to save window state before resize\");\n      }\n\n      // Close main window first to avoid showing loading state\n      await closeMainWindow();\n\n      try {\n        // Call the Swift resizeWindow function\n        const result = await resizeWindow(width, height, currentX, currentY);\n\n        // Log basic size information\n        log(`Size comparison - Requested: ${width}\u00D7${height}, Actual: ${result.width}\u00D7${result.height}`);\n\n        // Check for window information\n        const { width: actualWidth, height: actualHeight, requestedWidth, requestedHeight } = result;\n\n        // Check if actual size differs from requested size (with small tolerance)\n        const sizeTolerance = 5; // 5 pixels tolerance\n        const sizeWasRestricted =\n          Math.abs(actualWidth - requestedWidth) > sizeTolerance ||\n          Math.abs(actualHeight - requestedHeight) > sizeTolerance;\n\n        // Call the completion handler with the result\n        await options.onResizeComplete(result.width, result.height, sizeWasRestricted);\n      } catch {\n        throw new Error(\"Failed to set window size\");\n      }\n    } catch (err) {\n      logError(\"\uD83D\uDED1 Error resizing window:\", err);\n      await options.onError(err);\n    }\n  }\n\n  return {\n    adjustWindowSize,\n  };\n}\n", "import { useState, useEffect, useRef } from \"react\";\nimport { WindowInfo } from \"../types/index\";\nimport { getActiveWindowInfo, WindowDetailsObject } from \"../swift-app\";\nimport { log, error as logError } from \"../utils/logger\";\n\n/**\n * Hook for getting window information using Swift API\n * @returns Window information related states and methods\n */\nexport function useWindowInfo() {\n  const [windowInfo, setWindowInfo] = useState<WindowInfo | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const isMounted = useRef(true);\n\n  // Update mounted state when component unmounts\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  /**\n   * Get current active window information\n   */\n  const getWindowDetails = async (): Promise<WindowInfo | null> => {\n    // Only update state if component is mounted\n    if (isMounted.current) {\n      setIsLoading(true);\n      setError(null);\n    }\n\n    try {\n      // Get active window info directly from Swift API\n      const result = await getActiveWindowInfo();\n\n      // Handle different response types\n      if (!result) {\n        throw new Error(\"Failed to get window information\");\n      }\n\n      // Handle string error response (legacy format)\n      if (typeof result === \"string\" && result.startsWith(\"Error:\")) {\n        throw new Error(result);\n      }\n\n      // Handle object response\n      if (typeof result === \"object\" && !Array.isArray(result)) {\n        const details = result as WindowDetailsObject;\n\n        // Handle error in object\n        if (details.error) {\n          if (details.message) {\n            throw new Error(details.message);\n          } else {\n            throw new Error(\"Unknown error occurred\");\n          }\n        }\n\n        // Extract window information\n        if (details.window) {\n          const { position, size } = details.window;\n\n          // Create window info object\n          const info: WindowInfo = {\n            x: position.x,\n            y: position.y,\n            width: size.width,\n            height: size.height,\n          };\n\n          // Log window info regardless of component mount state\n          if (details.app) {\n            log(`Active window info: ${details.app.name}.${details.app.processID}`, info);\n          } else {\n            log(\"Active window info:\", info);\n          }\n\n          // Only update state if component is still mounted\n          if (isMounted.current) {\n            setWindowInfo(info);\n          }\n\n          return info;\n        }\n      }\n\n      throw new Error(\"Invalid window information format\");\n    } catch (err) {\n      // Only update state if component is still mounted\n      if (isMounted.current) {\n        const errorMsg = err instanceof Error ? err.message : String(err);\n        logError(\"Error getting window info:\", errorMsg);\n        setError(new Error(errorMsg));\n      }\n      return null;\n    } finally {\n      // Only update state if component is still mounted\n      if (isMounted.current) {\n        setIsLoading(false);\n      }\n    }\n  };\n\n  return {\n    windowInfo,\n    isLoading,\n    error,\n    getWindowInfo: getWindowDetails,\n    refreshWindowInfo: getWindowDetails,\n  };\n}\n", "\nimport { environment } from \"@raycast/api\";\nimport { join } from \"path\";\nimport { chmod } from \"fs/promises\";\nimport { spawn } from \"child_process\";\n\nasync function runSwiftFunction(command, ...args) {\n  if (process.platform === \"win32\") {\n    return Promise.reject(new Error(\"Swift functions are not supported on Windows\"));\n  }\n  const swiftPath = join(environment.assetsPath, \"compiled_raycast_swift/swift\");\n  await chmod(swiftPath, \"755\");\n\n  return new Promise((resolve, reject) => {\n    const commandArgs = [command];\n    for (const arg of args) {\n      try {\n        commandArgs.push(JSON.stringify(arg, (k, v) => v === undefined ? null : v));\n      } catch (err) {\n        reject(new SwiftError(\"Failed to serialize input to JSON: \" + err.message));\n        return;\n      }\n    }\n    const child = spawn(swiftPath, commandArgs);\n    const stdout = [];\n    const stderr = [];\n\n    child.stdout?.on(\"data\", (data) => {\n      stdout.push(data.toString());\n    });\n    child.stderr?.on(\"data\", (data) => {\n      stderr.push(data.toString());\n    });\n\n    child.on(\"exit\", (code) => {\n      if (code === 0) {\n        try {\n          const result = stdout.join(\"\").trim();\n          if (result.length != 0) {\n            resolve(JSON.parse(result));\n          } else {\n            resolve(null);\n          }\n        } catch (err) {\n          const error = new SwiftError(\"Failed to deserialize result from JSON: \" + err.message);\n          error.stdout = stdout.join(\"\").trim();\n          error.stderr = stderr.join(\"\").trim();\n          reject(error);\n        }\n      } else {\n        const error = new SwiftError(stderr.join(\"\").trim() || stdout.join(\"\").trim() || \"Could not get any data\");\n        error.stdout = stdout.join(\"\").trim();\n        error.stderr = stderr.join(\"\").trim();\n        reject(error);\n      }\n    });\n\n    child.on(\"error\", (error) => {\n      reject(error);\n    });\n  });\n}\n\nexport async function getScreensInfo() {\n  return await runSwiftFunction(\"getScreensInfo\")\n}\n\nexport async function getActiveWindowInfo() {\n  return await runSwiftFunction(\"getActiveWindowInfo\")\n}\n\nexport async function getActiveWindowScreenInfo() {\n  return await runSwiftFunction(\"getActiveWindowScreenInfo\")\n}\n\nexport async function maximizeActiveWindow() {\n  return await runSwiftFunction(\"maximizeActiveWindow\")\n}\n\nexport async function resizeWindow(windowRefID, targetWidth, targetHeight, windowX, windowY, windowWidth, windowHeight, screenFrame, windowInfo, preservePosition) {\n  return await runSwiftFunction(\"resizeWindow\", windowRefID, targetWidth, targetHeight, windowX, windowY, windowWidth, windowHeight, screenFrame, windowInfo, preservePosition)\n}\n\nexport class SwiftError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"SwiftError\";\n  }\n}\n", "// The Swift function exports the middle layer\n\nimport {\n  getScreensInfo,\n  getActiveWindowScreenInfo,\n  getActiveWindowInfo,\n  maximizeActiveWindow,\n  resizeWindow as _resizeWindow,\n} from \"swift:../swift\";\nimport { WindowDetailsObject, ResizeResult } from \"./types\";\n\n// Note: getActiveWindowDetails will be renamed to getActiveWindowInfo in hooks\nexport { getScreensInfo, getActiveWindowScreenInfo, getActiveWindowInfo, maximizeActiveWindow };\nexport type { WindowDetailsObject };\n\n// Window resize function with detailed result\nexport function resizeWindow(\n  width: number,\n  height: number,\n  x?: number,\n  y?: number,\n  preservePosition: boolean = false,\n): Promise<ResizeResult> {\n  // TypeScript still sees the Swift function as returning Promise<boolean>\n  // even though we updated it to return ResizeResult. We need to use type assertion\n  // for now, but after Swift compilation this should work correctly.\n  return _resizeWindow(\n    undefined, // windowRefID: Swift func allows specifying a window, but this wrapper always targets the active one.\n    width, // targetWidth\n    height, // targetHeight\n    x, // Optional x position (currentX in Swift if undefined)\n    y, // Optional y position (currentY in Swift if undefined)\n    undefined, // windowWidth: Swift func can use pre-fetched width, unused here.\n    undefined, // windowHeight: Swift func can use pre-fetched height, unused here.\n    undefined, // screenFrame: Swift func can use pre-fetched screen frame, unused here.\n    undefined, // windowInfo: Swift func can use pre-fetched window details, unused here.\n    preservePosition, // Whether to preserve exact position\n  ) as Promise<ResizeResult>;\n}\n", "// Simple logger utility to control log output and prevent duplicates\n// Set to false to disable all logs\nconst ENABLE_LOGS = true;\n\n// Store recent log messages to avoid duplicates\nconst recentLogs = new Set<string>();\n// Store recent error messages separately\nconst recentErrorLogs = new Set<string>();\nconst LOG_EXPIRY_MS = 1000; // Clear logs after 1 second\n\n/**\n * Generate a stable hash for a log message and its parameters\n */\nfunction getLogKey(message: unknown, params: unknown[]): string {\n  try {\n    return `${String(message)}_${JSON.stringify(params)}`;\n  } catch {\n    return String(message);\n  }\n}\n\n/**\n * Log a message to the console if logging is enabled\n * Prevents duplicate logs within a short time window\n * Uses the 'recentLogs' Set.\n * @param message Log message or data\n * @param optionalParams Additional parameters to log\n */\nexport function log(message: unknown, ...optionalParams: unknown[]): void {\n  if (!ENABLE_LOGS) return;\n\n  const logKey = getLogKey(message, optionalParams);\n\n  // Skip if this exact log was recently output\n  if (recentLogs.has(logKey)) return;\n\n  // Add to recent logs and schedule cleanup\n  recentLogs.add(logKey);\n  setTimeout(() => {\n    recentLogs.delete(logKey);\n  }, LOG_EXPIRY_MS);\n\n  // Output the log\n  console.log(message, ...optionalParams);\n}\n\n/**\n * Log an error to the console if logging is enabled\n * Prevents duplicate errors within a short time window.\n * Uses the 'recentErrorLogs' Set.\n * @param message Error message or data\n * @param optionalParams Additional parameters to log\n */\nexport function error(message: unknown, ...optionalParams: unknown[]): void {\n  if (!ENABLE_LOGS) return;\n\n  const logKey = getLogKey(message, optionalParams);\n\n  // Skip if this exact error was recently output\n  if (recentErrorLogs.has(logKey)) return; // Use recentErrorLogs\n\n  // Add to recent error logs and schedule cleanup\n  recentErrorLogs.add(logKey); // Use recentErrorLogs\n  setTimeout(() => {\n    recentErrorLogs.delete(logKey); // Use recentErrorLogs\n  }, LOG_EXPIRY_MS);\n\n  // Output the error\n  console.error(message, ...optionalParams);\n}\n", "import { LocalStorage } from \"@raycast/api\";\nimport { useCallback, useEffect, useState, useRef } from \"react\";\nimport { log, error as logError } from \"../utils/logger\";\nimport { WindowDetailsObject, WindowState } from \"../types\";\nimport { getActiveWindowInfo } from \"../swift-app\";\nimport { CachedItem, createCacheItem, isCacheValid, HOUR_IN_MS } from \"../utils/storageUtils\";\n\n// Main storage key for all window states\nconst WINDOW_STATES_STORAGE_KEY = \"window-states\";\n// Cache expiration time (1 hour)\nconst CACHE_EXPIRATION_TIME_MS = HOUR_IN_MS;\n// Maximum number of states to keep in storage\nconst MAX_STATES_COUNT = 50;\n\nexport function useWindowStateManager() {\n  // Window states cache using useState\n  const [windowStatesCache, setWindowStatesCache] = useState<CachedItem<Record<string, WindowState>> | null>(null);\n  // Use refs to track mounted state and pending operations\n  const isMounted = useRef(true);\n  const pendingOperations = useRef<AbortController[]>([]);\n\n  // Safe state update function\n  const safeSetWindowStatesCache = useCallback((value: CachedItem<Record<string, WindowState>> | null) => {\n    if (isMounted.current) {\n      setWindowStatesCache(value);\n    }\n  }, []);\n\n  // Create abort controller for async operations\n  const createOperation = useCallback(() => {\n    const controller = new AbortController();\n    // Only abort operations when component is unmounted\n    if (!isMounted.current) {\n      controller.abort();\n    } else {\n      pendingOperations.current.push(controller);\n    }\n    return controller;\n  }, []);\n\n  // Remove operation from pending list\n  const removeOperation = useCallback((controller: AbortController) => {\n    // Only remove after operation is completed\n    if (!controller.signal.aborted) {\n      pendingOperations.current = pendingOperations.current.filter((c) => c !== controller);\n    }\n  }, []);\n\n  // Load all saved window states from storage\n  const loadAllWindowStates = useCallback(async (): Promise<Record<string, WindowState>> => {\n    const controller = createOperation();\n    try {\n      // Return cached data if valid\n      if (windowStatesCache && isCacheValid(windowStatesCache, CACHE_EXPIRATION_TIME_MS)) {\n        removeOperation(controller);\n        return windowStatesCache.value;\n      }\n\n      if (controller.signal.aborted) {\n        throw new Error(\"Operation aborted\");\n      }\n\n      const data = await LocalStorage.getItem<string>(WINDOW_STATES_STORAGE_KEY);\n      if (data && !controller.signal.aborted) {\n        const parsedData = JSON.parse(data) as Record<string, WindowState>;\n        // Update cache using the safe setter\n        safeSetWindowStatesCache(createCacheItem(parsedData));\n        removeOperation(controller);\n        return parsedData;\n      }\n    } catch (err) {\n      if (err instanceof Error && err.message === \"Operation aborted\") {\n        log(\"Load operation aborted\");\n      } else {\n        logError(\"Error loading window states:\", err);\n      }\n    }\n\n    // Initialize empty cache\n    if (!controller.signal.aborted) {\n      const initialCache = createCacheItem({});\n      safeSetWindowStatesCache(initialCache);\n      removeOperation(controller);\n      return initialCache.value;\n    }\n\n    removeOperation(controller);\n    return {};\n  }, [windowStatesCache, createOperation, removeOperation, safeSetWindowStatesCache]);\n\n  // Save all window states\n  const saveAllWindowStates = useCallback(\n    async (states: Record<string, WindowState>): Promise<void> => {\n      const controller = createOperation();\n      try {\n        if (controller.signal.aborted) return;\n\n        // Update cache using the safe setter\n        safeSetWindowStatesCache(createCacheItem(states));\n\n        // Persist to storage\n        await LocalStorage.setItem(WINDOW_STATES_STORAGE_KEY, JSON.stringify(states));\n      } catch (err) {\n        logError(\"Error saving window states:\", err);\n      } finally {\n        removeOperation(controller);\n      }\n    },\n    [createOperation, removeOperation, safeSetWindowStatesCache],\n  );\n\n  // Limit the number of states to MAX_STATES_COUNT\n  const limitStatesCount = useCallback(\n    async (states: Record<string, WindowState>): Promise<Record<string, WindowState>> => {\n      // If we're under the limit, no need to do anything\n      if (Object.keys(states).length <= MAX_STATES_COUNT) {\n        return states;\n      }\n\n      // Sort entries by timestamp (oldest first)\n      const sortedEntries = Object.entries(states).sort(([, a], [, b]) => a.timestamp - b.timestamp);\n\n      // Keep only the most recent MAX_STATES_COUNT entries\n      const entriesToKeep = sortedEntries.slice(-MAX_STATES_COUNT);\n      const limitedStates = Object.fromEntries(entriesToKeep);\n\n      log(`Limited window states from ${sortedEntries.length} to ${entriesToKeep.length}`);\n      return limitedStates;\n    },\n    [],\n  );\n\n  // Update a single window state\n  const updateSingleWindowState = useCallback(\n    async (key: string, state: WindowState): Promise<boolean> => {\n      const controller = createOperation();\n      try {\n        if (controller.signal.aborted) return false;\n\n        // Read current cache value. If null, load it first.\n        const currentCacheValue = windowStatesCache?.value ?? (await loadAllWindowStates());\n\n        if (controller.signal.aborted) return false;\n\n        // Update the specific entry\n        const updatedStates = { ...currentCacheValue, [key]: state };\n\n        // Limit the number of states\n        const limitedStates = await limitStatesCount(updatedStates);\n\n        if (controller.signal.aborted) return false;\n\n        // First persist to storage\n        try {\n          await LocalStorage.setItem(WINDOW_STATES_STORAGE_KEY, JSON.stringify(limitedStates));\n\n          // Only update cache after storage is confirmed\n          const newCache = createCacheItem(limitedStates);\n          safeSetWindowStatesCache(newCache);\n\n          return true;\n        } catch (storageError) {\n          logError(`Error persisting window state for ${key}:`, storageError);\n          return false;\n        }\n      } catch (err) {\n        logError(`Error updating window state for ${key}:`, err);\n        return false;\n      } finally {\n        removeOperation(controller);\n      }\n    },\n    [\n      windowStatesCache,\n      loadAllWindowStates,\n      safeSetWindowStatesCache,\n      limitStatesCount,\n      createOperation,\n      removeOperation,\n    ],\n  );\n\n  // Get current window info using Swift API\n  const getCurrentWindowInfo = useCallback(async (): Promise<WindowState | null> => {\n    const controller = createOperation();\n    try {\n      if (controller.signal.aborted) return null;\n\n      // Use Swift API to get window details\n      const windowDetails = (await getActiveWindowInfo()) as WindowDetailsObject;\n\n      if (controller.signal.aborted) return null;\n\n      if (windowDetails.error || !windowDetails.app || !windowDetails.window) {\n        throw new Error(\"Failed to get window information\");\n      }\n\n      // Extract window information\n      const processId = String(windowDetails.app.processID);\n      const size = windowDetails.window.size;\n      const position = windowDetails.window.position;\n\n      // Create unique identifier using app name, process ID and window number\n      const windowId = windowDetails.windowRefID\n        ? `${encodeURIComponent(windowDetails.app.name)}_${processId}_${windowDetails.windowRefID}`\n        : `${encodeURIComponent(windowDetails.app.name)}_${processId}`;\n\n      // Create window state object with size and position information\n      return {\n        windowId,\n        size: {\n          width: size.width,\n          height: size.height,\n        },\n        position: {\n          x: position.x,\n          y: position.y,\n        },\n        timestamp: Date.now(),\n      };\n    } catch (err) {\n      logError(\"Error getting window info:\", err);\n      return null;\n    } finally {\n      removeOperation(controller);\n    }\n  }, [createOperation, removeOperation]);\n\n  // Save window state\n  const saveWindowState = useCallback(async (): Promise<boolean> => {\n    const controller = createOperation();\n    try {\n      if (controller.signal.aborted) return false;\n\n      const windowInfo = await getCurrentWindowInfo();\n\n      if (controller.signal.aborted) return false;\n\n      if (!windowInfo) {\n        logError(\"No active window found\");\n        return false;\n      }\n\n      // Use windowId as key\n      const key = windowInfo.windowId;\n\n      // Update single state and check if it was successful\n      const saved = await updateSingleWindowState(key, windowInfo);\n\n      // Log if the save was successful\n      if (saved) {\n        log(`Saved window info: `, windowInfo);\n      }\n\n      return saved; // Return the actual status of the save operation\n    } catch (err) {\n      logError(\"Error saving window state:\", err);\n      return false;\n    } finally {\n      removeOperation(controller);\n    }\n  }, [getCurrentWindowInfo, updateSingleWindowState, createOperation, removeOperation]);\n\n  // Clean up expired window states\n  const cleanupExpiredStates = useCallback(async (): Promise<void> => {\n    const controller = createOperation();\n    try {\n      if (controller.signal.aborted) return;\n\n      const allStates = await loadAllWindowStates();\n\n      if (controller.signal.aborted) return;\n\n      const now = Date.now();\n      let hasChanges = false;\n\n      // Remove states older than expiration time\n      const updatedStates = { ...allStates };\n      for (const key in updatedStates) {\n        if (now - updatedStates[key].timestamp > CACHE_EXPIRATION_TIME_MS) {\n          log(`Removing expired window info: ${key}`);\n          delete updatedStates[key];\n          hasChanges = true;\n        }\n      }\n\n      if (hasChanges && !controller.signal.aborted) {\n        await saveAllWindowStates(updatedStates);\n      }\n    } catch (err) {\n      logError(\"Error cleaning up expired states:\", err);\n    } finally {\n      removeOperation(controller);\n    }\n  }, [loadAllWindowStates, saveAllWindowStates, createOperation, removeOperation]);\n\n  // Get window state without applying it\n  const getWindowState = useCallback(async (): Promise<WindowState | null> => {\n    const controller = createOperation();\n    try {\n      if (controller.signal.aborted) return null;\n\n      const windowInfo = await getCurrentWindowInfo();\n\n      if (controller.signal.aborted) return null;\n\n      if (!windowInfo) {\n        logError(\"No active window found for getting state\");\n        return null;\n      }\n\n      const key = windowInfo.windowId;\n      const allStates = await loadAllWindowStates();\n\n      if (controller.signal.aborted) return null;\n\n      // Check if there's a saved state for this window\n      if (allStates[key]) {\n        log(`Found state for ${key}`);\n        return allStates[key];\n      }\n\n      log(`No state found for ${key}`);\n      return null;\n    } catch (err) {\n      logError(\"Error getting window state:\", err);\n      return null;\n    } finally {\n      removeOperation(controller);\n    }\n  }, [getCurrentWindowInfo, loadAllWindowStates, createOperation, removeOperation]);\n\n  // Run cleanup on hook initialization and periodically\n  useEffect(() => {\n    // Mark component as mounted\n    isMounted.current = true;\n\n    // Initial cleanup\n    cleanupExpiredStates();\n\n    // Set up periodic cleanup every 1 hour\n    const cleanupInterval = setInterval(() => {\n      cleanupExpiredStates();\n    }, HOUR_IN_MS);\n\n    // Cleanup function to prevent memory leaks\n    return () => {\n      // Mark component as unmounted\n      isMounted.current = false;\n\n      // Clear interval\n      clearInterval(cleanupInterval);\n\n      // Abort any pending operations\n      pendingOperations.current.forEach((controller) => {\n        controller.abort();\n      });\n      pendingOperations.current = [];\n    };\n  }, [cleanupExpiredStates]);\n\n  return {\n    saveWindowState,\n    cleanupExpiredStates,\n    getWindowState,\n    createOperation,\n  };\n}\n", "/**\n * Cache related utility functions\n */\n\n// Cache item interface\nexport interface CachedItem<T> {\n  value: T;\n  timestamp: number;\n}\n\n/**\n * Check if a cached item is still valid\n * @param cachedItem The cached item\n * @param cacheDuration Cache duration in milliseconds\n * @returns Whether the cache is still valid\n */\nexport function isCacheValid<T>(cachedItem: CachedItem<T> | null, cacheDuration: number): boolean {\n  // Return false if no item or if cache duration is not positive\n  if (!cachedItem || cacheDuration <= 0) return false;\n\n  const now = Date.now();\n  return now - cachedItem.timestamp < cacheDuration;\n}\n\n/**\n * Create a new cache item\n * @param value The value to cache\n * @returns A cache item with timestamp\n */\nexport function createCacheItem<T>(value: T): CachedItem<T> {\n  return {\n    value,\n    timestamp: Date.now(),\n  };\n}\n\n// Constants\nexport const HOUR_IN_MS = 60 * 60 * 1000; // 1 hour\n", "import { List, ActionPanel, Action, openCommandPreferences, popToRoot, Icon } from \"@raycast/api\";\nimport { useState, useEffect } from \"react\";\n\ninterface FavResolutionEmptyViewProps {\n  isResizing?: boolean;\n  isInvalidSize?: boolean;\n}\n\ntype ViewState = \"invalid\" | \"resizing\" | \"empty\" | \"initializing\";\n\nexport function FavResolutionEmptyView({ isResizing = false, isInvalidSize = false }: FavResolutionEmptyViewProps) {\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  useEffect(() => {\n    // Provide a very short delay to ensure state stability\n    const timer = setTimeout(() => {\n      setIsInitialized(true);\n    }, 50);\n    return () => clearTimeout(timer);\n  }, []);\n\n  const getViewState = (): ViewState => {\n    if (!isInitialized) return \"initializing\";\n    if (isInvalidSize) return \"invalid\";\n    if (isResizing) return \"resizing\";\n    return \"empty\";\n  };\n\n  const getViewConfig = (state: ViewState) => {\n    const configs = {\n      invalid: {\n        icon: \"icons/fav-size-invalid.svg\",\n        title: \"Invalid or Missing Size Value\",\n        description: \"Set positive numbers for both width and height.\",\n      },\n      resizing: {\n        icon: \"icons/fav-size-resizing.svg\",\n        title: \"Resizing Window...\",\n        description: \"\",\n      },\n      empty: {\n        icon: \"icons/fav-size-empty.svg\",\n        title: \"Set your Favorite Size first\",\n        description: \"Press \u23CE to open the command settings.\",\n      },\n      initializing: {\n        icon: \"icons/fav-size-empty.svg\",\n        title: \"Loading...\",\n        description: \"\",\n      },\n    };\n    return configs[state];\n  };\n\n  const viewState = getViewState();\n  const viewConfig = getViewConfig(viewState);\n\n  return (\n    <List filtering={false} isLoading={!isInitialized}>\n      <List.EmptyView\n        icon={viewConfig.icon}\n        title={viewConfig.title}\n        description={viewConfig.description}\n        actions={\n          viewState !== \"resizing\" && (\n            <ActionPanel>\n              <Action\n                title=\"Open Settings\"\n                icon={Icon.Gear}\n                onAction={async () => {\n                  await openCommandPreferences();\n                  await popToRoot();\n                }}\n              />\n            </ActionPanel>\n          )\n        }\n      />\n    </List>\n  );\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { useState, useEffect } from \"react\";\n\ninterface SavedResolution {\n  width: number;\n  height: number;\n}\n\ninterface Preferences {\n  favWidth?: string;\n  favHeight?: string;\n}\n\nexport function useSavedFavResolution() {\n  const [savedResolution, setSavedResolution] = useState<SavedResolution | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isValid, setIsValid] = useState(true);\n\n  // Load saved resolution on mount\n  useEffect(() => {\n    try {\n      const preferences = getPreferenceValues<Preferences>();\n      const width = preferences.favWidth\n        ? (() => {\n            const parsed = parseInt(preferences.favWidth, 10);\n            return isNaN(parsed) ? null : parsed;\n          })()\n        : null;\n      const height = preferences.favHeight\n        ? (() => {\n            const parsed = parseInt(preferences.favHeight, 10);\n            return isNaN(parsed) ? null : parsed;\n          })()\n        : null;\n\n      // Validate if input is a valid number\n      const isWidthValid = !preferences.favWidth || !isNaN(Number(preferences.favWidth));\n      const isHeightValid = !preferences.favHeight || !isNaN(Number(preferences.favHeight));\n\n      if (isWidthValid && isHeightValid && width && height && width > 0 && height > 0) {\n        setSavedResolution({ width, height });\n        setIsValid(true);\n      } else if (preferences.favWidth || preferences.favHeight) {\n        // Only set to false when there are values but they are invalid\n        setSavedResolution(null);\n        setIsValid(false);\n      } else {\n        // No values provided\n        setSavedResolution(null);\n        setIsValid(true);\n      }\n    } catch (error) {\n      console.error(\"Error loading saved resolution:\", error);\n      setSavedResolution(null);\n      setIsValid(false);\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  return {\n    savedResolution,\n    isLoading,\n    isValid,\n  };\n}\n"],
  "mappings": "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",
  "names": ["apply_fav_size_exports", "__export", "Command", "__toCommonJS", "import_api", "import_api", "import_api", "import_react", "import_api", "import_path", "import_promises", "import_child_process", "runSwiftFunction", "command", "args", "swiftPath", "resolve", "reject", "commandArgs", "arg", "k", "v", "err", "SwiftError", "child", "stdout", "stderr", "data", "code", "result", "error", "getActiveWindowInfo", "runSwiftFunction", "resizeWindow", "windowRefID", "targetWidth", "targetHeight", "windowX", "windowY", "windowWidth", "windowHeight", "screenFrame", "windowInfo", "preservePosition", "runSwiftFunction", "SwiftError", "message", "resizeWindow", "width", "height", "x", "y", "preservePosition", "recentLogs", "recentErrorLogs", "LOG_EXPIRY_MS", "getLogKey", "message", "params", "log", "optionalParams", "logKey", "error", "useWindowInfo", "windowInfo", "setWindowInfo", "isLoading", "setIsLoading", "error", "setError", "isMounted", "getWindowDetails", "result", "getActiveWindowInfo", "details", "position", "size", "info", "log", "err", "errorMsg", "import_api", "import_react", "isCacheValid", "cachedItem", "cacheDuration", "createCacheItem", "value", "HOUR_IN_MS", "WINDOW_STATES_STORAGE_KEY", "CACHE_EXPIRATION_TIME_MS", "HOUR_IN_MS", "MAX_STATES_COUNT", "useWindowStateManager", "windowStatesCache", "setWindowStatesCache", "isMounted", "pendingOperations", "safeSetWindowStatesCache", "value", "createOperation", "controller", "removeOperation", "c", "loadAllWindowStates", "isCacheValid", "data", "parsedData", "createCacheItem", "err", "log", "error", "initialCache", "saveAllWindowStates", "states", "limitStatesCount", "sortedEntries", "a", "b", "entriesToKeep", "limitedStates", "updateSingleWindowState", "key", "state", "currentCacheValue", "updatedStates", "newCache", "storageError", "getCurrentWindowInfo", "windowDetails", "getActiveWindowInfo", "processId", "size", "position", "saveWindowState", "windowInfo", "saved", "cleanupExpiredStates", "allStates", "now", "hasChanges", "getWindowState", "cleanupInterval", "useBaseWindowResize", "getWindowInfo", "useWindowInfo", "saveWindowState", "useWindowStateManager", "adjustWindowSize", "width", "height", "options", "windowInfo", "currentX", "currentY", "currentWidth", "currentHeight", "error", "result", "resizeWindow", "log", "actualWidth", "actualHeight", "requestedWidth", "requestedHeight", "sizeTolerance", "sizeWasRestricted", "err", "useFavWindowResize", "adjustWindowSize", "useBaseWindowResize", "resizeWindow", "width", "height", "isRestricted", "err", "errorStr", "import_api", "import_react", "import_api", "import_react", "import_jsx_runtime", "FavResolutionEmptyView", "isResizing", "isInvalidSize", "isInitialized", "setIsInitialized", "timer", "getViewState", "getViewConfig", "state", "viewState", "viewConfig", "import_api", "import_react", "useSavedFavResolution", "savedResolution", "setSavedResolution", "isLoading", "setIsLoading", "isValid", "setIsValid", "preferences", "width", "parsed", "height", "isWidthValid", "isHeightValid", "error", "import_jsx_runtime", "Command", "resizeWindow", "useFavWindowResize", "isResizing", "setIsResizing", "savedResolution", "isLoading", "isValid", "useSavedFavResolution", "isExecuting", "hasResized", "applySavedResolution", "error", "FavResolutionEmptyView"]
}
