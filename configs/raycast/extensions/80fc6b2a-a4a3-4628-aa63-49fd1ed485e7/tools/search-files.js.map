{
  "version": 3,
  "sources": ["../../src/tools/search-files.ts", "../../src/utils/workspace.ts"],
  "sourcesContent": ["import { readdir } from \"node:fs/promises\";\nimport { join, relative } from \"node:path\";\nimport { resolveAndValidatePath, getWorkspaceRoot } from \"../utils/workspace\";\n\ntype Input = {\n  /**\n   * The search query to match against file names (supports fuzzy matching)\n   */\n  query: string;\n  /**\n   * Optional: The relative path to search within (defaults to workspace root)\n   */\n  path?: string;\n};\n\n/**\n * Recursively searches for files matching the query\n */\nasync function searchFilesRecursive(dirPath: string, query: string, workspaceRoot: string): Promise<string[]> {\n  const results: string[] = [];\n  const queryLower = query.toLowerCase();\n\n  try {\n    const entries = await readdir(dirPath, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = join(dirPath, entry.name);\n\n      // Skip common directories that should be ignored\n      if (entry.isDirectory()) {\n        const skipDirs = [\"node_modules\", \".git\", \".next\", \".vscode\", \"dist\", \"build\"];\n        if (skipDirs.includes(entry.name)) {\n          continue;\n        }\n\n        // Recursively search subdirectories\n        const subResults = await searchFilesRecursive(fullPath, query, workspaceRoot);\n        results.push(...subResults);\n      }\n\n      // Check if the file/directory name matches the query (fuzzy matching)\n      const nameLower = entry.name.toLowerCase();\n      if (fuzzyMatch(nameLower, queryLower)) {\n        // Return relative path from workspace root\n        const relativePath = relative(workspaceRoot, fullPath);\n        results.push(relativePath);\n      }\n    }\n  } catch (error) {\n    // Skip directories that can't be read\n    console.error(`Error reading directory ${dirPath}:`, error);\n  }\n\n  return results;\n}\n\n/**\n * Simple fuzzy matching algorithm\n * Returns true if all characters in the query appear in order in the target string\n */\nfunction fuzzyMatch(target: string, query: string): boolean {\n  // Simple substring match\n  if (target.includes(query)) {\n    return true;\n  }\n\n  // Fuzzy match: check if all query characters appear in order\n  let queryIndex = 0;\n  for (let i = 0; i < target.length && queryIndex < query.length; i++) {\n    if (target[i] === query[queryIndex]) {\n      queryIndex++;\n    }\n  }\n\n  return queryIndex === query.length;\n}\n\nexport default async function ({ query, path = \".\" }: Input) {\n  if (!query || query.trim() === \"\") {\n    throw new Error(\"Search query is required\");\n  }\n\n  const workspaceRoot = getWorkspaceRoot();\n  const searchPath = resolveAndValidatePath(path);\n\n  const results = await searchFilesRecursive(searchPath, query, workspaceRoot);\n\n  // Sort results by relevance (exact matches first, then by path length)\n  results.sort((a, b) => {\n    const aName = a.split(\"/\").pop()?.toLowerCase() || \"\";\n    const bName = b.split(\"/\").pop()?.toLowerCase() || \"\";\n    const queryLower = query.toLowerCase();\n\n    // Exact matches first\n    const aExact = aName === queryLower ? 0 : 1;\n    const bExact = bName === queryLower ? 0 : 1;\n    if (aExact !== bExact) return aExact - bExact;\n\n    // Then by whether the query is at the start\n    const aStarts = aName.startsWith(queryLower) ? 0 : 1;\n    const bStarts = bName.startsWith(queryLower) ? 0 : 1;\n    if (aStarts !== bStarts) return aStarts - bStarts;\n\n    // Then by path length (shorter paths first)\n    return a.length - b.length;\n  });\n\n  return results;\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { resolve, relative } from \"node:path\";\n\nexport const getWorkspaceRoot = () => {\n  const preferences = getPreferenceValues<Preferences>();\n\n  if (!preferences.workspaceRoot) {\n    throw new Error(\"Workspace root directory is not configured. Please set it in the extension preferences.\");\n  }\n\n  return resolve(preferences.workspaceRoot);\n};\n\nexport const isAutoEditEnabled = () => {\n  const preferences = getPreferenceValues<Preferences>();\n  return preferences.autoEdit === true;\n};\n\nexport const resolveAndValidatePath = (userPath: string) => {\n  if (!userPath) {\n    throw new Error(\"Path is required\");\n  }\n\n  const workspaceRoot = getWorkspaceRoot();\n\n  const absolutePath = resolve(workspaceRoot, userPath);\n\n  const normalizedWorkspaceRoot = resolve(workspaceRoot);\n  const normalizedAbsolutePath = resolve(absolutePath);\n\n  const relativePath = relative(normalizedWorkspaceRoot, normalizedAbsolutePath);\n\n  if (relativePath.startsWith(\"..\") || relativePath === \"..\") {\n    throw new Error(\n      `Path \"${userPath}\" is outside the configured workspace root \"${workspaceRoot}\". ` +\n        \"All file operations must be within the workspace root directory.\",\n    );\n  }\n\n  return normalizedAbsolutePath;\n};\n"],
  "mappings": "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",
  "names": ["search_files_exports", "__export", "search_files_default", "__toCommonJS", "import_promises", "import_node_path", "import_api", "import_node_path", "getWorkspaceRoot", "preferences", "resolveAndValidatePath", "userPath", "workspaceRoot", "getWorkspaceRoot", "absolutePath", "normalizedWorkspaceRoot", "normalizedAbsolutePath", "relativePath", "searchFilesRecursive", "dirPath", "query", "workspaceRoot", "results", "queryLower", "entries", "entry", "fullPath", "subResults", "nameLower", "fuzzyMatch", "relativePath", "error", "target", "queryIndex", "i", "search_files_default", "path", "getWorkspaceRoot", "searchPath", "resolveAndValidatePath", "a", "b", "aName", "bName", "aExact", "bExact", "aStarts", "bStarts"]
}
