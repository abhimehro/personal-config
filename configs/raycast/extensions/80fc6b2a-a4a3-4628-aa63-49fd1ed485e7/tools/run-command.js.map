{
  "version": 3,
  "sources": ["../../src/tools/run-command.ts", "../../src/utils/workspace.ts"],
  "sourcesContent": ["import { execFile } from \"node:child_process\";\nimport { promisify } from \"node:util\";\nimport { getWorkspaceRoot, resolveAndValidatePath } from \"../utils/workspace\";\n\nconst execFileAsync = promisify(execFile);\n\ntype Input = {\n  /**\n   * The shell command to execute\n   */\n  command: string;\n  /**\n   * Optional: Working directory relative to workspace root (defaults to workspace root)\n   */\n  cwd?: string;\n  /**\n   * Optional: Timeout in milliseconds (defaults to 30000ms / 30 seconds)\n   */\n  timeout?: number;\n};\n\nconst MAX_OUTPUT = 10000;\nconst DEFAULT_TIMEOUT = 30000;\n\n/**\n * Confirmation is always required for run-command (not affected by autoEdit preference)\n * This is a security measure since shell commands can have significant side effects\n */\nexport async function confirmation({ command, cwd }: Input) {\n  return {\n    message: \"Execute shell command?\",\n    info: [\n      { name: \"Command\", value: command },\n      { name: \"Working Directory\", value: cwd || \"(workspace root)\" },\n    ],\n  };\n}\n\n/**\n * Truncate output to prevent extremely large responses\n */\nfunction truncateOutput(output: string, maxLength: number): string {\n  if (output.length <= maxLength) return output;\n  return output.slice(0, maxLength) + `\\n... (truncated, ${output.length - maxLength} more characters)`;\n}\n\nexport default async function ({ command, cwd, timeout = DEFAULT_TIMEOUT }: Input) {\n  if (!command || command.trim() === \"\") {\n    throw new Error(\"Command is required\");\n  }\n\n  const workspaceRoot = getWorkspaceRoot();\n  const workingDir = cwd ? resolveAndValidatePath(cwd) : workspaceRoot;\n\n  // Use the user's interactive login shell to execute commands\n  // Note: Shell interpretation is intentional here to support shell features like pipes,\n  // redirects, and variable expansion. Security is handled via user confirmation prompt.\n  const userShell = process.env.SHELL || \"/bin/sh\";\n\n  try {\n    const { stdout, stderr } = await execFileAsync(userShell, [\"-l\", \"-c\", command], {\n      cwd: workingDir,\n      timeout,\n      maxBuffer: 1024 * 1024 * 5, // 5MB buffer\n      env: {\n        ...process.env,\n        // Ensure consistent output formatting\n        FORCE_COLOR: \"0\",\n        NO_COLOR: \"1\",\n      },\n    });\n\n    return {\n      success: true,\n      exitCode: 0,\n      stdout: truncateOutput(stdout, MAX_OUTPUT),\n      stderr: truncateOutput(stderr, MAX_OUTPUT),\n    };\n  } catch (error: unknown) {\n    const execError = error as {\n      code?: number;\n      stdout?: string;\n      stderr?: string;\n      message?: string;\n      killed?: boolean;\n    };\n\n    // Check if command was killed due to timeout\n    if (execError.killed) {\n      return {\n        success: false,\n        exitCode: -1,\n        stdout: truncateOutput(execError.stdout || \"\", MAX_OUTPUT),\n        stderr: `Command timed out after ${timeout}ms`,\n        timedOut: true,\n      };\n    }\n\n    return {\n      success: false,\n      exitCode: execError.code || 1,\n      stdout: truncateOutput(execError.stdout || \"\", MAX_OUTPUT),\n      stderr: truncateOutput(execError.stderr || execError.message || \"Unknown error\", MAX_OUTPUT),\n    };\n  }\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { resolve, relative } from \"node:path\";\n\nexport const getWorkspaceRoot = () => {\n  const preferences = getPreferenceValues<Preferences>();\n\n  if (!preferences.workspaceRoot) {\n    throw new Error(\"Workspace root directory is not configured. Please set it in the extension preferences.\");\n  }\n\n  return resolve(preferences.workspaceRoot);\n};\n\nexport const isAutoEditEnabled = () => {\n  const preferences = getPreferenceValues<Preferences>();\n  return preferences.autoEdit === true;\n};\n\nexport const resolveAndValidatePath = (userPath: string) => {\n  if (!userPath) {\n    throw new Error(\"Path is required\");\n  }\n\n  const workspaceRoot = getWorkspaceRoot();\n\n  const absolutePath = resolve(workspaceRoot, userPath);\n\n  const normalizedWorkspaceRoot = resolve(workspaceRoot);\n  const normalizedAbsolutePath = resolve(absolutePath);\n\n  const relativePath = relative(normalizedWorkspaceRoot, normalizedAbsolutePath);\n\n  if (relativePath.startsWith(\"..\") || relativePath === \"..\") {\n    throw new Error(\n      `Path \"${userPath}\" is outside the configured workspace root \"${workspaceRoot}\". ` +\n        \"All file operations must be within the workspace root directory.\",\n    );\n  }\n\n  return normalizedAbsolutePath;\n};\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,kBAAAE,EAAA,YAAAC,IAAA,eAAAC,EAAAJ,GAAA,IAAAK,EAAyB,8BACzBC,EAA0B,qBCD1B,IAAAC,EAAoC,wBACpCC,EAAkC,qBAErBC,EAAmB,IAAM,CACpC,IAAMC,KAAc,uBAAiC,EAErD,GAAI,CAACA,EAAY,cACf,MAAM,IAAI,MAAM,yFAAyF,EAG3G,SAAO,WAAQA,EAAY,aAAa,CAC1C,EAOO,IAAMC,EAA0BC,GAAqB,CAC1D,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,kBAAkB,EAGpC,IAAMC,EAAgBC,EAAiB,EAEjCC,KAAe,WAAQF,EAAeD,CAAQ,EAE9CI,KAA0B,WAAQH,CAAa,EAC/CI,KAAyB,WAAQF,CAAY,EAE7CG,KAAe,YAASF,EAAyBC,CAAsB,EAE7E,GAAIC,EAAa,WAAW,IAAI,GAAKA,IAAiB,KACpD,MAAM,IAAI,MACR,SAASN,CAAQ,+CAA+CC,CAAa,qEAE/E,EAGF,OAAOI,CACT,EDpCA,IAAME,KAAgB,aAAU,UAAQ,EAiBlCC,EAAa,IACbC,EAAkB,IAMxB,eAAsBC,EAAa,CAAE,QAAAC,EAAS,IAAAC,CAAI,EAAU,CAC1D,MAAO,CACL,QAAS,yBACT,KAAM,CACJ,CAAE,KAAM,UAAW,MAAOD,CAAQ,EAClC,CAAE,KAAM,oBAAqB,MAAOC,GAAO,kBAAmB,CAChE,CACF,CACF,CAKA,SAASC,EAAeC,EAAgBC,EAA2B,CACjE,OAAID,EAAO,QAAUC,EAAkBD,EAChCA,EAAO,MAAM,EAAGC,CAAS,EAAI;AAAA,kBAAqBD,EAAO,OAASC,CAAS,mBACpF,CAEA,eAAOC,EAAwB,CAAE,QAAAL,EAAS,IAAAC,EAAK,QAAAK,EAAUR,CAAgB,EAAU,CACjF,GAAI,CAACE,GAAWA,EAAQ,KAAK,IAAM,GACjC,MAAM,IAAI,MAAM,qBAAqB,EAGvC,IAAMO,EAAgBC,EAAiB,EACjCC,EAAaR,EAAMS,EAAuBT,CAAG,EAAIM,EAKjDI,EAAY,QAAQ,IAAI,OAAS,UAEvC,GAAI,CACF,GAAM,CAAE,OAAAC,EAAQ,OAAAC,CAAO,EAAI,MAAMjB,EAAce,EAAW,CAAC,KAAM,KAAMX,CAAO,EAAG,CAC/E,IAAKS,EACL,QAAAH,EACA,UAAW,QACX,IAAK,CACH,GAAG,QAAQ,IAEX,YAAa,IACb,SAAU,GACZ,CACF,CAAC,EAED,MAAO,CACL,QAAS,GACT,SAAU,EACV,OAAQJ,EAAeU,EAAQf,CAAU,EACzC,OAAQK,EAAeW,EAAQhB,CAAU,CAC3C,CACF,OAASiB,EAAgB,CACvB,IAAMC,EAAYD,EASlB,OAAIC,EAAU,OACL,CACL,QAAS,GACT,SAAU,GACV,OAAQb,EAAea,EAAU,QAAU,GAAIlB,CAAU,EACzD,OAAQ,2BAA2BS,CAAO,KAC1C,SAAU,EACZ,EAGK,CACL,QAAS,GACT,SAAUS,EAAU,MAAQ,EAC5B,OAAQb,EAAea,EAAU,QAAU,GAAIlB,CAAU,EACzD,OAAQK,EAAea,EAAU,QAAUA,EAAU,SAAW,gBAAiBlB,CAAU,CAC7F,CACF,CACF",
  "names": ["run_command_exports", "__export", "confirmation", "run_command_default", "__toCommonJS", "import_node_child_process", "import_node_util", "import_api", "import_node_path", "getWorkspaceRoot", "preferences", "resolveAndValidatePath", "userPath", "workspaceRoot", "getWorkspaceRoot", "absolutePath", "normalizedWorkspaceRoot", "normalizedAbsolutePath", "relativePath", "execFileAsync", "MAX_OUTPUT", "DEFAULT_TIMEOUT", "confirmation", "command", "cwd", "truncateOutput", "output", "maxLength", "run_command_default", "timeout", "workspaceRoot", "getWorkspaceRoot", "workingDir", "resolveAndValidatePath", "userShell", "stdout", "stderr", "error", "execError"]
}
