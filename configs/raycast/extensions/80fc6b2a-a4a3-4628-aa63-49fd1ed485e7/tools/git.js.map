{
  "version": 3,
  "sources": ["../../src/tools/git.ts", "../../src/utils/workspace.ts"],
  "sourcesContent": ["import { execFile } from \"node:child_process\";\nimport { promisify } from \"node:util\";\nimport { getWorkspaceRoot, isAutoEditEnabled } from \"../utils/workspace\";\n\nconst execFileAsync = promisify(execFile);\n\ntype GitSubcommand =\n  | \"status\"\n  | \"diff\"\n  | \"log\"\n  | \"add\"\n  | \"commit\"\n  | \"branch\"\n  | \"show\"\n  | \"stash\"\n  | \"checkout\"\n  | \"pull\"\n  | \"fetch\";\n\ntype Input = {\n  /**\n   * The git subcommand to execute\n   */\n  subcommand: GitSubcommand;\n  /**\n   * Optional: Additional arguments for the git command\n   */\n  args?: string;\n};\n\n// Commands that don't modify the repository (read-only)\nconst READ_ONLY_COMMANDS: GitSubcommand[] = [\"status\", \"diff\", \"log\", \"branch\", \"show\"];\n\n// Stash subcommands that are read-only (list, show)\n// Note: git stash without args, pop, drop, apply, push, etc. all modify the repository\nconst READ_ONLY_STASH_SUBCOMMANDS = new Set([\"list\", \"show\"]);\n\n// Dangerous flags that should be blocked (normalized form without values)\nconst DANGEROUS_FLAGS = new Set([\n  \"--force\",\n  \"--force-with-lease\",\n  \"--hard\",\n  \"--delete\",\n  \"-D\", // delete branch shorthand\n]);\n\n// Dangerous flag patterns for specific subcommands\n// Maps subcommand -> set of dangerous short flags\nconst DANGEROUS_SHORT_FLAGS_BY_COMMAND: Record<string, Set<string>> = {\n  push: new Set([\"-f\"]), // -f is --force for push\n  clean: new Set([\"-f\", \"-d\"]), // -f is force, -d removes directories\n  branch: new Set([\"-D\"]), // -D is force delete\n};\n\nconst MAX_OUTPUT = 10000;\nconst DEFAULT_TIMEOUT = 30000;\n\n/**\n * Parse arguments string into individual tokens, respecting quoted strings\n */\nfunction parseArgs(args: string): string[] {\n  const tokens: string[] = [];\n  let current = \"\";\n  let inQuote: string | null = null;\n\n  for (let i = 0; i < args.length; i++) {\n    const char = args[i];\n\n    if (inQuote) {\n      if (char === inQuote) {\n        // End of quoted string - add the content without quotes\n        tokens.push(current);\n        current = \"\";\n        inQuote = null;\n      } else {\n        current += char;\n      }\n    } else if (char === '\"' || char === \"'\") {\n      // Start of quoted string\n      if (current) {\n        tokens.push(current);\n        current = \"\";\n      }\n      inQuote = char;\n    } else if (/\\s/.test(char)) {\n      // Whitespace outside quotes - end current token\n      if (current) {\n        tokens.push(current);\n        current = \"\";\n      }\n    } else {\n      current += char;\n    }\n  }\n\n  // Add any remaining token\n  if (current) {\n    tokens.push(current);\n  }\n\n  return tokens;\n}\n\n/**\n * Normalize a flag by removing any value (e.g., \"--force=true\" -> \"--force\")\n */\nfunction normalizeFlag(flag: string): string {\n  const equalsIndex = flag.indexOf(\"=\");\n  if (equalsIndex !== -1) {\n    return flag.slice(0, equalsIndex);\n  }\n  return flag;\n}\n\n/**\n * Extract individual short flags from combined form (e.g., \"-fd\" -> [\"-f\", \"-d\"])\n */\nfunction expandShortFlags(flag: string): string[] {\n  // Only expand if it's a short flag (starts with single dash, not double)\n  if (flag.startsWith(\"-\") && !flag.startsWith(\"--\") && flag.length > 2) {\n    return flag\n      .slice(1)\n      .split(\"\")\n      .map((c) => `-${c}`);\n  }\n  return [flag];\n}\n\n/**\n * Check if the command arguments contain dangerous patterns\n */\nfunction containsDangerousPattern(subcommand: string, args: string): string | null {\n  const tokens = parseArgs(args);\n  const dangerousShortFlags = DANGEROUS_SHORT_FLAGS_BY_COMMAND[subcommand] || new Set();\n\n  for (const token of tokens) {\n    // Skip non-flag arguments\n    if (!token.startsWith(\"-\")) {\n      continue;\n    }\n\n    // Check long flags (normalize to handle --flag=value syntax)\n    if (token.startsWith(\"--\")) {\n      const normalized = normalizeFlag(token).toLowerCase();\n      if (DANGEROUS_FLAGS.has(normalized)) {\n        return normalized;\n      }\n      continue;\n    }\n\n    // Check short flags (expand combined flags like -fd)\n    const expandedFlags = expandShortFlags(token);\n    for (const flag of expandedFlags) {\n      // Check global dangerous flags (case-sensitive for -D)\n      if (DANGEROUS_FLAGS.has(flag)) {\n        return flag;\n      }\n      // Check subcommand-specific dangerous short flags\n      if (dangerousShortFlags.has(flag)) {\n        return `${flag} (in git ${subcommand})`;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Check if a git command is read-only (doesn't modify the repository)\n */\nfunction isReadOnlyCommand(subcommand: GitSubcommand, args: string): boolean {\n  if (READ_ONLY_COMMANDS.includes(subcommand)) {\n    return true;\n  }\n\n  // Special handling for stash - only list and show are read-only\n  if (subcommand === \"stash\") {\n    const tokens = parseArgs(args);\n    const stashSubcommand = tokens[0];\n    if (stashSubcommand === undefined) {\n      return false; // git stash without args creates a new stash (write operation)\n    }\n    return READ_ONLY_STASH_SUBCOMMANDS.has(stashSubcommand);\n  }\n\n  return false;\n}\n\n/**\n * Truncate output to prevent extremely large responses\n */\nfunction truncateOutput(output: string, maxLength: number): string {\n  if (output.length <= maxLength) return output;\n  return output.slice(0, maxLength) + `\\n... (truncated, ${output.length - maxLength} more characters)`;\n}\n\n/**\n * Confirmation handler for git commands\n * - Read-only commands don't need confirmation\n * - Dangerous patterns are blocked entirely\n * - Other write commands respect autoEdit preference\n */\nexport async function confirmation({ subcommand, args = \"\" }: Input) {\n  // Check for dangerous patterns first\n  const dangerousPattern = containsDangerousPattern(subcommand, args);\n  if (dangerousPattern) {\n    throw new Error(\n      `Dangerous git operation detected: \"${dangerousPattern}\". ` +\n        \"This operation is blocked for safety. Please use the git CLI directly if you really need this.\",\n    );\n  }\n\n  // Read-only commands don't need confirmation\n  if (isReadOnlyCommand(subcommand, args)) {\n    return undefined;\n  }\n\n  // Check autoEdit preference for write commands\n  if (isAutoEditEnabled()) {\n    return undefined;\n  }\n\n  // Show confirmation for write commands\n  const fullCommand = `git ${subcommand}${args ? ` ${args}` : \"\"}`;\n  return {\n    message: `Execute git command?`,\n    info: [{ name: \"Command\", value: fullCommand }],\n  };\n}\n\nexport default async function ({ subcommand, args = \"\" }: Input) {\n  // Validate subcommand\n  const validSubcommands: GitSubcommand[] = [\n    \"status\",\n    \"diff\",\n    \"log\",\n    \"add\",\n    \"commit\",\n    \"branch\",\n    \"show\",\n    \"stash\",\n    \"checkout\",\n    \"pull\",\n    \"fetch\",\n  ];\n\n  if (!validSubcommands.includes(subcommand)) {\n    throw new Error(`Invalid git subcommand: \"${subcommand}\". ` + `Allowed commands: ${validSubcommands.join(\", \")}`);\n  }\n\n  // Double-check for dangerous patterns (in case confirmation was bypassed)\n  const dangerousPattern = containsDangerousPattern(subcommand, args);\n  if (dangerousPattern) {\n    throw new Error(`Dangerous git operation blocked: \"${dangerousPattern}\"`);\n  }\n\n  const workspaceRoot = getWorkspaceRoot();\n  const command = `git ${subcommand}${args ? ` ${args}` : \"\"}`;\n\n  // Parse args into an array for safe execution\n  // This avoids shell interpretation entirely by passing arguments directly to git\n  const gitArgs = [subcommand, ...parseArgs(args)];\n\n  try {\n    // Execute git directly without a shell wrapper to prevent shell injection\n    const { stdout, stderr } = await execFileAsync(\"git\", gitArgs, {\n      cwd: workspaceRoot,\n      timeout: DEFAULT_TIMEOUT,\n      maxBuffer: 1024 * 1024 * 5, // 5MB buffer\n      env: {\n        ...process.env,\n        // Disable git pager for consistent output\n        GIT_PAGER: \"\",\n        // Ensure consistent output formatting\n        FORCE_COLOR: \"0\",\n        NO_COLOR: \"1\",\n      },\n    });\n\n    return {\n      success: true,\n      command,\n      output: truncateOutput(stdout || stderr, MAX_OUTPUT),\n    };\n  } catch (error: unknown) {\n    const execError = error as {\n      code?: number;\n      stdout?: string;\n      stderr?: string;\n      message?: string;\n    };\n\n    return {\n      success: false,\n      command,\n      exitCode: execError.code || 1,\n      output: truncateOutput(execError.stdout || \"\", MAX_OUTPUT),\n      error: truncateOutput(execError.stderr || execError.message || \"Unknown error\", MAX_OUTPUT),\n    };\n  }\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { resolve, relative } from \"node:path\";\n\nexport const getWorkspaceRoot = () => {\n  const preferences = getPreferenceValues<Preferences>();\n\n  if (!preferences.workspaceRoot) {\n    throw new Error(\"Workspace root directory is not configured. Please set it in the extension preferences.\");\n  }\n\n  return resolve(preferences.workspaceRoot);\n};\n\nexport const isAutoEditEnabled = () => {\n  const preferences = getPreferenceValues<Preferences>();\n  return preferences.autoEdit === true;\n};\n\nexport const resolveAndValidatePath = (userPath: string) => {\n  if (!userPath) {\n    throw new Error(\"Path is required\");\n  }\n\n  const workspaceRoot = getWorkspaceRoot();\n\n  const absolutePath = resolve(workspaceRoot, userPath);\n\n  const normalizedWorkspaceRoot = resolve(workspaceRoot);\n  const normalizedAbsolutePath = resolve(absolutePath);\n\n  const relativePath = relative(normalizedWorkspaceRoot, normalizedAbsolutePath);\n\n  if (relativePath.startsWith(\"..\") || relativePath === \"..\") {\n    throw new Error(\n      `Path \"${userPath}\" is outside the configured workspace root \"${workspaceRoot}\". ` +\n        \"All file operations must be within the workspace root directory.\",\n    );\n  }\n\n  return normalizedAbsolutePath;\n};\n"],
  "mappings": "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",
  "names": ["git_exports", "__export", "confirmation", "git_default", "__toCommonJS", "import_node_child_process", "import_node_util", "import_api", "import_node_path", "getWorkspaceRoot", "preferences", "isAutoEditEnabled", "execFileAsync", "READ_ONLY_COMMANDS", "READ_ONLY_STASH_SUBCOMMANDS", "DANGEROUS_FLAGS", "DANGEROUS_SHORT_FLAGS_BY_COMMAND", "MAX_OUTPUT", "DEFAULT_TIMEOUT", "parseArgs", "args", "tokens", "current", "inQuote", "i", "char", "normalizeFlag", "flag", "equalsIndex", "expandShortFlags", "c", "containsDangerousPattern", "subcommand", "dangerousShortFlags", "token", "normalized", "expandedFlags", "isReadOnlyCommand", "stashSubcommand", "truncateOutput", "output", "maxLength", "confirmation", "dangerousPattern", "isAutoEditEnabled", "git_default", "validSubcommands", "workspaceRoot", "getWorkspaceRoot", "command", "gitArgs", "stdout", "stderr", "error", "execError"]
}
