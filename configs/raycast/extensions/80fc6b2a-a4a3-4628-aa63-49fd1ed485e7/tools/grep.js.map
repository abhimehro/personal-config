{
  "version": 3,
  "sources": ["../../src/tools/grep.ts", "../../src/utils/workspace.ts"],
  "sourcesContent": ["import { readFile, readdir } from \"node:fs/promises\";\nimport { join, relative, extname, basename } from \"node:path\";\nimport { resolveAndValidatePath, getWorkspaceRoot } from \"../utils/workspace\";\n\ntype Input = {\n  /**\n   * The search query (text to search for)\n   */\n  query: string;\n  /**\n   * Optional: The relative path to search within (defaults to \".\" for entire workspace)\n   */\n  path?: string;\n  /**\n   * Optional: Glob pattern to filter files (e.g., \"*.ts\", \"*.{ts,tsx}\")\n   */\n  glob?: string;\n  /**\n   * Optional: Case-sensitive search (defaults to false)\n   */\n  caseSensitive?: boolean;\n};\n\ntype Match = {\n  file: string;\n  line: number;\n  content: string;\n};\n\nconst SKIP_DIRS = [\"node_modules\", \".git\", \"dist\", \"build\", \".next\", \".cache\", \".vscode\", \"coverage\"];\nconst MAX_MATCHES = 100;\nconst MAX_LINE_LENGTH = 200;\n\n// Binary file extensions to skip\nconst BINARY_EXTENSIONS = [\n  \".png\",\n  \".jpg\",\n  \".jpeg\",\n  \".gif\",\n  \".ico\",\n  \".svg\",\n  \".webp\",\n  \".woff\",\n  \".woff2\",\n  \".ttf\",\n  \".eot\",\n  \".otf\",\n  \".pdf\",\n  \".zip\",\n  \".tar\",\n  \".gz\",\n  \".7z\",\n  \".rar\",\n  \".exe\",\n  \".dll\",\n  \".so\",\n  \".dylib\",\n  \".mp3\",\n  \".mp4\",\n  \".avi\",\n  \".mov\",\n  \".mkv\",\n  \".db\",\n  \".sqlite\",\n  \".lock\",\n];\n\nfunction escapeRegExp(value: string) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\n/**\n * Simple glob pattern matching\n * Supports: *.ts, *.{ts,tsx}, test.*, etc.\n */\nfunction matchGlob(filename: string, pattern: string): boolean {\n  // Handle {a,b,c} syntax\n  if (pattern.includes(\"{\") && pattern.includes(\"}\")) {\n    const match = pattern.match(/\\{([^}]+)\\}/);\n    if (match) {\n      const options = match[1].split(\",\");\n      return options.some((opt) => {\n        const expandedPattern = pattern.replace(match[0], opt.trim());\n        return matchGlob(filename, expandedPattern);\n      });\n    }\n  }\n\n  // Convert glob to regex\n  const regexPattern = pattern.replace(/\\./g, \"\\\\.\").replace(/\\*/g, \".*\").replace(/\\?/g, \".\");\n\n  return new RegExp(`^${regexPattern}$`, \"i\").test(filename);\n}\n\n/**\n * Check if a file should be skipped (binary files)\n */\nfunction isBinaryFile(filename: string): boolean {\n  const ext = extname(filename).toLowerCase();\n  return BINARY_EXTENSIONS.includes(ext);\n}\n\n/**\n * Recursively walk through directories and yield file paths\n */\nasync function* walkDir(dir: string): AsyncGenerator<string> {\n  try {\n    const entries = await readdir(dir, { withFileTypes: true });\n    for (const entry of entries) {\n      if (SKIP_DIRS.includes(entry.name)) continue;\n\n      const fullPath = join(dir, entry.name);\n      if (entry.isDirectory()) {\n        yield* walkDir(fullPath);\n      } else if (entry.isFile() && !isBinaryFile(entry.name)) {\n        yield fullPath;\n      }\n    }\n  } catch {\n    // Skip directories that can't be read\n  }\n}\n\nexport default async function ({ query, path = \".\", glob, caseSensitive = false }: Input) {\n  if (!query || query.trim() === \"\") {\n    throw new Error(\"Search query is required\");\n  }\n\n  const workspaceRoot = getWorkspaceRoot();\n  const searchRoot = resolveAndValidatePath(path);\n\n  const flags = caseSensitive ? \"g\" : \"gi\";\n  const escapedQuery = escapeRegExp(query);\n  const regex = new RegExp(escapedQuery, flags);\n\n  const matches: Match[] = [];\n  let filesSearched = 0;\n\n  for await (const filePath of walkDir(searchRoot)) {\n    // Apply glob filter if specified\n    if (glob) {\n      const filename = basename(filePath);\n      if (!matchGlob(filename, glob)) continue;\n    }\n\n    // Stop if we've found enough matches\n    if (matches.length >= MAX_MATCHES) break;\n\n    filesSearched++;\n\n    try {\n      const content = await readFile(filePath, \"utf8\");\n      const lines = content.split(\"\\n\");\n\n      lines.forEach((lineContent, index) => {\n        // Reset regex lastIndex for each line (important for global flag)\n        regex.lastIndex = 0;\n\n        if (regex.test(lineContent) && matches.length < MAX_MATCHES) {\n          matches.push({\n            file: relative(workspaceRoot, filePath),\n            line: index + 1,\n            content: lineContent.trim().slice(0, MAX_LINE_LENGTH),\n          });\n        }\n      });\n    } catch {\n      // Skip files that can't be read (e.g., binary files, permission issues)\n    }\n  }\n\n  return {\n    matches,\n    totalMatches: matches.length,\n    filesSearched,\n    truncated: matches.length >= MAX_MATCHES,\n  };\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { resolve, relative } from \"node:path\";\n\nexport const getWorkspaceRoot = () => {\n  const preferences = getPreferenceValues<Preferences>();\n\n  if (!preferences.workspaceRoot) {\n    throw new Error(\"Workspace root directory is not configured. Please set it in the extension preferences.\");\n  }\n\n  return resolve(preferences.workspaceRoot);\n};\n\nexport const isAutoEditEnabled = () => {\n  const preferences = getPreferenceValues<Preferences>();\n  return preferences.autoEdit === true;\n};\n\nexport const resolveAndValidatePath = (userPath: string) => {\n  if (!userPath) {\n    throw new Error(\"Path is required\");\n  }\n\n  const workspaceRoot = getWorkspaceRoot();\n\n  const absolutePath = resolve(workspaceRoot, userPath);\n\n  const normalizedWorkspaceRoot = resolve(workspaceRoot);\n  const normalizedAbsolutePath = resolve(absolutePath);\n\n  const relativePath = relative(normalizedWorkspaceRoot, normalizedAbsolutePath);\n\n  if (relativePath.startsWith(\"..\") || relativePath === \"..\") {\n    throw new Error(\n      `Path \"${userPath}\" is outside the configured workspace root \"${workspaceRoot}\". ` +\n        \"All file operations must be within the workspace root directory.\",\n    );\n  }\n\n  return normalizedAbsolutePath;\n};\n"],
  "mappings": "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",
  "names": ["grep_exports", "__export", "grep_default", "__toCommonJS", "import_promises", "import_node_path", "import_api", "import_node_path", "getWorkspaceRoot", "preferences", "resolveAndValidatePath", "userPath", "workspaceRoot", "getWorkspaceRoot", "absolutePath", "normalizedWorkspaceRoot", "normalizedAbsolutePath", "relativePath", "SKIP_DIRS", "MAX_MATCHES", "MAX_LINE_LENGTH", "BINARY_EXTENSIONS", "escapeRegExp", "value", "matchGlob", "filename", "pattern", "match", "opt", "expandedPattern", "regexPattern", "isBinaryFile", "ext", "walkDir", "dir", "entries", "entry", "fullPath", "grep_default", "query", "path", "glob", "caseSensitive", "workspaceRoot", "getWorkspaceRoot", "searchRoot", "resolveAndValidatePath", "flags", "escapedQuery", "regex", "matches", "filesSearched", "filePath", "lineContent", "index"]
}
