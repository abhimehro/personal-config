{
  "version": 3,
  "sources": ["../src/shuffle.tsx", "../src/lib/utils.ts"],
  "sourcesContent": ["import { showHUD } from \"@raycast/api\";\nimport { sendCommand, getCurrentTrack } from \"./lib/utils\";\n\nexport default async function ShuffleCommand() {\n  const success = await sendCommand(\"toggleShuffle\");\n\n  if (success) {\n    await new Promise((resolve) => setTimeout(resolve, 200));\n\n    const updatedTrack = await getCurrentTrack();\n\n    const status = updatedTrack?.isShuffled ? \"Off\" : \"On\";\n    await showHUD(`\uD83D\uDD00 Shuffle: ${status}`);\n  } else {\n    await showHUD(\"\u274C Failed to toggle shuffle\");\n  }\n}\n", "import {\n  showHUD,\n  showToast,\n  Toast,\n  environment,\n  launchCommand,\n  LaunchType,\n  open,\n  getPreferenceValues,\n  openExtensionPreferences,\n} from \"@raycast/api\";\nimport { spawn, execSync } from \"child_process\";\nimport { join } from \"path\";\nimport { existsSync, readFileSync, writeFileSync, unlinkSync } from \"fs\";\n\nexport interface Track {\n  title: string;\n  artist: string;\n  isPlaying: boolean;\n  playingFrom: string;\n  currentTime: string;\n  duration: string;\n  isLiked: boolean;\n  isShuffled: boolean;\n  repeatMode: \"off\" | \"all\" | \"one\";\n  timestamp?: number;\n  receivedAt?: string;\n}\n\nexport interface ServerStatus {\n  startTime: string;\n  requestCount: number;\n  lastTrackUpdate: string | null;\n  lastCommandSent: string | null;\n  chromeConnected: boolean;\n  raycastConnected: boolean;\n  uptime: number;\n  currentTrack: Track | null;\n  pendingCommandsCount: number;\n  port: number;\n  pid: number;\n}\n\nexport type ServerConnectionStatus = \"connected\" | \"disconnected\" | \"connecting\";\n\nconst API_BASE_URL = \"http://localhost:3049\";\nconst REQUEST_TIMEOUT = 1000;\nconst PID_FILE_NAME = \"server.pid\";\n\nconst SERVER_SCRIPT_CONTENT = `\nconst http = require(\"http\")\nconst fs = require(\"fs\")\nconst path = require(\"path\")\n\nconst PORT = 3049\nconst PID_FILE = path.join(__dirname, \"server.pid\")\n\nlet currentTrackData = null\nconst pendingCommands = []\nconst serverStats = {\n  startTime: new Date(),\n  requestCount: 0,\n  lastTrackUpdate: null,\n  lastCommandSent: null,\n  chromeConnected: false,\n  raycastConnected: false,\n  pid: process.pid,\n}\n\nconst AUTH_TOKEN = process.env.LOCAL_API_AUTH_TOKEN;\nif (!AUTH_TOKEN) {\n    console.error(\"FATAL: LOCAL_API_AUTH_TOKEN environment variable not set. Server cannot start securely.\");\n    process.exit(1);\n}\n\ntry {\n  fs.writeFileSync(PID_FILE, process.pid.toString())\n} catch (error) {\n  console.error('Failed to write PID file:', error);\n}\n\nfunction setCORSHeaders(res) {\n  res.setHeader(\"Access-Control-Allow-Origin\", \"*\")\n  res.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n  res.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n}\n\nfunction parseBody(req) {\n  return new Promise((resolve, reject) => {\n    let body = \"\"\n    req.on(\"data\", (chunk) => {\n      body += chunk.toString()\n    })\n    req.on(\"end\", () => {\n      try {\n        resolve(body ? JSON.parse(body) : {})\n      } catch (error) {\n        reject(new Error(\"Invalid JSON body\"))\n      }\n    })\n    req.on(\"error\", (err) => {\n      reject(err)\n    })\n  })\n}\n\nconst server = http.createServer(async (req, res) => {\n  serverStats.requestCount++\n  const parsedUrl = new URL(req.url, \\`http://localhost:\\${PORT}\\`)\n  const pathname = parsedUrl.pathname\n  const method = req.method\n\n  setCORSHeaders(res)\n  if (method === \"OPTIONS\") {\n    res.writeHead(200)\n    res.end()\n    return\n  }\n\n  if (!(pathname === \"/\" && method === \"GET\")) {\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        res.writeHead(401, { \"Content-Type\": \"application/json\" });\n        res.end(JSON.stringify({ error: \"Unauthorized: Missing or invalid Authorization header\" }));\n        return;\n    }\n    const requestToken = authHeader.split(' ')[1];\n    if (requestToken !== AUTH_TOKEN) {\n        res.writeHead(403, { \"Content-Type\": \"application/json\" });\n        res.end(JSON.stringify({ error: \"Forbidden: Invalid token\" }));\n        return;\n    }\n  }\n\n  try {\n    if (pathname === \"/\" && method === \"GET\") {\n      res.writeHead(200, { \"Content-Type\": \"text/html\" });\n      res.end(\\`\n  <!DOCTYPE html>\n  <html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Tidal Raycast API Server</title>\n    <style>\n      body {\n        font-family: system-ui, sans-serif;\n        margin: 0;\n        background: #f2f2f7;\n        color: #1c1c1e;\n        line-height: 1.6;\n      }\n      .container {\n        max-width: 700px;\n        margin: 4rem auto;\n        padding: 2rem;\n        background: #fff;\n        border-radius: 12px;\n        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);\n      }\n      h1 {\n        color: #007aff;\n        font-size: 1.8rem;\n        margin-bottom: 1rem;\n      }\n      h2 {\n        margin-top: 2rem;\n        color: #444;\n      }\n      p {\n        margin-bottom: 1rem;\n      }\n      ul {\n        padding-left: 1.2rem;\n      }\n      li {\n        margin-bottom: 0.5rem;\n      }\n      code {\n        background: #f1f1f1;\n        padding: 0.2rem 0.4rem;\n        border-radius: 4px;\n        font-family: monospace;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"container\">\n      <h1>Tidal Raycast API Server</h1>\n      <p>This server connects your <strong>Raycast</strong> and <strong>Chrome</strong> extensions for a smooth Tidal experience.</p>\n\n      <h2>Endpoints</h2>\n      <ul>\n        <li><code>POST /track-data</code> \u2014 Send track info from Chrome</li>\n        <li><code>GET /current-track</code> \u2014 Get current track in Raycast</li>\n        <li><code>POST /send-command</code> \u2014 Send a control command from Raycast</li>\n        <li><code>GET /get-command</code> \u2014 Chrome polls for the next command</li>\n        <li><code>GET /status</code> \u2014 View server status and metrics</li>\n        <li><code>GET /health</code> \u2014 Quick server health check</li>\n      </ul>\n\n      <h2>Authentication</h2>\n      <p>All API requests (except this page) require a <code>Bearer Token</code> in the <code>Authorization</code> header. Set this in your Raycast preferences.</p>\n\n      <h2>Tips</h2>\n      <ul>\n        <li>To stop the server, run <strong>\"Stop Server\"</strong> in Raycast.</li>\n        <li>Need help? Run <strong>\"Setup Guide\"</strong> in Raycast for setup instructions.</li>\n      </ul>\n    </div>\n  </body>\n  </html>\n\\`);\n    } else if (pathname === \"/track-data\" && method === \"POST\") {\n      const trackData = await parseBody(req)\n      currentTrackData = { ...trackData, receivedAt: new Date().toISOString() }\n      serverStats.lastTrackUpdate = new Date()\n      serverStats.chromeConnected = true\n      res.writeHead(200, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify({ status: \"success\", message: \"Track data received\" }))\n    } else if (pathname === \"/get-command\" && method === \"GET\") {\n      serverStats.chromeConnected = true\n      if (pendingCommands.length > 0) {\n        const command = pendingCommands.shift()\n        res.writeHead(200, { \"Content-Type\": \"application/json\" })\n        res.end(JSON.stringify(command))\n      } else {\n        res.writeHead(200, { \"Content-Type\": \"application/json\" })\n        res.end(JSON.stringify({ status: \"no-commands\" }))\n      }\n    } else if (pathname === \"/current-track\" && method === \"GET\") {\n      serverStats.raycastConnected = true\n      res.writeHead(200, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify(currentTrackData || { status: \"no-data\" }))\n    } else if (pathname === \"/send-command\" && method === \"POST\") {\n      const command = await parseBody(req)\n      command.timestamp = Date.now()\n      command.id = Math.random().toString(36).substr(2, 9)\n      pendingCommands.push(command)\n      serverStats.lastCommandSent = new Date()\n      serverStats.raycastConnected = true\n      res.writeHead(200, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify({ status: \"success\", message: \"Command queued\" }))\n    } else if (pathname === \"/status\" && method === \"GET\") {\n      const status = {\n        ...serverStats,\n        uptime: Date.now() - serverStats.startTime.getTime(),\n        currentTrack: currentTrackData,\n        pendingCommandsCount: pendingCommands.length,\n        port: PORT,\n      }\n      res.writeHead(200, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify(status, null, 2))\n    } else if (pathname === \"/health\" && method === \"GET\") {\n      res.writeHead(200, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify({ status: \"healthy\", timestamp: new Date().toISOString(), pid: process.pid }))\n    } else {\n      res.writeHead(404, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify({ error: \"Not found\", path: pathname }))\n    }\n  } catch (error) {\n    console.error(\\`Request error: \\${error.message} for \\${method} \\${pathname}\\`)\n    res.writeHead(500, { \"Content-Type\": \"application/json\" })\n    res.end(JSON.stringify({ error: \"Internal server error\", message: error.message }))\n  }\n})\n\nserver.on(\"error\", (err) => {\n  console.error(\\`Server error: \\${err.message}\\`)\n  if (err.code === \"EADDRINUSE\") {\n    console.error(\\`Port \\${PORT} is already in use. Another server instance might be running.\\`)\n    process.exit(1)\n  }\n})\n\nserver\n  .listen(PORT, () => {\n    console.log(\\`Server listening on port \\${PORT}\\`);\n  })\n  .on(\"error\", (err) => {\n    console.error(\\`Failed to listen on port \\${PORT}: \\${err.message}\\`)\n    process.exit(1)\n  })\n\nfunction gracefulShutdown() {\n  server.close(() => {\n    try {\n      if (fs.existsSync(PID_FILE)) {\n        fs.unlinkSync(PID_FILE)\n      }\n    } catch (error) {\n      console.error('Error removing PID file on shutdown:', error);\n    }\n    process.exit(0)\n  })\n\n  setTimeout(() => {\n    process.exit(1)\n  }, 5000)\n}\n\nprocess.on(\"SIGINT\", gracefulShutdown)\nprocess.on(\"SIGTERM\", gracefulShutdown)\n\nprocess.on(\"uncaughtException\", (error, origin) => {\n  console.error(\\`Uncaught exception: \\${error.message} at \\${origin}]\\`)\n  console.error(error)\n  process.exit(1)\n})\n\nprocess.on(\"unhandledRejection\", (reason, promise) => {\n  console.error(\\`Unhandled rejection at promise: \\${promise}, reason: \\${reason}\\`)\n  console.error(reason)\n})\n\nsetInterval(() => {\n  const now = Date.now()\n  if (serverStats.lastTrackUpdate && now - serverStats.lastTrackUpdate.getTime() > 15000) {\n    serverStats.chromeConnected = false\n  }\n}, 5000)\n`;\n\nexport const log = (message: string, level: \"info\" | \"error\" | \"warn\" = \"info\") => {\n  console.log(`[TIDAL] [${level.toUpperCase()}] ${message}`);\n};\n\nconst getAuthHeaders = (): Record<string, string> => {\n  const { localApiAuthToken } = getPreferenceValues<{ localApiAuthToken: string }>();\n  if (!localApiAuthToken) {\n    const errorMessage = \"Auth token not found in Raycast preferences.\";\n    log(errorMessage, \"error\");\n    throw new Error(errorMessage);\n  }\n  return {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${localApiAuthToken}`,\n  };\n};\n\nexport const getCurrentTrack = async (): Promise<Track | null> => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/current-track`, {\n      headers: getAuthHeaders(),\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n\n    if (response.ok) {\n      const data = (await response.json()) as Track | { status: string };\n      if (\"status\" in data && data.status === \"no-data\") {\n        return null;\n      }\n      return data as Track;\n    }\n    if (response.status === 401 || response.status === 403) {\n      log(\"Authentication failed when getting current track.\", \"error\");\n    }\n    return null;\n  } catch (error) {\n    log(`Failed to get current track: ${error}`, \"error\");\n    return null;\n  }\n};\n\nexport const sendCommand = async (action: string, serverStatus?: ServerConnectionStatus): Promise<boolean> => {\n  if (serverStatus && serverStatus !== \"connected\") {\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Not Connected\",\n      message: \"Server connection lost\",\n    });\n    return false;\n  }\n\n  try {\n    const response = await fetch(`${API_BASE_URL}/send-command`, {\n      method: \"POST\",\n      headers: getAuthHeaders(),\n      body: JSON.stringify({ action }),\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n\n    if (response.ok) {\n      log(`Command sent: ${action}`);\n      return true;\n    } else {\n      const errorText = await response.text();\n      throw new Error(`Command failed: ${response.status} - ${errorText}`);\n    }\n  } catch (error) {\n    log(`Command error: ${error}`, \"error\");\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Command Failed\",\n      message: String(error),\n    });\n    return false;\n  }\n};\n\nexport const getServerStatus = async (): Promise<ServerStatus | null> => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/status`, {\n      headers: getAuthHeaders(),\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n\n    if (response.ok) {\n      return (await response.json()) as ServerStatus;\n    }\n    return null;\n  } catch (error) {\n    log(`Failed to get server status: ${error}`, \"error\");\n    return null;\n  }\n};\n\nexport const checkServerHealth = async (): Promise<boolean> => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/health`, {\n      headers: getAuthHeaders(),\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n    return response.ok;\n  } catch (error) {\n    log(`Health check failed: ${error}`, \"error\");\n    return false;\n  }\n};\n\nexport const refreshData = async (): Promise<{\n  track: Track;\n  hasRealData: boolean;\n  serverStatus: ServerConnectionStatus;\n}> => {\n  try {\n    const headers = getAuthHeaders();\n    const healthResponse = await fetch(`${API_BASE_URL}/health`, {\n      headers,\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n\n    if (!healthResponse.ok) {\n      throw new Error(`Health check failed: ${healthResponse.status}`);\n    }\n\n    const trackResponse = await fetch(`${API_BASE_URL}/current-track`, {\n      headers,\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n\n    if (trackResponse.ok) {\n      const trackData = (await trackResponse.json()) as Track | { status: string };\n\n      if (\"status\" in trackData && trackData.status === \"no-data\") {\n        return {\n          track: {\n            title: \"No Track Playing\",\n            artist: \"Open Tidal and play a song\",\n            isPlaying: false,\n            playingFrom: \"\",\n            currentTime: \"0:00\",\n            duration: \"0:00\",\n            isLiked: false,\n            isShuffled: false,\n            repeatMode: \"off\",\n          },\n          hasRealData: false,\n          serverStatus: \"connected\",\n        };\n      } else if (\"title\" in trackData && trackData.title && trackData.title !== \"Unknown\") {\n        const dataAge = Date.now() - (trackData.timestamp || 0);\n        if (dataAge < 600000) {\n          return {\n            track: trackData as Track,\n            hasRealData: true,\n            serverStatus: \"connected\",\n          };\n        } else {\n          return {\n            track: {\n              title: \"Stale Data\",\n              artist: `Chrome inactive? (${Math.round(dataAge / 1000)}s)`,\n              isPlaying: false,\n              playingFrom: \"\",\n              currentTime: \"0:00\",\n              duration: \"0:00\",\n              isLiked: false,\n              isShuffled: false,\n              repeatMode: \"off\",\n            },\n            hasRealData: false,\n            serverStatus: \"connected\",\n          };\n        }\n      }\n    }\n\n    return {\n      track: {\n        title: \"Loading...\",\n        artist: \"Connecting...\",\n        isPlaying: false,\n        playingFrom: \"\",\n        currentTime: \"0:00\",\n        duration: \"0:00\",\n        isLiked: false,\n        isShuffled: false,\n        repeatMode: \"off\",\n      },\n      hasRealData: false,\n      serverStatus: \"connected\",\n    };\n  } catch (error) {\n    log(`Refresh error: ${error} (is the server down??)`, \"error\");\n    return {\n      track: {\n        title: \"Connection Error\",\n        artist: \"Server not responding or auth failed\",\n        isPlaying: false,\n        playingFrom: \"\",\n        currentTime: \"0:00\",\n        duration: \"0:00\",\n        isLiked: false,\n        isShuffled: false,\n        repeatMode: \"off\",\n      },\n      hasRealData: false,\n      serverStatus: \"disconnected\",\n    };\n  }\n};\n\nexport const createCommandHandler = (\n  action: string,\n  serverStatus: ServerConnectionStatus,\n  refreshCallback: () => void,\n) => {\n  return async () => {\n    const success = await sendCommand(action, serverStatus);\n    if (success) {\n      setTimeout(refreshCallback, 200);\n    }\n  };\n};\n\nexport const showServerStatusCmd = async () => {\n  try {\n    await launchCommand({ name: \"server-status\", type: LaunchType.UserInitiated });\n  } catch (error) {\n    log(`Failed to open server status: ${error}`, \"error\");\n    await showToast({ style: Toast.Style.Failure, title: \"Failed to Open Status\" });\n  }\n};\n\nexport const editPreferencesCmd = async () => {\n  try {\n    await openExtensionPreferences();\n  } catch (error) {\n    log(`Failed to open preferences: ${error}`, \"error\");\n    await showToast({ style: Toast.Style.Failure, title: \"Failed to Open Preferences\" });\n  }\n};\n\nexport const showDocsCmd = async () => {\n  try {\n    await open(\"https://github.com/Ek2100/tidal/blob/main/raycast/README.md\");\n  } catch (error) {\n    log(`Failed to open documentation: ${error}`, \"error\");\n    await showToast({ style: Toast.Style.Failure, title: \"Failed to Open Documentation\" });\n  }\n};\n\nexport const manualStartServer = async (refreshCallback: () => void) => {\n  try {\n    await launchCommand({ name: \"start-server\", type: LaunchType.Background });\n    setTimeout(refreshCallback, 2000);\n  } catch (error) {\n    await showHUD(\"\u274C Failed to start server\");\n    log(`Failed to start server: ${error}`, \"error\");\n  }\n};\n\nexport const manualStopServer = async () => {\n  try {\n    await launchCommand({ name: \"stop-server\", type: LaunchType.Background });\n  } catch (error) {\n    await showHUD(\"\u274C Failed to stop server\");\n    log(`Failed to stop server: ${error}`, \"error\");\n  }\n};\n\nconst findNodePath = (): string => {\n  const possiblePaths = [\n    \"/usr/local/bin/node\",\n    \"/opt/homebrew/bin/node\",\n    \"/usr/bin/node\",\n    \"/bin/node\",\n    process.execPath,\n  ];\n\n  for (const path of possiblePaths) {\n    if (existsSync(path)) {\n      log(`Found Node.js at: ${path}`);\n      return path;\n    }\n  }\n\n  try {\n    const nodePath = execSync(\"which node\", { encoding: \"utf8\" }).trim();\n    if (nodePath && existsSync(nodePath)) {\n      log(`Found Node.js via 'which': ${nodePath}`);\n      return nodePath;\n    }\n  } catch (error) {\n    log(`'which node' failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  log(\"Could not find Node.js path, falling back to 'node'\");\n  return \"node\";\n};\n\nexport const startServer = async (): Promise<boolean> => {\n  const serverDir = environment.supportPath;\n  const serverPath = join(serverDir, \"server.js\");\n  const pidPath = join(serverDir, PID_FILE_NAME);\n\n  log(`Server dir: ${serverDir}`);\n  log(`Server path: ${serverPath}`);\n  log(`PID file path: ${pidPath}`);\n\n  const { localApiAuthToken } = getPreferenceValues<{ localApiAuthToken: string }>();\n  if (!localApiAuthToken) {\n    await showHUD(\"\u274C Auth Token is not set in preferences!\");\n    log(\"Auth token is missing from preferences. Cannot start server.\", \"error\");\n    return false;\n  }\n\n  if (!existsSync(serverPath)) {\n    try {\n      writeFileSync(serverPath, SERVER_SCRIPT_CONTENT);\n      log(\"Created server.js file\");\n    } catch (error) {\n      log(`Failed to create server.js: ${error instanceof Error ? error.message : String(error)}`);\n      return false;\n    }\n  }\n\n  const nodePath = findNodePath();\n\n  if (existsSync(pidPath)) {\n    try {\n      const pid = readFileSync(pidPath, \"utf8\").trim();\n      log(`Found PID file with PID: ${pid}`);\n      try {\n        execSync(`ps -p ${pid} -o comm=`);\n        log(`Server process ${pid} seems to be running.`);\n        manualStopServer();\n        return true;\n      } catch (e) {\n        log(`Process ${pid} not running: ${e instanceof Error ? e.message : String(e)}`);\n        writeFileSync(pidPath, \"\");\n      }\n    } catch (err) {\n      log(`Error reading PID file: ${err instanceof Error ? err.message : String(err)}`);\n    }\n  }\n\n  try {\n    const healthResponse = await fetch(`${API_BASE_URL}/health`, {\n      headers: getAuthHeaders(),\n      signal: AbortSignal.timeout(500),\n    });\n    if (healthResponse.ok) {\n      const healthData = (await healthResponse.json()) as HealthStatusResponse;\n      log(`Server already healthy on port 3049 (PID: ${healthData.pid}).`);\n      await showHUD(`\u2705 Server already running (PID: ${healthData.pid})`);\n      if (!existsSync(pidPath) || readFileSync(pidPath, \"utf8\").trim() !== String(healthData.pid)) {\n        writeFileSync(pidPath, String(healthData.pid));\n        log(`Updated PID file with PID: ${healthData.pid}`);\n      }\n      return true;\n    }\n  } catch (e) {\n    log(`Health check failed: ${e instanceof Error ? e.message : String(e)}`, \"warn\");\n  }\n\n  log(`Attempting to start server using Node.js at: ${nodePath}`);\n  try {\n    const serverProcess = spawn(nodePath, [serverPath], {\n      detached: true,\n      stdio: \"ignore\",\n      cwd: serverDir,\n      env: {\n        ...process.env,\n        LOCAL_API_AUTH_TOKEN: localApiAuthToken,\n        PATH: process.env.PATH || \"/usr/local/bin:/opt/homebrew/bin:/usr/bin:/bin\",\n      },\n    });\n    serverProcess.unref();\n    log(`Server process spawned with PID: ${serverProcess.pid}`);\n\n    if (serverProcess.pid) {\n      writeFileSync(pidPath, serverProcess.pid.toString());\n      log(`Wrote new PID ${serverProcess.pid} to ${pidPath}`);\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 2500));\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/health`, {\n        headers: getAuthHeaders(),\n        signal: AbortSignal.timeout(1000),\n      });\n      if (response.ok) {\n        const data = (await response.json()) as HealthStatusResponse;\n        log(`Server started successfully (PID: ${data.pid}).`);\n        await showHUD(`\u2705 Server started (PID: ${data.pid})`);\n        return true;\n      } else {\n        throw new Error(`Server responded with ${response.status}`);\n      }\n    } catch (err) {\n      log(`Server health check failed after start: ${err instanceof Error ? err.message : String(err)}`);\n      await showHUD(`\u274C Server failed to start. Node.js: ${nodePath}`);\n      return false;\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    log(`Error spawning server process: ${errorMessage}`);\n    await showHUD(`\u274C Failed to start server: ${errorMessage}`);\n    return false;\n  }\n};\n\ninterface HealthStatusResponse {\n  status: string;\n  timestamp: string;\n  pid: number;\n}\n\nexport const stopServer = async (): Promise<boolean> => {\n  const serverDir = environment.supportPath;\n  const pidPath = join(serverDir, PID_FILE_NAME);\n\n  log(`Attempting to stop server. PID file path: ${pidPath}`);\n\n  let pidToKill: number | null = null;\n  let initialPidFromFile: string | null = null;\n\n  const checkServerHealthAndGetPid = async (): Promise<number | null> => {\n    try {\n      const healthResponse = await fetch(`${API_BASE_URL}/health`, {\n        headers: getAuthHeaders(),\n        signal: AbortSignal.timeout(500),\n      });\n      if (healthResponse.ok) {\n        const data = (await healthResponse.json()) as HealthStatusResponse;\n        if (data && typeof data.pid === \"number\") {\n          return data.pid;\n        }\n      }\n    } catch (e) {\n      log(`Health check failed: ${e instanceof Error ? e.message : String(e)}`, \"warn\");\n    }\n    return null;\n  };\n\n  if (existsSync(pidPath)) {\n    try {\n      initialPidFromFile = readFileSync(pidPath, \"utf8\").trim();\n      if (initialPidFromFile) {\n        pidToKill = parseInt(initialPidFromFile);\n        log(`Found PID file with PID: ${pidToKill}`);\n      } else {\n        log(\"PID file is empty.\");\n      }\n    } catch (err) {\n      log(`Error reading PID file: ${err instanceof Error ? err.message : String(err)}.`, \"warn\");\n    }\n  } else {\n    log(\"PID file not found.\");\n  }\n\n  if (pidToKill === null) {\n    log(\"No PID from file. Checking server health endpoint for active PID.\");\n    pidToKill = await checkServerHealthAndGetPid();\n    if (pidToKill) {\n      log(`Found active server PID from health endpoint: ${pidToKill}`);\n    } else {\n      log(\"Server not detected as running via health endpoint. Nothing to stop.\", \"warn\");\n      await showHUD(\"\u26A0\uFE0F Server not running\");\n      return false;\n    }\n  }\n\n  try {\n    log(`Attempting to send SIGTERM to PID: ${pidToKill}`);\n    process.kill(pidToKill, \"SIGTERM\");\n    log(`Sent SIGTERM to PID: ${pidToKill}`);\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n  } catch (error) {\n    log(\n      `Error sending SIGTERM to PID ${pidToKill}: ${\n        error instanceof Error ? error.message : String(error)\n      }. Process might not exist or already stopped.`,\n      \"warn\",\n    );\n  }\n\n  const finalRunningPid = await checkServerHealthAndGetPid();\n\n  if (finalRunningPid === null) {\n    log(\"Server stopped successfully (final health check failed).\");\n    await showHUD(\"\u2705 Server stopped\");\n    if (existsSync(pidPath)) {\n      try {\n        unlinkSync(pidPath);\n        log(\"PID file removed.\");\n      } catch (unlinkErr) {\n        log(`Error removing PID file: ${unlinkErr instanceof Error ? unlinkErr.message : String(unlinkErr)}`, \"error\");\n      }\n    }\n    const serverPath = join(serverDir, \"server.js\");\n    if (existsSync(serverPath)) {\n      try {\n        unlinkSync(serverPath);\n        log(\"server.js file removed.\");\n      } catch (unlinkErr) {\n        log(\n          `Error removing server.js file: ${unlinkErr instanceof Error ? unlinkErr.message : String(unlinkErr)}`,\n          \"error\",\n        );\n      }\n    }\n    return true;\n  } else {\n    let message = `\u274C Server still running (PID: ${finalRunningPid}).`;\n    if (initialPidFromFile && finalRunningPid === parseInt(initialPidFromFile)) {\n      message += ` Original PID ${initialPidFromFile} is still active.`;\n    } else if (initialPidFromFile && finalRunningPid !== parseInt(initialPidFromFile)) {\n      message += ` New PID ${finalRunningPid} detected, original PID ${initialPidFromFile} might have been replaced.`;\n    } else {\n      message += ` No original PID file found.`;\n    }\n    log(message, \"error\");\n    await showHUD(message);\n    return false;\n  }\n};\n\nexport const formatUptime = (ms: number): string => {\n  const seconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n\n  if (hours > 0) return `${hours}h ${minutes % 60}m`;\n  if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\n  return `${seconds}s`;\n};\n\nexport const getRepeatIcon = (repeatMode: Track[\"repeatMode\"]) => {\n  switch (repeatMode) {\n    case \"one\":\n      return \"ArrowClockwise\";\n    case \"all\":\n      return \"Repeat\";\n    default:\n      return \"MinusCircle\";\n  }\n};\n\nexport const getRepeatTitle = (repeatMode: Track[\"repeatMode\"]) => {\n  switch (repeatMode) {\n    case \"one\":\n      return \"Repeat: One\";\n    case \"all\":\n      return \"Repeat: All\";\n    default:\n      return \"Repeat: Off\";\n  }\n};\n\nexport const getServerIcon = (serverStatus: ServerConnectionStatus) => {\n  switch (serverStatus) {\n    case \"connected\":\n      return \"CheckCircle\";\n    case \"connecting\":\n      return \"Clock\";\n    default:\n      return \"XMarkCircle\";\n  }\n};\n\nexport const getMenubarTitle = (hasRealData: boolean, currentTrack: Track, serverStatus: ServerConnectionStatus) => {\n  if (hasRealData && currentTrack.title !== \"Loading...\" && currentTrack.title !== \"No Track Playing\") {\n    return `${currentTrack.title.substring(0, 25)}${currentTrack.title.length > 25 ? \"...\" : \"\"}`;\n  }\n\n  switch (serverStatus) {\n    case \"connected\":\n      return \"Tidal\";\n    case \"connecting\":\n      return \"Loading...\";\n    default:\n      return \"Offline\";\n  }\n};\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAwB,wBCAxB,IAAAC,EAUO,wBAmCP,IAAMC,EAAe,wBACfC,EAAkB,IAqRjB,IAAMC,EAAM,CAACC,EAAiBC,EAAmC,SAAW,CACjF,QAAQ,IAAI,YAAYA,EAAM,YAAY,CAAC,KAAKD,CAAO,EAAE,CAC3D,EAEME,EAAiB,IAA8B,CACnD,GAAM,CAAE,kBAAAC,CAAkB,KAAI,uBAAmD,EACjF,GAAI,CAACA,EAAmB,CACtB,IAAMC,EAAe,+CACrB,MAAAL,EAAIK,EAAc,OAAO,EACnB,IAAI,MAAMA,CAAY,CAC9B,CACA,MAAO,CACL,eAAgB,mBAChB,cAAe,UAAUD,CAAiB,EAC5C,CACF,EAEaE,EAAkB,SAAmC,CAChE,GAAI,CACF,IAAMC,EAAW,MAAM,MAAM,GAAGC,CAAY,iBAAkB,CAC5D,QAASL,EAAe,EACxB,OAAQ,YAAY,QAAQM,CAAe,CAC7C,CAAC,EAED,GAAIF,EAAS,GAAI,CACf,IAAMG,EAAQ,MAAMH,EAAS,KAAK,EAClC,MAAI,WAAYG,GAAQA,EAAK,SAAW,UAC/B,KAEFA,CACT,CACA,OAAIH,EAAS,SAAW,KAAOA,EAAS,SAAW,MACjDP,EAAI,oDAAqD,OAAO,EAE3D,IACT,OAASW,EAAO,CACd,OAAAX,EAAI,gCAAgCW,CAAK,GAAI,OAAO,EAC7C,IACT,CACF,EAEaC,EAAc,MAAOC,EAAgBC,IAA4D,CAC5G,GAAIA,GAAgBA,IAAiB,YACnC,sBAAU,CACR,MAAO,QAAM,MAAM,QACnB,MAAO,gBACP,QAAS,wBACX,CAAC,EACM,GAGT,GAAI,CACF,IAAMP,EAAW,MAAM,MAAM,GAAGC,CAAY,gBAAiB,CAC3D,OAAQ,OACR,QAASL,EAAe,EACxB,KAAM,KAAK,UAAU,CAAE,OAAAU,CAAO,CAAC,EAC/B,OAAQ,YAAY,QAAQJ,CAAe,CAC7C,CAAC,EAED,GAAIF,EAAS,GACX,OAAAP,EAAI,iBAAiBa,CAAM,EAAE,EACtB,GACF,CACL,IAAME,EAAY,MAAMR,EAAS,KAAK,EACtC,MAAM,IAAI,MAAM,mBAAmBA,EAAS,MAAM,MAAMQ,CAAS,EAAE,CACrE,CACF,OAASJ,EAAO,CACd,OAAAX,EAAI,kBAAkBW,CAAK,GAAI,OAAO,KACtC,aAAU,CACR,MAAO,QAAM,MAAM,QACnB,MAAO,iBACP,QAAS,OAAOA,CAAK,CACvB,CAAC,EACM,EACT,CACF,ED3YA,eAAOK,GAAwC,CAG7C,GAFgB,MAAMC,EAAY,eAAe,EAEpC,CACX,MAAM,IAAI,QAASC,GAAY,WAAWA,EAAS,GAAG,CAAC,EAIvD,IAAMC,GAFe,MAAMC,EAAgB,IAEd,WAAa,MAAQ,KAClD,QAAM,WAAQ,sBAAeD,CAAM,EAAE,CACvC,MACE,QAAM,WAAQ,iCAA4B,CAE9C",
  "names": ["shuffle_exports", "__export", "ShuffleCommand", "__toCommonJS", "import_api", "import_api", "API_BASE_URL", "REQUEST_TIMEOUT", "log", "message", "level", "getAuthHeaders", "localApiAuthToken", "errorMessage", "getCurrentTrack", "response", "API_BASE_URL", "REQUEST_TIMEOUT", "data", "error", "sendCommand", "action", "serverStatus", "errorText", "ShuffleCommand", "sendCommand", "resolve", "status", "getCurrentTrack"]
}
