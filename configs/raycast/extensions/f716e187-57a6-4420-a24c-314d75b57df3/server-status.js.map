{
  "version": 3,
  "sources": ["../src/server-status.tsx", "../src/lib/utils.ts"],
  "sourcesContent": ["\"use client\";\n\nimport { List, Icon, Color, ActionPanel, Action } from \"@raycast/api\";\nimport { useState, useEffect } from \"react\";\nimport { getServerStatus, startServer, stopServer, formatUptime, type ServerStatus } from \"./lib/utils\";\n\nexport default function ServerStatusCommand() {\n  const [status, setStatus] = useState<ServerStatus | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchStatus = async () => {\n    try {\n      const data = await getServerStatus();\n      if (data) {\n        setStatus(data);\n        setError(null);\n      } else {\n        setError(\"Server not reachable\");\n        setStatus(null);\n      }\n    } catch (err) {\n      console.error(\"Error fetching server status:\", err);\n      setError(\"Server not reachable\");\n      setStatus(null);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleStartServer = async () => {\n    setIsLoading(true);\n    await startServer();\n    setTimeout(fetchStatus, 2000);\n  };\n\n  const handleStopServer = async () => {\n    setIsLoading(true);\n    await stopServer();\n    setTimeout(fetchStatus, 1000);\n  };\n\n  useEffect(() => {\n    fetchStatus();\n    const interval = setInterval(fetchStatus, 2000);\n    return () => clearInterval(interval);\n  }, []);\n\n  if (isLoading) {\n    return <List isLoading={true} />;\n  }\n\n  if (error) {\n    return (\n      <List>\n        <List.Item\n          title=\"Server Status\"\n          subtitle={error}\n          icon={{ source: Icon.XMarkCircle, tintColor: Color.Red }}\n          actions={\n            <ActionPanel>\n              <Action title=\"Start Server\" onAction={handleStartServer} icon={Icon.Play} />\n              <Action title=\"Refresh\" onAction={fetchStatus} icon={Icon.RotateClockwise} />\n            </ActionPanel>\n          }\n        />\n      </List>\n    );\n  }\n\n  return (\n    <List>\n      <List.Section title=\"Server Status\">\n        <List.Item\n          title=\"Server\"\n          subtitle={`Running on port ${status?.port}`}\n          icon={{ source: Icon.CheckCircle, tintColor: Color.Green }}\n          accessories={[{ text: `Uptime: ${formatUptime(status?.uptime || 0)}` }]}\n          actions={\n            <ActionPanel>\n              <Action title=\"Stop Server\" onAction={handleStopServer} icon={Icon.Stop} />\n              <Action title=\"Refresh\" onAction={fetchStatus} icon={Icon.RotateClockwise} />\n            </ActionPanel>\n          }\n        />\n        <List.Item\n          title=\"Requests\"\n          subtitle={`${status?.requestCount} total requests`}\n          icon={{ source: Icon.BarChart, tintColor: Color.Blue }}\n        />\n      </List.Section>\n\n      <List.Section title=\"Connections\">\n        <List.Item\n          title=\"Chrome Extension\"\n          subtitle={status?.chromeConnected ? \"Connected\" : \"Disconnected\"}\n          icon={{\n            source: status?.chromeConnected ? Icon.CheckCircle : Icon.XMarkCircle,\n            tintColor: status?.chromeConnected ? Color.Green : Color.Red,\n          }}\n          accessories={\n            status?.lastTrackUpdate\n              ? [{ text: `Last update: ${new Date(status.lastTrackUpdate).toLocaleTimeString()}` }]\n              : [{ text: \"No updates\" }]\n          }\n        />\n        <List.Item\n          title=\"Raycast Extension\"\n          subtitle={status?.raycastConnected ? \"Connected\" : \"Disconnected\"}\n          icon={{\n            source: status?.raycastConnected ? Icon.CheckCircle : Icon.XMarkCircle,\n            tintColor: status?.raycastConnected ? Color.Green : Color.Red,\n          }}\n          accessories={\n            status?.lastCommandSent\n              ? [{ text: `Last command: ${new Date(status.lastCommandSent).toLocaleTimeString()}` }]\n              : [{ text: \"No commands\" }]\n          }\n        />\n      </List.Section>\n\n      <List.Section title=\"Current State\">\n        <List.Item\n          title=\"Track\"\n          subtitle={\n            status?.currentTrack?.title\n              ? `${status.currentTrack.title} - ${status.currentTrack.artist}`\n              : \"No track data\"\n          }\n          icon={{ source: Icon.Music, tintColor: Color.Purple }}\n          accessories={\n            status?.currentTrack?.isPlaying\n              ? [{ text: \"Playing\", icon: { source: Icon.Play, tintColor: Color.Green } }]\n              : [{ text: \"Paused\", icon: { source: Icon.Pause, tintColor: Color.Orange } }]\n          }\n        />\n        <List.Item\n          title=\"Pending Commands\"\n          subtitle={`${status?.pendingCommandsCount || 0} commands in queue`}\n          icon={{ source: Icon.Terminal, tintColor: Color.Yellow }}\n        />\n      </List.Section>\n    </List>\n  );\n}\n", "import {\n  showHUD,\n  showToast,\n  Toast,\n  environment,\n  launchCommand,\n  LaunchType,\n  open,\n  getPreferenceValues,\n  openExtensionPreferences,\n} from \"@raycast/api\";\nimport { spawn, execSync } from \"child_process\";\nimport { join } from \"path\";\nimport { existsSync, readFileSync, writeFileSync, unlinkSync } from \"fs\";\n\nexport interface Track {\n  title: string;\n  artist: string;\n  isPlaying: boolean;\n  playingFrom: string;\n  currentTime: string;\n  duration: string;\n  isLiked: boolean;\n  isShuffled: boolean;\n  repeatMode: \"off\" | \"all\" | \"one\";\n  timestamp?: number;\n  receivedAt?: string;\n}\n\nexport interface ServerStatus {\n  startTime: string;\n  requestCount: number;\n  lastTrackUpdate: string | null;\n  lastCommandSent: string | null;\n  chromeConnected: boolean;\n  raycastConnected: boolean;\n  uptime: number;\n  currentTrack: Track | null;\n  pendingCommandsCount: number;\n  port: number;\n  pid: number;\n}\n\nexport type ServerConnectionStatus = \"connected\" | \"disconnected\" | \"connecting\";\n\nconst API_BASE_URL = \"http://localhost:3049\";\nconst REQUEST_TIMEOUT = 1000;\nconst PID_FILE_NAME = \"server.pid\";\n\nconst SERVER_SCRIPT_CONTENT = `\nconst http = require(\"http\")\nconst fs = require(\"fs\")\nconst path = require(\"path\")\n\nconst PORT = 3049\nconst PID_FILE = path.join(__dirname, \"server.pid\")\n\nlet currentTrackData = null\nconst pendingCommands = []\nconst serverStats = {\n  startTime: new Date(),\n  requestCount: 0,\n  lastTrackUpdate: null,\n  lastCommandSent: null,\n  chromeConnected: false,\n  raycastConnected: false,\n  pid: process.pid,\n}\n\nconst AUTH_TOKEN = process.env.LOCAL_API_AUTH_TOKEN;\nif (!AUTH_TOKEN) {\n    console.error(\"FATAL: LOCAL_API_AUTH_TOKEN environment variable not set. Server cannot start securely.\");\n    process.exit(1);\n}\n\ntry {\n  fs.writeFileSync(PID_FILE, process.pid.toString())\n} catch (error) {\n  console.error('Failed to write PID file:', error);\n}\n\nfunction setCORSHeaders(res) {\n  res.setHeader(\"Access-Control-Allow-Origin\", \"*\")\n  res.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n  res.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n}\n\nfunction parseBody(req) {\n  return new Promise((resolve, reject) => {\n    let body = \"\"\n    req.on(\"data\", (chunk) => {\n      body += chunk.toString()\n    })\n    req.on(\"end\", () => {\n      try {\n        resolve(body ? JSON.parse(body) : {})\n      } catch (error) {\n        reject(new Error(\"Invalid JSON body\"))\n      }\n    })\n    req.on(\"error\", (err) => {\n      reject(err)\n    })\n  })\n}\n\nconst server = http.createServer(async (req, res) => {\n  serverStats.requestCount++\n  const parsedUrl = new URL(req.url, \\`http://localhost:\\${PORT}\\`)\n  const pathname = parsedUrl.pathname\n  const method = req.method\n\n  setCORSHeaders(res)\n  if (method === \"OPTIONS\") {\n    res.writeHead(200)\n    res.end()\n    return\n  }\n\n  if (!(pathname === \"/\" && method === \"GET\")) {\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        res.writeHead(401, { \"Content-Type\": \"application/json\" });\n        res.end(JSON.stringify({ error: \"Unauthorized: Missing or invalid Authorization header\" }));\n        return;\n    }\n    const requestToken = authHeader.split(' ')[1];\n    if (requestToken !== AUTH_TOKEN) {\n        res.writeHead(403, { \"Content-Type\": \"application/json\" });\n        res.end(JSON.stringify({ error: \"Forbidden: Invalid token\" }));\n        return;\n    }\n  }\n\n  try {\n    if (pathname === \"/\" && method === \"GET\") {\n      res.writeHead(200, { \"Content-Type\": \"text/html\" });\n      res.end(\\`\n  <!DOCTYPE html>\n  <html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Tidal Raycast API Server</title>\n    <style>\n      body {\n        font-family: system-ui, sans-serif;\n        margin: 0;\n        background: #f2f2f7;\n        color: #1c1c1e;\n        line-height: 1.6;\n      }\n      .container {\n        max-width: 700px;\n        margin: 4rem auto;\n        padding: 2rem;\n        background: #fff;\n        border-radius: 12px;\n        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);\n      }\n      h1 {\n        color: #007aff;\n        font-size: 1.8rem;\n        margin-bottom: 1rem;\n      }\n      h2 {\n        margin-top: 2rem;\n        color: #444;\n      }\n      p {\n        margin-bottom: 1rem;\n      }\n      ul {\n        padding-left: 1.2rem;\n      }\n      li {\n        margin-bottom: 0.5rem;\n      }\n      code {\n        background: #f1f1f1;\n        padding: 0.2rem 0.4rem;\n        border-radius: 4px;\n        font-family: monospace;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"container\">\n      <h1>Tidal Raycast API Server</h1>\n      <p>This server connects your <strong>Raycast</strong> and <strong>Chrome</strong> extensions for a smooth Tidal experience.</p>\n\n      <h2>Endpoints</h2>\n      <ul>\n        <li><code>POST /track-data</code> \u2014 Send track info from Chrome</li>\n        <li><code>GET /current-track</code> \u2014 Get current track in Raycast</li>\n        <li><code>POST /send-command</code> \u2014 Send a control command from Raycast</li>\n        <li><code>GET /get-command</code> \u2014 Chrome polls for the next command</li>\n        <li><code>GET /status</code> \u2014 View server status and metrics</li>\n        <li><code>GET /health</code> \u2014 Quick server health check</li>\n      </ul>\n\n      <h2>Authentication</h2>\n      <p>All API requests (except this page) require a <code>Bearer Token</code> in the <code>Authorization</code> header. Set this in your Raycast preferences.</p>\n\n      <h2>Tips</h2>\n      <ul>\n        <li>To stop the server, run <strong>\"Stop Server\"</strong> in Raycast.</li>\n        <li>Need help? Run <strong>\"Setup Guide\"</strong> in Raycast for setup instructions.</li>\n      </ul>\n    </div>\n  </body>\n  </html>\n\\`);\n    } else if (pathname === \"/track-data\" && method === \"POST\") {\n      const trackData = await parseBody(req)\n      currentTrackData = { ...trackData, receivedAt: new Date().toISOString() }\n      serverStats.lastTrackUpdate = new Date()\n      serverStats.chromeConnected = true\n      res.writeHead(200, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify({ status: \"success\", message: \"Track data received\" }))\n    } else if (pathname === \"/get-command\" && method === \"GET\") {\n      serverStats.chromeConnected = true\n      if (pendingCommands.length > 0) {\n        const command = pendingCommands.shift()\n        res.writeHead(200, { \"Content-Type\": \"application/json\" })\n        res.end(JSON.stringify(command))\n      } else {\n        res.writeHead(200, { \"Content-Type\": \"application/json\" })\n        res.end(JSON.stringify({ status: \"no-commands\" }))\n      }\n    } else if (pathname === \"/current-track\" && method === \"GET\") {\n      serverStats.raycastConnected = true\n      res.writeHead(200, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify(currentTrackData || { status: \"no-data\" }))\n    } else if (pathname === \"/send-command\" && method === \"POST\") {\n      const command = await parseBody(req)\n      command.timestamp = Date.now()\n      command.id = Math.random().toString(36).substr(2, 9)\n      pendingCommands.push(command)\n      serverStats.lastCommandSent = new Date()\n      serverStats.raycastConnected = true\n      res.writeHead(200, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify({ status: \"success\", message: \"Command queued\" }))\n    } else if (pathname === \"/status\" && method === \"GET\") {\n      const status = {\n        ...serverStats,\n        uptime: Date.now() - serverStats.startTime.getTime(),\n        currentTrack: currentTrackData,\n        pendingCommandsCount: pendingCommands.length,\n        port: PORT,\n      }\n      res.writeHead(200, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify(status, null, 2))\n    } else if (pathname === \"/health\" && method === \"GET\") {\n      res.writeHead(200, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify({ status: \"healthy\", timestamp: new Date().toISOString(), pid: process.pid }))\n    } else {\n      res.writeHead(404, { \"Content-Type\": \"application/json\" })\n      res.end(JSON.stringify({ error: \"Not found\", path: pathname }))\n    }\n  } catch (error) {\n    console.error(\\`Request error: \\${error.message} for \\${method} \\${pathname}\\`)\n    res.writeHead(500, { \"Content-Type\": \"application/json\" })\n    res.end(JSON.stringify({ error: \"Internal server error\", message: error.message }))\n  }\n})\n\nserver.on(\"error\", (err) => {\n  console.error(\\`Server error: \\${err.message}\\`)\n  if (err.code === \"EADDRINUSE\") {\n    console.error(\\`Port \\${PORT} is already in use. Another server instance might be running.\\`)\n    process.exit(1)\n  }\n})\n\nserver\n  .listen(PORT, () => {\n    console.log(\\`Server listening on port \\${PORT}\\`);\n  })\n  .on(\"error\", (err) => {\n    console.error(\\`Failed to listen on port \\${PORT}: \\${err.message}\\`)\n    process.exit(1)\n  })\n\nfunction gracefulShutdown() {\n  server.close(() => {\n    try {\n      if (fs.existsSync(PID_FILE)) {\n        fs.unlinkSync(PID_FILE)\n      }\n    } catch (error) {\n      console.error('Error removing PID file on shutdown:', error);\n    }\n    process.exit(0)\n  })\n\n  setTimeout(() => {\n    process.exit(1)\n  }, 5000)\n}\n\nprocess.on(\"SIGINT\", gracefulShutdown)\nprocess.on(\"SIGTERM\", gracefulShutdown)\n\nprocess.on(\"uncaughtException\", (error, origin) => {\n  console.error(\\`Uncaught exception: \\${error.message} at \\${origin}]\\`)\n  console.error(error)\n  process.exit(1)\n})\n\nprocess.on(\"unhandledRejection\", (reason, promise) => {\n  console.error(\\`Unhandled rejection at promise: \\${promise}, reason: \\${reason}\\`)\n  console.error(reason)\n})\n\nsetInterval(() => {\n  const now = Date.now()\n  if (serverStats.lastTrackUpdate && now - serverStats.lastTrackUpdate.getTime() > 15000) {\n    serverStats.chromeConnected = false\n  }\n}, 5000)\n`;\n\nexport const log = (message: string, level: \"info\" | \"error\" | \"warn\" = \"info\") => {\n  console.log(`[TIDAL] [${level.toUpperCase()}] ${message}`);\n};\n\nconst getAuthHeaders = (): Record<string, string> => {\n  const { localApiAuthToken } = getPreferenceValues<{ localApiAuthToken: string }>();\n  if (!localApiAuthToken) {\n    const errorMessage = \"Auth token not found in Raycast preferences.\";\n    log(errorMessage, \"error\");\n    throw new Error(errorMessage);\n  }\n  return {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${localApiAuthToken}`,\n  };\n};\n\nexport const getCurrentTrack = async (): Promise<Track | null> => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/current-track`, {\n      headers: getAuthHeaders(),\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n\n    if (response.ok) {\n      const data = (await response.json()) as Track | { status: string };\n      if (\"status\" in data && data.status === \"no-data\") {\n        return null;\n      }\n      return data as Track;\n    }\n    if (response.status === 401 || response.status === 403) {\n      log(\"Authentication failed when getting current track.\", \"error\");\n    }\n    return null;\n  } catch (error) {\n    log(`Failed to get current track: ${error}`, \"error\");\n    return null;\n  }\n};\n\nexport const sendCommand = async (action: string, serverStatus?: ServerConnectionStatus): Promise<boolean> => {\n  if (serverStatus && serverStatus !== \"connected\") {\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Not Connected\",\n      message: \"Server connection lost\",\n    });\n    return false;\n  }\n\n  try {\n    const response = await fetch(`${API_BASE_URL}/send-command`, {\n      method: \"POST\",\n      headers: getAuthHeaders(),\n      body: JSON.stringify({ action }),\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n\n    if (response.ok) {\n      log(`Command sent: ${action}`);\n      return true;\n    } else {\n      const errorText = await response.text();\n      throw new Error(`Command failed: ${response.status} - ${errorText}`);\n    }\n  } catch (error) {\n    log(`Command error: ${error}`, \"error\");\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Command Failed\",\n      message: String(error),\n    });\n    return false;\n  }\n};\n\nexport const getServerStatus = async (): Promise<ServerStatus | null> => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/status`, {\n      headers: getAuthHeaders(),\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n\n    if (response.ok) {\n      return (await response.json()) as ServerStatus;\n    }\n    return null;\n  } catch (error) {\n    log(`Failed to get server status: ${error}`, \"error\");\n    return null;\n  }\n};\n\nexport const checkServerHealth = async (): Promise<boolean> => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/health`, {\n      headers: getAuthHeaders(),\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n    return response.ok;\n  } catch (error) {\n    log(`Health check failed: ${error}`, \"error\");\n    return false;\n  }\n};\n\nexport const refreshData = async (): Promise<{\n  track: Track;\n  hasRealData: boolean;\n  serverStatus: ServerConnectionStatus;\n}> => {\n  try {\n    const headers = getAuthHeaders();\n    const healthResponse = await fetch(`${API_BASE_URL}/health`, {\n      headers,\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n\n    if (!healthResponse.ok) {\n      throw new Error(`Health check failed: ${healthResponse.status}`);\n    }\n\n    const trackResponse = await fetch(`${API_BASE_URL}/current-track`, {\n      headers,\n      signal: AbortSignal.timeout(REQUEST_TIMEOUT),\n    });\n\n    if (trackResponse.ok) {\n      const trackData = (await trackResponse.json()) as Track | { status: string };\n\n      if (\"status\" in trackData && trackData.status === \"no-data\") {\n        return {\n          track: {\n            title: \"No Track Playing\",\n            artist: \"Open Tidal and play a song\",\n            isPlaying: false,\n            playingFrom: \"\",\n            currentTime: \"0:00\",\n            duration: \"0:00\",\n            isLiked: false,\n            isShuffled: false,\n            repeatMode: \"off\",\n          },\n          hasRealData: false,\n          serverStatus: \"connected\",\n        };\n      } else if (\"title\" in trackData && trackData.title && trackData.title !== \"Unknown\") {\n        const dataAge = Date.now() - (trackData.timestamp || 0);\n        if (dataAge < 600000) {\n          return {\n            track: trackData as Track,\n            hasRealData: true,\n            serverStatus: \"connected\",\n          };\n        } else {\n          return {\n            track: {\n              title: \"Stale Data\",\n              artist: `Chrome inactive? (${Math.round(dataAge / 1000)}s)`,\n              isPlaying: false,\n              playingFrom: \"\",\n              currentTime: \"0:00\",\n              duration: \"0:00\",\n              isLiked: false,\n              isShuffled: false,\n              repeatMode: \"off\",\n            },\n            hasRealData: false,\n            serverStatus: \"connected\",\n          };\n        }\n      }\n    }\n\n    return {\n      track: {\n        title: \"Loading...\",\n        artist: \"Connecting...\",\n        isPlaying: false,\n        playingFrom: \"\",\n        currentTime: \"0:00\",\n        duration: \"0:00\",\n        isLiked: false,\n        isShuffled: false,\n        repeatMode: \"off\",\n      },\n      hasRealData: false,\n      serverStatus: \"connected\",\n    };\n  } catch (error) {\n    log(`Refresh error: ${error} (is the server down??)`, \"error\");\n    return {\n      track: {\n        title: \"Connection Error\",\n        artist: \"Server not responding or auth failed\",\n        isPlaying: false,\n        playingFrom: \"\",\n        currentTime: \"0:00\",\n        duration: \"0:00\",\n        isLiked: false,\n        isShuffled: false,\n        repeatMode: \"off\",\n      },\n      hasRealData: false,\n      serverStatus: \"disconnected\",\n    };\n  }\n};\n\nexport const createCommandHandler = (\n  action: string,\n  serverStatus: ServerConnectionStatus,\n  refreshCallback: () => void,\n) => {\n  return async () => {\n    const success = await sendCommand(action, serverStatus);\n    if (success) {\n      setTimeout(refreshCallback, 200);\n    }\n  };\n};\n\nexport const showServerStatusCmd = async () => {\n  try {\n    await launchCommand({ name: \"server-status\", type: LaunchType.UserInitiated });\n  } catch (error) {\n    log(`Failed to open server status: ${error}`, \"error\");\n    await showToast({ style: Toast.Style.Failure, title: \"Failed to Open Status\" });\n  }\n};\n\nexport const editPreferencesCmd = async () => {\n  try {\n    await openExtensionPreferences();\n  } catch (error) {\n    log(`Failed to open preferences: ${error}`, \"error\");\n    await showToast({ style: Toast.Style.Failure, title: \"Failed to Open Preferences\" });\n  }\n};\n\nexport const showDocsCmd = async () => {\n  try {\n    await open(\"https://github.com/Ek2100/tidal/blob/main/raycast/README.md\");\n  } catch (error) {\n    log(`Failed to open documentation: ${error}`, \"error\");\n    await showToast({ style: Toast.Style.Failure, title: \"Failed to Open Documentation\" });\n  }\n};\n\nexport const manualStartServer = async (refreshCallback: () => void) => {\n  try {\n    await launchCommand({ name: \"start-server\", type: LaunchType.Background });\n    setTimeout(refreshCallback, 2000);\n  } catch (error) {\n    await showHUD(\"\u274C Failed to start server\");\n    log(`Failed to start server: ${error}`, \"error\");\n  }\n};\n\nexport const manualStopServer = async () => {\n  try {\n    await launchCommand({ name: \"stop-server\", type: LaunchType.Background });\n  } catch (error) {\n    await showHUD(\"\u274C Failed to stop server\");\n    log(`Failed to stop server: ${error}`, \"error\");\n  }\n};\n\nconst findNodePath = (): string => {\n  const possiblePaths = [\n    \"/usr/local/bin/node\",\n    \"/opt/homebrew/bin/node\",\n    \"/usr/bin/node\",\n    \"/bin/node\",\n    process.execPath,\n  ];\n\n  for (const path of possiblePaths) {\n    if (existsSync(path)) {\n      log(`Found Node.js at: ${path}`);\n      return path;\n    }\n  }\n\n  try {\n    const nodePath = execSync(\"which node\", { encoding: \"utf8\" }).trim();\n    if (nodePath && existsSync(nodePath)) {\n      log(`Found Node.js via 'which': ${nodePath}`);\n      return nodePath;\n    }\n  } catch (error) {\n    log(`'which node' failed: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  log(\"Could not find Node.js path, falling back to 'node'\");\n  return \"node\";\n};\n\nexport const startServer = async (): Promise<boolean> => {\n  const serverDir = environment.supportPath;\n  const serverPath = join(serverDir, \"server.js\");\n  const pidPath = join(serverDir, PID_FILE_NAME);\n\n  log(`Server dir: ${serverDir}`);\n  log(`Server path: ${serverPath}`);\n  log(`PID file path: ${pidPath}`);\n\n  const { localApiAuthToken } = getPreferenceValues<{ localApiAuthToken: string }>();\n  if (!localApiAuthToken) {\n    await showHUD(\"\u274C Auth Token is not set in preferences!\");\n    log(\"Auth token is missing from preferences. Cannot start server.\", \"error\");\n    return false;\n  }\n\n  if (!existsSync(serverPath)) {\n    try {\n      writeFileSync(serverPath, SERVER_SCRIPT_CONTENT);\n      log(\"Created server.js file\");\n    } catch (error) {\n      log(`Failed to create server.js: ${error instanceof Error ? error.message : String(error)}`);\n      return false;\n    }\n  }\n\n  const nodePath = findNodePath();\n\n  if (existsSync(pidPath)) {\n    try {\n      const pid = readFileSync(pidPath, \"utf8\").trim();\n      log(`Found PID file with PID: ${pid}`);\n      try {\n        execSync(`ps -p ${pid} -o comm=`);\n        log(`Server process ${pid} seems to be running.`);\n        manualStopServer();\n        return true;\n      } catch (e) {\n        log(`Process ${pid} not running: ${e instanceof Error ? e.message : String(e)}`);\n        writeFileSync(pidPath, \"\");\n      }\n    } catch (err) {\n      log(`Error reading PID file: ${err instanceof Error ? err.message : String(err)}`);\n    }\n  }\n\n  try {\n    const healthResponse = await fetch(`${API_BASE_URL}/health`, {\n      headers: getAuthHeaders(),\n      signal: AbortSignal.timeout(500),\n    });\n    if (healthResponse.ok) {\n      const healthData = (await healthResponse.json()) as HealthStatusResponse;\n      log(`Server already healthy on port 3049 (PID: ${healthData.pid}).`);\n      await showHUD(`\u2705 Server already running (PID: ${healthData.pid})`);\n      if (!existsSync(pidPath) || readFileSync(pidPath, \"utf8\").trim() !== String(healthData.pid)) {\n        writeFileSync(pidPath, String(healthData.pid));\n        log(`Updated PID file with PID: ${healthData.pid}`);\n      }\n      return true;\n    }\n  } catch (e) {\n    log(`Health check failed: ${e instanceof Error ? e.message : String(e)}`, \"warn\");\n  }\n\n  log(`Attempting to start server using Node.js at: ${nodePath}`);\n  try {\n    const serverProcess = spawn(nodePath, [serverPath], {\n      detached: true,\n      stdio: \"ignore\",\n      cwd: serverDir,\n      env: {\n        ...process.env,\n        LOCAL_API_AUTH_TOKEN: localApiAuthToken,\n        PATH: process.env.PATH || \"/usr/local/bin:/opt/homebrew/bin:/usr/bin:/bin\",\n      },\n    });\n    serverProcess.unref();\n    log(`Server process spawned with PID: ${serverProcess.pid}`);\n\n    if (serverProcess.pid) {\n      writeFileSync(pidPath, serverProcess.pid.toString());\n      log(`Wrote new PID ${serverProcess.pid} to ${pidPath}`);\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 2500));\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/health`, {\n        headers: getAuthHeaders(),\n        signal: AbortSignal.timeout(1000),\n      });\n      if (response.ok) {\n        const data = (await response.json()) as HealthStatusResponse;\n        log(`Server started successfully (PID: ${data.pid}).`);\n        await showHUD(`\u2705 Server started (PID: ${data.pid})`);\n        return true;\n      } else {\n        throw new Error(`Server responded with ${response.status}`);\n      }\n    } catch (err) {\n      log(`Server health check failed after start: ${err instanceof Error ? err.message : String(err)}`);\n      await showHUD(`\u274C Server failed to start. Node.js: ${nodePath}`);\n      return false;\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    log(`Error spawning server process: ${errorMessage}`);\n    await showHUD(`\u274C Failed to start server: ${errorMessage}`);\n    return false;\n  }\n};\n\ninterface HealthStatusResponse {\n  status: string;\n  timestamp: string;\n  pid: number;\n}\n\nexport const stopServer = async (): Promise<boolean> => {\n  const serverDir = environment.supportPath;\n  const pidPath = join(serverDir, PID_FILE_NAME);\n\n  log(`Attempting to stop server. PID file path: ${pidPath}`);\n\n  let pidToKill: number | null = null;\n  let initialPidFromFile: string | null = null;\n\n  const checkServerHealthAndGetPid = async (): Promise<number | null> => {\n    try {\n      const healthResponse = await fetch(`${API_BASE_URL}/health`, {\n        headers: getAuthHeaders(),\n        signal: AbortSignal.timeout(500),\n      });\n      if (healthResponse.ok) {\n        const data = (await healthResponse.json()) as HealthStatusResponse;\n        if (data && typeof data.pid === \"number\") {\n          return data.pid;\n        }\n      }\n    } catch (e) {\n      log(`Health check failed: ${e instanceof Error ? e.message : String(e)}`, \"warn\");\n    }\n    return null;\n  };\n\n  if (existsSync(pidPath)) {\n    try {\n      initialPidFromFile = readFileSync(pidPath, \"utf8\").trim();\n      if (initialPidFromFile) {\n        pidToKill = parseInt(initialPidFromFile);\n        log(`Found PID file with PID: ${pidToKill}`);\n      } else {\n        log(\"PID file is empty.\");\n      }\n    } catch (err) {\n      log(`Error reading PID file: ${err instanceof Error ? err.message : String(err)}.`, \"warn\");\n    }\n  } else {\n    log(\"PID file not found.\");\n  }\n\n  if (pidToKill === null) {\n    log(\"No PID from file. Checking server health endpoint for active PID.\");\n    pidToKill = await checkServerHealthAndGetPid();\n    if (pidToKill) {\n      log(`Found active server PID from health endpoint: ${pidToKill}`);\n    } else {\n      log(\"Server not detected as running via health endpoint. Nothing to stop.\", \"warn\");\n      await showHUD(\"\u26A0\uFE0F Server not running\");\n      return false;\n    }\n  }\n\n  try {\n    log(`Attempting to send SIGTERM to PID: ${pidToKill}`);\n    process.kill(pidToKill, \"SIGTERM\");\n    log(`Sent SIGTERM to PID: ${pidToKill}`);\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n  } catch (error) {\n    log(\n      `Error sending SIGTERM to PID ${pidToKill}: ${\n        error instanceof Error ? error.message : String(error)\n      }. Process might not exist or already stopped.`,\n      \"warn\",\n    );\n  }\n\n  const finalRunningPid = await checkServerHealthAndGetPid();\n\n  if (finalRunningPid === null) {\n    log(\"Server stopped successfully (final health check failed).\");\n    await showHUD(\"\u2705 Server stopped\");\n    if (existsSync(pidPath)) {\n      try {\n        unlinkSync(pidPath);\n        log(\"PID file removed.\");\n      } catch (unlinkErr) {\n        log(`Error removing PID file: ${unlinkErr instanceof Error ? unlinkErr.message : String(unlinkErr)}`, \"error\");\n      }\n    }\n    const serverPath = join(serverDir, \"server.js\");\n    if (existsSync(serverPath)) {\n      try {\n        unlinkSync(serverPath);\n        log(\"server.js file removed.\");\n      } catch (unlinkErr) {\n        log(\n          `Error removing server.js file: ${unlinkErr instanceof Error ? unlinkErr.message : String(unlinkErr)}`,\n          \"error\",\n        );\n      }\n    }\n    return true;\n  } else {\n    let message = `\u274C Server still running (PID: ${finalRunningPid}).`;\n    if (initialPidFromFile && finalRunningPid === parseInt(initialPidFromFile)) {\n      message += ` Original PID ${initialPidFromFile} is still active.`;\n    } else if (initialPidFromFile && finalRunningPid !== parseInt(initialPidFromFile)) {\n      message += ` New PID ${finalRunningPid} detected, original PID ${initialPidFromFile} might have been replaced.`;\n    } else {\n      message += ` No original PID file found.`;\n    }\n    log(message, \"error\");\n    await showHUD(message);\n    return false;\n  }\n};\n\nexport const formatUptime = (ms: number): string => {\n  const seconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n\n  if (hours > 0) return `${hours}h ${minutes % 60}m`;\n  if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\n  return `${seconds}s`;\n};\n\nexport const getRepeatIcon = (repeatMode: Track[\"repeatMode\"]) => {\n  switch (repeatMode) {\n    case \"one\":\n      return \"ArrowClockwise\";\n    case \"all\":\n      return \"Repeat\";\n    default:\n      return \"MinusCircle\";\n  }\n};\n\nexport const getRepeatTitle = (repeatMode: Track[\"repeatMode\"]) => {\n  switch (repeatMode) {\n    case \"one\":\n      return \"Repeat: One\";\n    case \"all\":\n      return \"Repeat: All\";\n    default:\n      return \"Repeat: Off\";\n  }\n};\n\nexport const getServerIcon = (serverStatus: ServerConnectionStatus) => {\n  switch (serverStatus) {\n    case \"connected\":\n      return \"CheckCircle\";\n    case \"connecting\":\n      return \"Clock\";\n    default:\n      return \"XMarkCircle\";\n  }\n};\n\nexport const getMenubarTitle = (hasRealData: boolean, currentTrack: Track, serverStatus: ServerConnectionStatus) => {\n  if (hasRealData && currentTrack.title !== \"Loading...\" && currentTrack.title !== \"No Track Playing\") {\n    return `${currentTrack.title.substring(0, 25)}${currentTrack.title.length > 25 ? \"...\" : \"\"}`;\n  }\n\n  switch (serverStatus) {\n    case \"connected\":\n      return \"Tidal\";\n    case \"connecting\":\n      return \"Loading...\";\n    default:\n      return \"Offline\";\n  }\n};\n"],
  "mappings": "sbAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAEA,IAAAI,EAAuD,wBACvDC,EAAoC,iBCHpC,IAAAC,EAUO,wBACPC,EAAgC,yBAChCC,EAAqB,gBACrBC,EAAoE,cAgC9DC,EAAe,wBACfC,EAAkB,IAClBC,EAAgB,aAEhBC,EAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkRjBC,EAAM,CAACC,EAAiBC,EAAmC,SAAW,CACjF,QAAQ,IAAI,YAAYA,EAAM,YAAY,CAAC,KAAKD,CAAO,EAAE,CAC3D,EAEME,EAAiB,IAA8B,CACnD,GAAM,CAAE,kBAAAC,CAAkB,KAAI,uBAAmD,EACjF,GAAI,CAACA,EAAmB,CACtB,IAAMC,EAAe,+CACrB,MAAAL,EAAIK,EAAc,OAAO,EACnB,IAAI,MAAMA,CAAY,CAC9B,CACA,MAAO,CACL,eAAgB,mBAChB,cAAe,UAAUD,CAAiB,EAC5C,CACF,EA8DO,IAAME,EAAkB,SAA0C,CACvE,GAAI,CACF,IAAMC,EAAW,MAAM,MAAM,GAAGC,CAAY,UAAW,CACrD,QAASC,EAAe,EACxB,OAAQ,YAAY,QAAQC,CAAe,CAC7C,CAAC,EAED,OAAIH,EAAS,GACH,MAAMA,EAAS,KAAK,EAEvB,IACT,OAASI,EAAO,CACd,OAAAC,EAAI,gCAAgCD,CAAK,GAAI,OAAO,EAC7C,IACT,CACF,EAwKO,IAAME,EAAmB,SAAY,CAC1C,GAAI,CACF,QAAM,iBAAc,CAAE,KAAM,cAAe,KAAM,aAAW,UAAW,CAAC,CAC1E,OAASC,EAAO,CACd,QAAM,WAAQ,8BAAyB,EACvCC,EAAI,0BAA0BD,CAAK,GAAI,OAAO,CAChD,CACF,EAEME,EAAe,IAAc,CACjC,IAAMC,EAAgB,CACpB,sBACA,yBACA,gBACA,YACA,QAAQ,QACV,EAEA,QAAWC,KAAQD,EACjB,MAAI,cAAWC,CAAI,EACjB,OAAAH,EAAI,qBAAqBG,CAAI,EAAE,EACxBA,EAIX,GAAI,CACF,IAAMC,KAAW,YAAS,aAAc,CAAE,SAAU,MAAO,CAAC,EAAE,KAAK,EACnE,GAAIA,MAAY,cAAWA,CAAQ,EACjC,OAAAJ,EAAI,8BAA8BI,CAAQ,EAAE,EACrCA,CAEX,OAASL,EAAO,CACdC,EAAI,wBAAwBD,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAAC,EAAE,CACtF,CAEA,OAAAC,EAAI,qDAAqD,EAClD,MACT,EAEaK,EAAc,SAA8B,CACvD,IAAMC,EAAY,cAAY,YACxBC,KAAa,QAAKD,EAAW,WAAW,EACxCE,KAAU,QAAKF,EAAWG,CAAa,EAE7CT,EAAI,eAAeM,CAAS,EAAE,EAC9BN,EAAI,gBAAgBO,CAAU,EAAE,EAChCP,EAAI,kBAAkBQ,CAAO,EAAE,EAE/B,GAAM,CAAE,kBAAAE,CAAkB,KAAI,uBAAmD,EACjF,GAAI,CAACA,EACH,eAAM,WAAQ,8CAAyC,EACvDV,EAAI,+DAAgE,OAAO,EACpE,GAGT,GAAI,IAAC,cAAWO,CAAU,EACxB,GAAI,IACF,iBAAcA,EAAYI,CAAqB,EAC/CX,EAAI,wBAAwB,CAC9B,OAASD,EAAO,CACd,OAAAC,EAAI,+BAA+BD,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAAC,EAAE,EACpF,EACT,CAGF,IAAMK,EAAWH,EAAa,EAE9B,MAAI,cAAWO,CAAO,EACpB,GAAI,CACF,IAAMI,KAAM,gBAAaJ,EAAS,MAAM,EAAE,KAAK,EAC/CR,EAAI,4BAA4BY,CAAG,EAAE,EACrC,GAAI,CACF,qBAAS,SAASA,CAAG,WAAW,EAChCZ,EAAI,kBAAkBY,CAAG,uBAAuB,EAChDd,EAAiB,EACV,EACT,OAAS,EAAG,CACVE,EAAI,WAAWY,CAAG,iBAAiB,aAAa,MAAQ,EAAE,QAAU,OAAO,CAAC,CAAC,EAAE,KAC/E,iBAAcJ,EAAS,EAAE,CAC3B,CACF,OAASK,EAAK,CACZb,EAAI,2BAA2Ba,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,CAAC,EAAE,CACnF,CAGF,GAAI,CACF,IAAMC,EAAiB,MAAM,MAAM,GAAGC,CAAY,UAAW,CAC3D,QAASC,EAAe,EACxB,OAAQ,YAAY,QAAQ,GAAG,CACjC,CAAC,EACD,GAAIF,EAAe,GAAI,CACrB,IAAMG,EAAc,MAAMH,EAAe,KAAK,EAC9C,OAAAd,EAAI,6CAA6CiB,EAAW,GAAG,IAAI,EACnE,QAAM,WAAQ,uCAAkCA,EAAW,GAAG,GAAG,GAC7D,IAAC,cAAWT,CAAO,MAAK,gBAAaA,EAAS,MAAM,EAAE,KAAK,IAAM,OAAOS,EAAW,GAAG,QACxF,iBAAcT,EAAS,OAAOS,EAAW,GAAG,CAAC,EAC7CjB,EAAI,8BAA8BiB,EAAW,GAAG,EAAE,GAE7C,EACT,CACF,OAASC,EAAG,CACVlB,EAAI,wBAAwBkB,aAAa,MAAQA,EAAE,QAAU,OAAOA,CAAC,CAAC,GAAI,MAAM,CAClF,CAEAlB,EAAI,gDAAgDI,CAAQ,EAAE,EAC9D,GAAI,CACF,IAAMe,KAAgB,SAAMf,EAAU,CAACG,CAAU,EAAG,CAClD,SAAU,GACV,MAAO,SACP,IAAKD,EACL,IAAK,CACH,GAAG,QAAQ,IACX,qBAAsBI,EACtB,KAAM,QAAQ,IAAI,MAAQ,gDAC5B,CACF,CAAC,EACDS,EAAc,MAAM,EACpBnB,EAAI,oCAAoCmB,EAAc,GAAG,EAAE,EAEvDA,EAAc,SAChB,iBAAcX,EAASW,EAAc,IAAI,SAAS,CAAC,EACnDnB,EAAI,iBAAiBmB,EAAc,GAAG,OAAOX,CAAO,EAAE,GAGxD,MAAM,IAAI,QAASY,GAAY,WAAWA,EAAS,IAAI,CAAC,EAExD,GAAI,CACF,IAAMC,EAAW,MAAM,MAAM,GAAGN,CAAY,UAAW,CACrD,QAASC,EAAe,EACxB,OAAQ,YAAY,QAAQ,GAAI,CAClC,CAAC,EACD,GAAIK,EAAS,GAAI,CACf,IAAMC,EAAQ,MAAMD,EAAS,KAAK,EAClC,OAAArB,EAAI,qCAAqCsB,EAAK,GAAG,IAAI,EACrD,QAAM,WAAQ,+BAA0BA,EAAK,GAAG,GAAG,EAC5C,EACT,KACE,OAAM,IAAI,MAAM,yBAAyBD,EAAS,MAAM,EAAE,CAE9D,OAASR,EAAK,CACZ,OAAAb,EAAI,2CAA2Ca,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,CAAC,EAAE,EACjG,QAAM,WAAQ,2CAAsCT,CAAQ,EAAE,EACvD,EACT,CACF,OAASL,EAAO,CACd,IAAMwB,EAAexB,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC1E,OAAAC,EAAI,kCAAkCuB,CAAY,EAAE,EACpD,QAAM,WAAQ,kCAA6BA,CAAY,EAAE,EAClD,EACT,CACF,EAQaC,EAAa,SAA8B,CACtD,IAAMlB,EAAY,cAAY,YACxBE,KAAU,QAAKF,EAAWG,CAAa,EAE7CT,EAAI,6CAA6CQ,CAAO,EAAE,EAE1D,IAAIiB,EAA2B,KAC3BC,EAAoC,KAElCC,EAA6B,SAAoC,CACrE,GAAI,CACF,IAAMb,EAAiB,MAAM,MAAM,GAAGC,CAAY,UAAW,CAC3D,QAASC,EAAe,EACxB,OAAQ,YAAY,QAAQ,GAAG,CACjC,CAAC,EACD,GAAIF,EAAe,GAAI,CACrB,IAAMQ,EAAQ,MAAMR,EAAe,KAAK,EACxC,GAAIQ,GAAQ,OAAOA,EAAK,KAAQ,SAC9B,OAAOA,EAAK,GAEhB,CACF,OAAS,EAAG,CACVtB,EAAI,wBAAwB,aAAa,MAAQ,EAAE,QAAU,OAAO,CAAC,CAAC,GAAI,MAAM,CAClF,CACA,OAAO,IACT,EAEA,MAAI,cAAWQ,CAAO,EACpB,GAAI,CACFkB,KAAqB,gBAAalB,EAAS,MAAM,EAAE,KAAK,EACpDkB,GACFD,EAAY,SAASC,CAAkB,EACvC1B,EAAI,4BAA4ByB,CAAS,EAAE,GAE3CzB,EAAI,oBAAoB,CAE5B,OAASa,EAAK,CACZb,EAAI,2BAA2Ba,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,CAAC,IAAK,MAAM,CAC5F,MAEAb,EAAI,qBAAqB,EAG3B,GAAIyB,IAAc,KAGhB,GAFAzB,EAAI,mEAAmE,EACvEyB,EAAY,MAAME,EAA2B,EACzCF,EACFzB,EAAI,iDAAiDyB,CAAS,EAAE,MAEhE,QAAAzB,EAAI,uEAAwE,MAAM,EAClF,QAAM,WAAQ,iCAAuB,EAC9B,GAIX,GAAI,CACFA,EAAI,sCAAsCyB,CAAS,EAAE,EACrD,QAAQ,KAAKA,EAAW,SAAS,EACjCzB,EAAI,wBAAwByB,CAAS,EAAE,EACvC,MAAM,IAAI,QAASL,GAAY,WAAWA,EAAS,GAAI,CAAC,CAC1D,OAASrB,EAAO,CACdC,EACE,gCAAgCyB,CAAS,KACvC1B,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CACvD,gDACA,MACF,CACF,CAEA,IAAM6B,EAAkB,MAAMD,EAA2B,EAEzD,GAAIC,IAAoB,KAAM,CAG5B,GAFA5B,EAAI,0DAA0D,EAC9D,QAAM,WAAQ,uBAAkB,KAC5B,cAAWQ,CAAO,EACpB,GAAI,IACF,cAAWA,CAAO,EAClBR,EAAI,mBAAmB,CACzB,OAAS6B,EAAW,CAClB7B,EAAI,4BAA4B6B,aAAqB,MAAQA,EAAU,QAAU,OAAOA,CAAS,CAAC,GAAI,OAAO,CAC/G,CAEF,IAAMtB,KAAa,QAAKD,EAAW,WAAW,EAC9C,MAAI,cAAWC,CAAU,EACvB,GAAI,IACF,cAAWA,CAAU,EACrBP,EAAI,yBAAyB,CAC/B,OAAS6B,EAAW,CAClB7B,EACE,kCAAkC6B,aAAqB,MAAQA,EAAU,QAAU,OAAOA,CAAS,CAAC,GACpG,OACF,CACF,CAEF,MAAO,EACT,KAAO,CACL,IAAIC,EAAU,qCAAgCF,CAAe,KAC7D,OAAIF,GAAsBE,IAAoB,SAASF,CAAkB,EACvEI,GAAW,iBAAiBJ,CAAkB,oBACrCA,GAAsBE,IAAoB,SAASF,CAAkB,EAC9EI,GAAW,YAAYF,CAAe,2BAA2BF,CAAkB,6BAEnFI,GAAW,+BAEb9B,EAAI8B,EAAS,OAAO,EACpB,QAAM,WAAQA,CAAO,EACd,EACT,CACF,EAEaC,EAAgBC,GAAuB,CAClD,IAAMC,EAAU,KAAK,MAAMD,EAAK,GAAI,EAC9BE,EAAU,KAAK,MAAMD,EAAU,EAAE,EACjCE,EAAQ,KAAK,MAAMD,EAAU,EAAE,EAErC,OAAIC,EAAQ,EAAU,GAAGA,CAAK,KAAKD,EAAU,EAAE,IAC3CA,EAAU,EAAU,GAAGA,CAAO,KAAKD,EAAU,EAAE,IAC5C,GAAGA,CAAO,GACnB,ED1yBW,IAAAG,EAAA,6BA3CI,SAARC,GAAuC,CAC5C,GAAM,CAACC,EAAQC,CAAS,KAAI,YAA8B,IAAI,EACxD,CAACC,EAAWC,CAAY,KAAI,YAAS,EAAI,EACzC,CAACC,EAAOC,CAAQ,KAAI,YAAwB,IAAI,EAEhDC,EAAc,SAAY,CAC9B,GAAI,CACF,IAAMC,EAAO,MAAMC,EAAgB,EAC/BD,GACFN,EAAUM,CAAI,EACdF,EAAS,IAAI,IAEbA,EAAS,sBAAsB,EAC/BJ,EAAU,IAAI,EAElB,OAASQ,EAAK,CACZ,QAAQ,MAAM,gCAAiCA,CAAG,EAClDJ,EAAS,sBAAsB,EAC/BJ,EAAU,IAAI,CAChB,QAAE,CACAE,EAAa,EAAK,CACpB,CACF,EAEMO,EAAoB,SAAY,CACpCP,EAAa,EAAI,EACjB,MAAMQ,EAAY,EAClB,WAAWL,EAAa,GAAI,CAC9B,EAEMM,EAAmB,SAAY,CACnCT,EAAa,EAAI,EACjB,MAAMU,EAAW,EACjB,WAAWP,EAAa,GAAI,CAC9B,EAQA,SANA,aAAU,IAAM,CACdA,EAAY,EACZ,IAAMQ,EAAW,YAAYR,EAAa,GAAI,EAC9C,MAAO,IAAM,cAAcQ,CAAQ,CACrC,EAAG,CAAC,CAAC,EAEDZ,KACK,OAAC,QAAK,UAAW,GAAM,EAG5BE,KAEA,OAAC,QACC,mBAAC,OAAK,KAAL,CACC,MAAM,gBACN,SAAUA,EACV,KAAM,CAAE,OAAQ,OAAK,YAAa,UAAW,QAAM,GAAI,EACvD,WACE,QAAC,eACC,oBAAC,UAAO,MAAM,eAAe,SAAUM,EAAmB,KAAM,OAAK,KAAM,KAC3E,OAAC,UAAO,MAAM,UAAU,SAAUJ,EAAa,KAAM,OAAK,gBAAiB,GAC7E,EAEJ,EACF,KAKF,QAAC,QACC,qBAAC,OAAK,QAAL,CAAa,MAAM,gBAClB,oBAAC,OAAK,KAAL,CACC,MAAM,SACN,SAAU,mBAAmBN,GAAQ,IAAI,GACzC,KAAM,CAAE,OAAQ,OAAK,YAAa,UAAW,QAAM,KAAM,EACzD,YAAa,CAAC,CAAE,KAAM,WAAWe,EAAaf,GAAQ,QAAU,CAAC,CAAC,EAAG,CAAC,EACtE,WACE,QAAC,eACC,oBAAC,UAAO,MAAM,cAAc,SAAUY,EAAkB,KAAM,OAAK,KAAM,KACzE,OAAC,UAAO,MAAM,UAAU,SAAUN,EAAa,KAAM,OAAK,gBAAiB,GAC7E,EAEJ,KACA,OAAC,OAAK,KAAL,CACC,MAAM,WACN,SAAU,GAAGN,GAAQ,YAAY,kBACjC,KAAM,CAAE,OAAQ,OAAK,SAAU,UAAW,QAAM,IAAK,EACvD,GACF,KAEA,QAAC,OAAK,QAAL,CAAa,MAAM,cAClB,oBAAC,OAAK,KAAL,CACC,MAAM,mBACN,SAAUA,GAAQ,gBAAkB,YAAc,eAClD,KAAM,CACJ,OAAQA,GAAQ,gBAAkB,OAAK,YAAc,OAAK,YAC1D,UAAWA,GAAQ,gBAAkB,QAAM,MAAQ,QAAM,GAC3D,EACA,YACEA,GAAQ,gBACJ,CAAC,CAAE,KAAM,gBAAgB,IAAI,KAAKA,EAAO,eAAe,EAAE,mBAAmB,CAAC,EAAG,CAAC,EAClF,CAAC,CAAE,KAAM,YAAa,CAAC,EAE/B,KACA,OAAC,OAAK,KAAL,CACC,MAAM,oBACN,SAAUA,GAAQ,iBAAmB,YAAc,eACnD,KAAM,CACJ,OAAQA,GAAQ,iBAAmB,OAAK,YAAc,OAAK,YAC3D,UAAWA,GAAQ,iBAAmB,QAAM,MAAQ,QAAM,GAC5D,EACA,YACEA,GAAQ,gBACJ,CAAC,CAAE,KAAM,iBAAiB,IAAI,KAAKA,EAAO,eAAe,EAAE,mBAAmB,CAAC,EAAG,CAAC,EACnF,CAAC,CAAE,KAAM,aAAc,CAAC,EAEhC,GACF,KAEA,QAAC,OAAK,QAAL,CAAa,MAAM,gBAClB,oBAAC,OAAK,KAAL,CACC,MAAM,QACN,SACEA,GAAQ,cAAc,MAClB,GAAGA,EAAO,aAAa,KAAK,MAAMA,EAAO,aAAa,MAAM,GAC5D,gBAEN,KAAM,CAAE,OAAQ,OAAK,MAAO,UAAW,QAAM,MAAO,EACpD,YACEA,GAAQ,cAAc,UAClB,CAAC,CAAE,KAAM,UAAW,KAAM,CAAE,OAAQ,OAAK,KAAM,UAAW,QAAM,KAAM,CAAE,CAAC,EACzE,CAAC,CAAE,KAAM,SAAU,KAAM,CAAE,OAAQ,OAAK,MAAO,UAAW,QAAM,MAAO,CAAE,CAAC,EAElF,KACA,OAAC,OAAK,KAAL,CACC,MAAM,mBACN,SAAU,GAAGA,GAAQ,sBAAwB,CAAC,qBAC9C,KAAM,CAAE,OAAQ,OAAK,SAAU,UAAW,QAAM,MAAO,EACzD,GACF,GACF,CAEJ",
  "names": ["server_status_exports", "__export", "ServerStatusCommand", "__toCommonJS", "import_api", "import_react", "import_api", "import_child_process", "import_path", "import_fs", "API_BASE_URL", "REQUEST_TIMEOUT", "PID_FILE_NAME", "SERVER_SCRIPT_CONTENT", "log", "message", "level", "getAuthHeaders", "localApiAuthToken", "errorMessage", "getServerStatus", "response", "API_BASE_URL", "getAuthHeaders", "REQUEST_TIMEOUT", "error", "log", "manualStopServer", "error", "log", "findNodePath", "possiblePaths", "path", "nodePath", "startServer", "serverDir", "serverPath", "pidPath", "PID_FILE_NAME", "localApiAuthToken", "SERVER_SCRIPT_CONTENT", "pid", "err", "healthResponse", "API_BASE_URL", "getAuthHeaders", "healthData", "e", "serverProcess", "resolve", "response", "data", "errorMessage", "stopServer", "pidToKill", "initialPidFromFile", "checkServerHealthAndGetPid", "finalRunningPid", "unlinkErr", "message", "formatUptime", "ms", "seconds", "minutes", "hours", "import_jsx_runtime", "ServerStatusCommand", "status", "setStatus", "isLoading", "setIsLoading", "error", "setError", "fetchStatus", "data", "getServerStatus", "err", "handleStartServer", "startServer", "handleStopServer", "stopServer", "interval", "formatUptime"]
}
