{
  "version": 3,
  "sources": ["../src/fix-invisible-characters.ts", "../src/lib/sets.ts", "../src/lib/analyze.ts", "../src/lib/runtime.ts", "../src/lib/clean.ts"],
  "sourcesContent": ["import * as Ray from \"@raycast/api\";\nimport { analyzeText } from \"./lib/analyze\";\nimport { fixAllUnicode, fixInvisibleOnly, getPreferences, readPreferredTextSource } from \"./lib/runtime\";\n\nexport default async function main() {\n  const prefs = getPreferences();\n  try {\n    const original = await readPreferredTextSource(prefs);\n    if (!original) {\n      await Ray.showToast({\n        style: Ray.Toast.Style.Failure,\n        title: \"No text to process\",\n        message: \"Select text or copy it to the clipboard\",\n      });\n      return;\n    }\n\n    const analysisBefore = analyzeText(original);\n    const cleaned = prefs.defaultCleanMode === \"all\" ? fixAllUnicode(original, prefs) : fixInvisibleOnly(original);\n    const analysisAfter = analyzeText(cleaned);\n\n    if (prefs.actionAfterClean === \"paste\") {\n      await Ray.closeMainWindow();\n      await Ray.Clipboard.paste(cleaned);\n    } else {\n      await Ray.Clipboard.copy(cleaned);\n    }\n\n    if (prefs.showToasts) {\n      const modeLabel = prefs.defaultCleanMode === \"all\" ? \"All Unicode\" : \"Only Invisible\";\n      await Ray.showToast({\n        style: Ray.Toast.Style.Success,\n        title: `Cleaned text (${modeLabel})`,\n        message: `before: ${analysisBefore.invisible.count} invisible, ${analysisBefore.nonKeyboard.count} non-keyboard \u2192 after: ${analysisAfter.invisible.count} invisible, ${analysisAfter.nonKeyboard.count} non-keyboard`,\n      });\n    }\n  } catch (error) {\n    await Ray.showToast({ style: Ray.Toast.Style.Failure, title: \"Failed to clean\", message: String(error) });\n  }\n}\n", "/*\n  Centralized character sets and helpers for detection & cleaning.\n*/\n\nexport const INVISIBLE_RANGES = [\n  \"\\u200B-\\u200D\", // zero width space, non-joiner, joiner\n  \"\\u200E-\\u200F\", // LRM, RLM\n  \"\\u202A-\\u202E\", // bidi embedding/override\n  \"\\u2066-\\u2069\", // bidi isolate\n  \"\\u180B-\\u180D\", // Mongolian variation selectors 1-3\n  \"\\uFE00-\\uFE0F\", // variation selectors\n];\n\n// Single code points that are invisible or formatting marks\nexport const INVISIBLE_SINGLES = [\n  \"\\u00AD\", // soft hyphen\n  \"\\u034F\", // grapheme joiner\n  \"\\uFEFF\", // zero width no-break space / BOM\n];\n\n// Hangul/Khmer fillers and others (some render as blank width); treat as removable\nexport const FILLERS_VISIBLE_OR_BLANK = [\n  \"\\u3164\", // Hangul Filler\n  \"\\u115F\", // Hangul Choseong Filler\n  \"\\u1160\", // Hangul Jungseong Filler\n  \"\\u17B4\", // Khmer Vowel Inherent AQ\n  \"\\u17B5\", // Khmer Vowel Inherent AA\n];\n\n// Spaces that are visible but non-standard; normalize to regular space in All Unicode mode\nexport const SPECIAL_SPACES_RANGES = [\n  \"\\u2000-\\u200A\", // various en/thin spaces\n];\nexport const SPECIAL_SPACES_SINGLES = [\n  \"\\u00A0\", // NBSP\n  \"\\u202F\", // narrow no-break space\n  \"\\u205F\", // medium mathematical space\n  \"\\u3000\", // ideographic space\n  \"\\u180E\", // Mongolian vowel separator (historically spacing)\n];\n\n// Visible but non-keyboard typography\nexport const SMART_QUOTES = [\"\\u2018\", \"\\u2019\", \"\\u201C\", \"\\u201D\"]; // \u2018 \u2019 \u201C \u201D\nexport const DASHES = [\"\\u2013\", \"\\u2014\"]; // \u2013 \u2014\nexport const ELLIPSIS = \"\\u2026\"; // \u2026\n\nexport function buildCharClass(parts: string[]): string {\n  return parts.join(\"\");\n}\n\nexport const INVISIBLE_CLASS = `[${buildCharClass(INVISIBLE_RANGES)}${INVISIBLE_SINGLES.join(\"\")}]`;\nexport const FILLERS_CLASS = `[${FILLERS_VISIBLE_OR_BLANK.join(\"\")}]`;\nexport const SPECIAL_SPACES_CLASS = `[${buildCharClass(SPECIAL_SPACES_RANGES)}${SPECIAL_SPACES_SINGLES.join(\"\")}]`;\n\nexport const NON_KEYBOARD_CLASS = `[${SMART_QUOTES.join(\"\")}${DASHES.join(\"\")}${ELLIPSIS}]`;\n\nexport const ASCII_ALLOWED_IN_ALL = /[\\n\\r\\t \\x20-\\x7E]/;\n\nexport function codePointToHex(cp: number): string {\n  return `U+${cp.toString(16).toUpperCase()}`;\n}\n", "import { FILLERS_CLASS, INVISIBLE_CLASS, NON_KEYBOARD_CLASS, SPECIAL_SPACES_CLASS, codePointToHex } from \"./sets\";\n\nexport interface CharacterGroupSummary {\n  label: string;\n  count: number;\n  codePoints: string[];\n}\n\nexport interface AnalysisResult {\n  totalCharacters: number;\n  totalWords: number;\n  invisible: CharacterGroupSummary;\n  nonKeyboard: CharacterGroupSummary;\n  specialSpaces: CharacterGroupSummary;\n}\n\nexport function analyzeText(text: string): AnalysisResult {\n  const totalCharacters = [...text].length;\n  const totalWords = text\n    .replace(new RegExp(`${INVISIBLE_CLASS}|${FILLERS_CLASS}`, \"gu\"), \"\")\n    .trim()\n    .split(/\\s+/u)\n    .filter(Boolean).length;\n\n  const invMatches = text.match(new RegExp(`${INVISIBLE_CLASS}`, \"gu\")) ?? [];\n  const nonKeyboardMatches = text.match(new RegExp(`${NON_KEYBOARD_CLASS}`, \"gu\")) ?? [];\n  const specialSpaceMatches = text.match(new RegExp(`${SPECIAL_SPACES_CLASS}`, \"gu\")) ?? [];\n\n  return {\n    totalCharacters,\n    totalWords,\n    invisible: {\n      label: \"Invisible Characters\",\n      count: invMatches.length,\n      codePoints: uniqueCodePoints(invMatches),\n    },\n    nonKeyboard: {\n      label: \"Non-Keyboard Unicode\",\n      count: nonKeyboardMatches.length,\n      codePoints: uniqueCodePoints(nonKeyboardMatches),\n    },\n    specialSpaces: {\n      label: \"Special Spaces\",\n      count: specialSpaceMatches.length,\n      codePoints: uniqueCodePoints(specialSpaceMatches),\n    },\n  };\n}\n\nfunction uniqueCodePoints(chars: string[]): string[] {\n  const set = new Set<string>();\n  for (const ch of chars) {\n    const cp = ch.codePointAt(0);\n    if (cp !== undefined) set.add(codePointToHex(cp));\n  }\n  return [...set];\n}\n", "import { getPreferenceValues, Clipboard, getSelectedText } from \"@raycast/api\";\nimport { analyzeText } from \"./analyze\";\nexport type CleanMode = \"invisible\" | \"all\";\n\nexport interface Preferences {\n  defaultCleanMode: CleanMode;\n  preferSelectedText: boolean;\n  actionAfterClean: \"copy\" | \"paste\";\n  showToasts: boolean;\n  replaceNBSPWithSpace: boolean;\n  convertSmartQuotes: boolean;\n  convertDashes: boolean;\n  replaceEllipsis: boolean;\n  tabWidth: number | string;\n  collapseMultipleSpaces: boolean;\n  normalizeNFKD: boolean;\n  previewShowSpaces: boolean;\n  previewShowNonKeyboard: boolean;\n  previewShowUnicodeTags: boolean;\n}\n\nexport function getPreferences(): Preferences {\n  return getPreferenceValues<Preferences>();\n}\n\nexport async function readPreferredTextSource(prefs: Preferences): Promise<string | undefined> {\n  if (prefs.preferSelectedText) {\n    try {\n      const sel = await getSelectedText();\n      if (sel && sel.length > 0) return sel;\n    } catch {\n      // fall back to clipboard\n    }\n  }\n  const clip = await Clipboard.readText();\n  return clip ?? undefined;\n}\n\nexport { analyzeText };\nexport { fixInvisibleOnly, fixAllUnicode } from \"./clean\";\n", "import { FILLERS_CLASS, INVISIBLE_CLASS, SPECIAL_SPACES_CLASS, ASCII_ALLOWED_IN_ALL } from \"./sets\";\nimport type { Preferences } from \"./runtime\";\n\nexport function fixInvisibleOnly(text: string): string {\n  const re = new RegExp(`${INVISIBLE_CLASS}|${FILLERS_CLASS}`, \"gu\");\n  return text.replace(re, \"\");\n}\n\nexport function fixAllUnicode(text: string, prefs: Preferences): string {\n  let result = text;\n\n  // Replace special spaces\n  if (prefs.replaceNBSPWithSpace) {\n    result = result.replace(new RegExp(`${SPECIAL_SPACES_CLASS}`, \"gu\"), \" \");\n  }\n\n  // Convert smart quotes and apostrophes\n  if (prefs.convertSmartQuotes) {\n    result = result.replace(/[\\u2018\\u2019]/gu, \"'\").replace(/[\\u201C\\u201D]/gu, '\"');\n  }\n\n  // Convert en/em dashes\n  if (prefs.convertDashes) {\n    result = result.replace(/[\\u2013\\u2014]/gu, \"-\");\n  }\n\n  // Ellipsis\n  if (prefs.replaceEllipsis) {\n    result = result.replace(/\\u2026/gu, \"...\");\n  }\n\n  // Tabs\n  const tabWidth = Math.max(0, Number.parseInt(String(prefs.tabWidth || 4), 10) || 4);\n  result = result.replace(/\\t/gu, \" \".repeat(tabWidth));\n\n  // Remove invisible & fillers\n  result = result.replace(new RegExp(`${INVISIBLE_CLASS}|${FILLERS_CLASS}`, \"gu\"), \"\");\n\n  // Normalize NFKD and strip combining marks\n  if (prefs.normalizeNFKD) {\n    result = result.normalize(\"NFKD\").replace(/\\p{M}+/gu, \"\");\n  }\n\n  // Remove any remaining non-ASCII (except newline and spaces)\n  result = [...result].filter((ch) => ASCII_ALLOWED_IN_ALL.test(ch)).join(\"\");\n\n  if (prefs.collapseMultipleSpaces) {\n    result = result.replace(/ {2,}/g, \" \");\n  }\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["fix_invisible_characters_exports", "__export", "main", "__toCommonJS", "Ray", "INVISIBLE_RANGES", "INVISIBLE_SINGLES", "FILLERS_VISIBLE_OR_BLANK", "SPECIAL_SPACES_RANGES", "SPECIAL_SPACES_SINGLES", "SMART_QUOTES", "DASHES", "buildCharClass", "parts", "INVISIBLE_CLASS", "INVISIBLE_RANGES", "INVISIBLE_SINGLES", "FILLERS_CLASS", "FILLERS_VISIBLE_OR_BLANK", "SPECIAL_SPACES_CLASS", "SPECIAL_SPACES_RANGES", "SPECIAL_SPACES_SINGLES", "NON_KEYBOARD_CLASS", "SMART_QUOTES", "DASHES", "ASCII_ALLOWED_IN_ALL", "codePointToHex", "cp", "analyzeText", "text", "totalCharacters", "totalWords", "INVISIBLE_CLASS", "FILLERS_CLASS", "invMatches", "nonKeyboardMatches", "NON_KEYBOARD_CLASS", "specialSpaceMatches", "SPECIAL_SPACES_CLASS", "uniqueCodePoints", "chars", "set", "ch", "cp", "codePointToHex", "import_api", "fixInvisibleOnly", "text", "re", "INVISIBLE_CLASS", "FILLERS_CLASS", "fixAllUnicode", "prefs", "result", "SPECIAL_SPACES_CLASS", "tabWidth", "ch", "ASCII_ALLOWED_IN_ALL", "getPreferences", "readPreferredTextSource", "prefs", "sel", "main", "prefs", "getPreferences", "original", "readPreferredTextSource", "analysisBefore", "analyzeText", "cleaned", "fixAllUnicode", "fixInvisibleOnly", "analysisAfter", "modeLabel", "error"]
}
