{
  "version": 3,
  "sources": ["../node_modules/react-async-hook/node_modules/babel-plugin-transform-async-to-promises/helpers.js", "../node_modules/react-async-hook/src/index.ts", "../node_modules/react-async-hook/node_modules/babel-plugin-transform-async-to-promises/helpers.js", "../node_modules/react-async-hook/src/index.ts", "../node_modules/react-async-hook/dist/index.js", "../src/index.tsx", "../src/screens/FormScreen.tsx", "../src/screens/MainScreen.tsx", "../src/components/CheatSheet.tsx", "../src/components/RegexOptions.tsx"],
  "sourcesContent": ["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && !check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n", "import {\n  Dispatch,\n  SetStateAction,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from 'react';\n\n// See https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n    ? useLayoutEffect\n    : useEffect;\n\n// Assign current value to a ref and returns a stable getter to get the latest value.\n// This way we are sure to always get latest value provided to hook and\n// avoid weird issues due to closures capturing stale values...\n// See https://github.com/facebook/react/issues/16956\n// See https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nconst useGetter = <T>(t: T) => {\n  const ref = useRef(t);\n  useIsomorphicLayoutEffect(() => {\n    ref.current = t;\n  });\n  return useCallback(() => ref.current, [ref]);\n};\n\ntype UnknownResult = unknown;\n\n// Convenient to avoid declaring the type of args, which may help reduce type boilerplate\n//type UnknownArgs = unknown[];\n// TODO unfortunately it seems required for now if we want default param to work...\n// See https://twitter.com/sebastienlorber/status/1170003594894106624\ntype UnknownArgs = any[];\n\nexport type AsyncStateStatus =\n  | 'not-requested'\n  | 'loading'\n  | 'success'\n  | 'error';\n\nexport type AsyncState<R> = {\n  status: AsyncStateStatus;\n  loading: boolean;\n  error: Error | undefined;\n  result: R | undefined;\n};\ntype SetLoading<R> = (asyncState: AsyncState<R>) => AsyncState<R>;\ntype SetResult<R> = (result: R, asyncState: AsyncState<R>) => AsyncState<R>;\ntype SetError<R> = (error: Error, asyncState: AsyncState<R>) => AsyncState<R>;\n\ntype MaybePromise<T> = Promise<T> | T;\n\ntype PromiseCallbackOptions = {\n  // Permit to know if the success/error belongs to the last async call\n  isCurrent: () => boolean;\n\n  // TODO this can be convenient but need some refactor\n  // params: Args;\n};\n\nexport type UseAsyncOptionsNormalized<R> = {\n  initialState: (options?: UseAsyncOptionsNormalized<R>) => AsyncState<R>;\n  executeOnMount: boolean;\n  executeOnUpdate: boolean;\n  setLoading: SetLoading<R>;\n  setResult: SetResult<R>;\n  setError: SetError<R>;\n  onSuccess: (r: R, options: PromiseCallbackOptions) => void;\n  onError: (e: Error, options: PromiseCallbackOptions) => void;\n};\nexport type UseAsyncOptions<R> =\n  | Partial<UseAsyncOptionsNormalized<R>>\n  | undefined\n  | null;\n\nconst InitialAsyncState: AsyncState<any> = {\n  status: 'not-requested',\n  loading: false,\n  result: undefined,\n  error: undefined,\n};\n\nconst InitialAsyncLoadingState: AsyncState<any> = {\n  status: 'loading',\n  loading: true,\n  result: undefined,\n  error: undefined,\n};\n\nconst defaultSetLoading: SetLoading<any> = _asyncState =>\n  InitialAsyncLoadingState;\n\nconst defaultSetResult: SetResult<any> = (result, _asyncState) => ({\n  status: 'success',\n  loading: false,\n  result: result,\n  error: undefined,\n});\n\nconst defaultSetError: SetError<any> = (error, _asyncState) => ({\n  status: 'error',\n  loading: false,\n  result: undefined,\n  error: error,\n});\n\nconst noop = () => {};\n\nconst DefaultOptions: UseAsyncOptionsNormalized<any> = {\n  initialState: options =>\n    options && options.executeOnMount\n      ? InitialAsyncLoadingState\n      : InitialAsyncState,\n  executeOnMount: true,\n  executeOnUpdate: true,\n  setLoading: defaultSetLoading,\n  setResult: defaultSetResult,\n  setError: defaultSetError,\n  onSuccess: noop,\n  onError: noop,\n};\n\nconst normalizeOptions = <R>(\n  options: UseAsyncOptions<R>\n): UseAsyncOptionsNormalized<R> => ({\n  ...DefaultOptions,\n  ...options,\n});\n\ntype UseAsyncStateResult<R> = {\n  value: AsyncState<R>;\n  set: Dispatch<SetStateAction<AsyncState<R>>>;\n  merge: (value: Partial<AsyncState<R>>) => void;\n  reset: () => void;\n  setLoading: () => void;\n  setResult: (r: R) => void;\n  setError: (e: Error) => void;\n};\nconst useAsyncState = <R extends {}>(\n  options: UseAsyncOptionsNormalized<R>\n): UseAsyncStateResult<R> => {\n  const [value, setValue] = useState<AsyncState<R>>(() =>\n    options.initialState(options)\n  );\n\n  const reset = useCallback(() => setValue(options.initialState(options)), [\n    setValue,\n    options,\n  ]);\n\n  const setLoading = useCallback(() => setValue(options.setLoading(value)), [\n    value,\n    setValue,\n  ]);\n  const setResult = useCallback(\n    (result: R) => setValue(options.setResult(result, value)),\n    [value, setValue]\n  );\n\n  const setError = useCallback(\n    (error: Error) => setValue(options.setError(error, value)),\n    [value, setValue]\n  );\n\n  const merge = useCallback(\n    (state: Partial<AsyncState<R>>) =>\n      setValue({\n        ...value,\n        ...state,\n      }),\n    [value, setValue]\n  );\n\n  return {\n    value,\n    set: setValue,\n    merge,\n    reset,\n    setLoading,\n    setResult,\n    setError,\n  };\n};\n\nconst useIsMounted = (): (() => boolean) => {\n  const ref = useRef<boolean>(false);\n  useEffect(() => {\n    ref.current = true;\n    return () => {\n      ref.current = false;\n    };\n  }, []);\n  return () => ref.current;\n};\n\ntype UseCurrentPromiseReturn<R> = {\n  set: (promise: Promise<R>) => void;\n  get: () => Promise<R> | null;\n  is: (promise: Promise<R>) => boolean;\n};\nconst useCurrentPromise = <R>(): UseCurrentPromiseReturn<R> => {\n  const ref = useRef<Promise<R> | null>(null);\n  return {\n    set: promise => (ref.current = promise),\n    get: () => ref.current,\n    is: promise => ref.current === promise,\n  };\n};\n\nexport type UseAsyncReturn<\n  R = UnknownResult,\n  Args extends any[] = UnknownArgs\n> = AsyncState<R> & {\n  set: (value: AsyncState<R>) => void;\n  merge: (value: Partial<AsyncState<R>>) => void;\n  reset: () => void;\n  execute: (...args: Args) => Promise<R>;\n  currentPromise: Promise<R> | null;\n  currentParams: Args | null;\n};\n\n// Relaxed interface which accept both async and sync functions\n// Accepting sync function is convenient for useAsyncCallback\nconst useAsyncInternal = <R = UnknownResult, Args extends any[] = UnknownArgs>(\n  asyncFunction: (...args: Args) => MaybePromise<R>,\n  params: Args,\n  options?: UseAsyncOptions<R>\n): UseAsyncReturn<R, Args> => {\n  // Fallback missing params, only for JS users forgetting the deps array, to prevent infinite loops\n  // https://github.com/slorber/react-async-hook/issues/27\n  // @ts-ignore\n  !params && (params = []);\n\n  const normalizedOptions = normalizeOptions<R>(options);\n\n  const [currentParams, setCurrentParams] = useState<Args | null>(null);\n\n  const AsyncState = useAsyncState<R>(normalizedOptions);\n\n  const isMounted = useIsMounted();\n  const CurrentPromise = useCurrentPromise<R>();\n\n  // We only want to handle the promise result/error\n  // if it is the last operation and the comp is still mounted\n  const shouldHandlePromise = (p: Promise<R>) =>\n    isMounted() && CurrentPromise.is(p);\n\n  const executeAsyncOperation = (...args: Args): Promise<R> => {\n    // async ensures errors thrown synchronously are caught (ie, bug when formatting api payloads)\n    // async ensures promise-like and synchronous functions are handled correctly too\n    // see https://github.com/slorber/react-async-hook/issues/24\n    const promise: Promise<R> = (async () => asyncFunction(...args))();\n    setCurrentParams(args);\n    CurrentPromise.set(promise);\n    AsyncState.setLoading();\n    promise.then(\n      result => {\n        if (shouldHandlePromise(promise)) {\n          AsyncState.setResult(result);\n        }\n        normalizedOptions.onSuccess(result, {\n          isCurrent: () => CurrentPromise.is(promise),\n        });\n      },\n      error => {\n        if (shouldHandlePromise(promise)) {\n          AsyncState.setError(error);\n        }\n        normalizedOptions.onError(error, {\n          isCurrent: () => CurrentPromise.is(promise),\n        });\n      }\n    );\n    return promise;\n  };\n\n  const getLatestExecuteAsyncOperation = useGetter(executeAsyncOperation);\n\n  const executeAsyncOperationMemo: (...args: Args) => Promise<R> = useCallback(\n    (...args) => getLatestExecuteAsyncOperation()(...args),\n    [getLatestExecuteAsyncOperation]\n  );\n\n  // Keep this outside useEffect, because inside isMounted()\n  // will be true as the component is already mounted when it's run\n  const isMounting = !isMounted();\n  useEffect(() => {\n    const execute = () => getLatestExecuteAsyncOperation()(...params);\n    isMounting && normalizedOptions.executeOnMount && execute();\n    !isMounting && normalizedOptions.executeOnUpdate && execute();\n  }, params);\n\n  return {\n    ...AsyncState.value,\n    set: AsyncState.set,\n    merge: AsyncState.merge,\n    reset: AsyncState.reset,\n    execute: executeAsyncOperationMemo,\n    currentPromise: CurrentPromise.get(),\n    currentParams,\n  };\n};\n\n// override to allow passing an async function with no args:\n// gives more user-freedom to create an inline async function\nexport function useAsync<R = UnknownResult, Args extends any[] = UnknownArgs>(\n  asyncFunction: () => Promise<R>,\n  params: Args,\n  options?: UseAsyncOptions<R>\n): UseAsyncReturn<R, Args>;\nexport function useAsync<R = UnknownResult, Args extends any[] = UnknownArgs>(\n  asyncFunction: (...args: Args) => Promise<R>,\n  params: Args,\n  options?: UseAsyncOptions<R>\n): UseAsyncReturn<R, Args>;\n\nexport function useAsync<R = UnknownResult, Args extends any[] = UnknownArgs>(\n  asyncFunction: (...args: Args) => Promise<R>,\n  params: Args,\n  options?: UseAsyncOptions<R>\n): UseAsyncReturn<R, Args> {\n  return useAsyncInternal(asyncFunction, params, options);\n}\n\ntype AddArg<H, T extends any[]> = ((h: H, ...t: T) => void) extends ((\n  ...r: infer R\n) => void)\n  ? R\n  : never;\n\nexport const useAsyncAbortable = <\n  R = UnknownResult,\n  Args extends any[] = UnknownArgs\n>(\n  asyncFunction: (...args: AddArg<AbortSignal, Args>) => Promise<R>,\n  params: Args,\n  options?: UseAsyncOptions<R>\n): UseAsyncReturn<R, Args> => {\n  const abortControllerRef = useRef<AbortController>();\n\n  // Wrap the original async function and enhance it with abortion login\n  const asyncFunctionWrapper: (...args: Args) => Promise<R> = async (\n    ...p: Args\n  ) => {\n    // Cancel previous async call\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    // Create/store new abort controller for next async call\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    try {\n      // @ts-ignore // TODO how to type this?\n      return await asyncFunction(abortController.signal, ...p);\n    } finally {\n      // Unset abortController ref if response is already there,\n      // as it's not needed anymore to try to abort it (would it be no-op?)\n      if (abortControllerRef.current === abortController) {\n        abortControllerRef.current = undefined;\n      }\n    }\n  };\n\n  return useAsync(asyncFunctionWrapper, params, options);\n};\n\n// keep compat with TS < 3.5\ntype LegacyOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n// Some options are not allowed for useAsyncCallback\nexport type UseAsyncCallbackOptions<R> =\n  | LegacyOmit<\n      Partial<UseAsyncOptionsNormalized<R>>,\n      'executeOnMount' | 'executeOnUpdate' | 'initialState'\n    >\n  | undefined\n  | null;\n\nexport const useAsyncCallback = <\n  R = UnknownResult,\n  Args extends any[] = UnknownArgs\n>(\n  asyncFunction: (...args: Args) => MaybePromise<R>,\n  options?: UseAsyncCallbackOptions<R>\n): UseAsyncReturn<R, Args> => {\n  return useAsyncInternal(\n    asyncFunction,\n    // Hacky but in such case we don't need the params,\n    // because async function is only executed manually\n    [] as any,\n    {\n      ...options,\n      executeOnMount: false,\n      executeOnUpdate: false,\n    }\n  );\n};\n", "// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && !check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n", "import {\n  Dispatch,\n  SetStateAction,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from 'react';\n\n// See https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n    ? useLayoutEffect\n    : useEffect;\n\n// Assign current value to a ref and returns a stable getter to get the latest value.\n// This way we are sure to always get latest value provided to hook and\n// avoid weird issues due to closures capturing stale values...\n// See https://github.com/facebook/react/issues/16956\n// See https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nconst useGetter = <T>(t: T) => {\n  const ref = useRef(t);\n  useIsomorphicLayoutEffect(() => {\n    ref.current = t;\n  });\n  return useCallback(() => ref.current, [ref]);\n};\n\ntype UnknownResult = unknown;\n\n// Convenient to avoid declaring the type of args, which may help reduce type boilerplate\n//type UnknownArgs = unknown[];\n// TODO unfortunately it seems required for now if we want default param to work...\n// See https://twitter.com/sebastienlorber/status/1170003594894106624\ntype UnknownArgs = any[];\n\nexport type AsyncStateStatus =\n  | 'not-requested'\n  | 'loading'\n  | 'success'\n  | 'error';\n\nexport type AsyncState<R> = {\n  status: AsyncStateStatus;\n  loading: boolean;\n  error: Error | undefined;\n  result: R | undefined;\n};\ntype SetLoading<R> = (asyncState: AsyncState<R>) => AsyncState<R>;\ntype SetResult<R> = (result: R, asyncState: AsyncState<R>) => AsyncState<R>;\ntype SetError<R> = (error: Error, asyncState: AsyncState<R>) => AsyncState<R>;\n\ntype MaybePromise<T> = Promise<T> | T;\n\ntype PromiseCallbackOptions = {\n  // Permit to know if the success/error belongs to the last async call\n  isCurrent: () => boolean;\n\n  // TODO this can be convenient but need some refactor\n  // params: Args;\n};\n\nexport type UseAsyncOptionsNormalized<R> = {\n  initialState: (options?: UseAsyncOptionsNormalized<R>) => AsyncState<R>;\n  executeOnMount: boolean;\n  executeOnUpdate: boolean;\n  setLoading: SetLoading<R>;\n  setResult: SetResult<R>;\n  setError: SetError<R>;\n  onSuccess: (r: R, options: PromiseCallbackOptions) => void;\n  onError: (e: Error, options: PromiseCallbackOptions) => void;\n};\nexport type UseAsyncOptions<R> =\n  | Partial<UseAsyncOptionsNormalized<R>>\n  | undefined\n  | null;\n\nconst InitialAsyncState: AsyncState<any> = {\n  status: 'not-requested',\n  loading: false,\n  result: undefined,\n  error: undefined,\n};\n\nconst InitialAsyncLoadingState: AsyncState<any> = {\n  status: 'loading',\n  loading: true,\n  result: undefined,\n  error: undefined,\n};\n\nconst defaultSetLoading: SetLoading<any> = _asyncState =>\n  InitialAsyncLoadingState;\n\nconst defaultSetResult: SetResult<any> = (result, _asyncState) => ({\n  status: 'success',\n  loading: false,\n  result: result,\n  error: undefined,\n});\n\nconst defaultSetError: SetError<any> = (error, _asyncState) => ({\n  status: 'error',\n  loading: false,\n  result: undefined,\n  error: error,\n});\n\nconst noop = () => {};\n\nconst DefaultOptions: UseAsyncOptionsNormalized<any> = {\n  initialState: options =>\n    options && options.executeOnMount\n      ? InitialAsyncLoadingState\n      : InitialAsyncState,\n  executeOnMount: true,\n  executeOnUpdate: true,\n  setLoading: defaultSetLoading,\n  setResult: defaultSetResult,\n  setError: defaultSetError,\n  onSuccess: noop,\n  onError: noop,\n};\n\nconst normalizeOptions = <R>(\n  options: UseAsyncOptions<R>\n): UseAsyncOptionsNormalized<R> => ({\n  ...DefaultOptions,\n  ...options,\n});\n\ntype UseAsyncStateResult<R> = {\n  value: AsyncState<R>;\n  set: Dispatch<SetStateAction<AsyncState<R>>>;\n  merge: (value: Partial<AsyncState<R>>) => void;\n  reset: () => void;\n  setLoading: () => void;\n  setResult: (r: R) => void;\n  setError: (e: Error) => void;\n};\nconst useAsyncState = <R extends {}>(\n  options: UseAsyncOptionsNormalized<R>\n): UseAsyncStateResult<R> => {\n  const [value, setValue] = useState<AsyncState<R>>(() =>\n    options.initialState(options)\n  );\n\n  const reset = useCallback(() => setValue(options.initialState(options)), [\n    setValue,\n    options,\n  ]);\n\n  const setLoading = useCallback(() => setValue(options.setLoading(value)), [\n    value,\n    setValue,\n  ]);\n  const setResult = useCallback(\n    (result: R) => setValue(options.setResult(result, value)),\n    [value, setValue]\n  );\n\n  const setError = useCallback(\n    (error: Error) => setValue(options.setError(error, value)),\n    [value, setValue]\n  );\n\n  const merge = useCallback(\n    (state: Partial<AsyncState<R>>) =>\n      setValue({\n        ...value,\n        ...state,\n      }),\n    [value, setValue]\n  );\n\n  return {\n    value,\n    set: setValue,\n    merge,\n    reset,\n    setLoading,\n    setResult,\n    setError,\n  };\n};\n\nconst useIsMounted = (): (() => boolean) => {\n  const ref = useRef<boolean>(false);\n  useEffect(() => {\n    ref.current = true;\n    return () => {\n      ref.current = false;\n    };\n  }, []);\n  return () => ref.current;\n};\n\ntype UseCurrentPromiseReturn<R> = {\n  set: (promise: Promise<R>) => void;\n  get: () => Promise<R> | null;\n  is: (promise: Promise<R>) => boolean;\n};\nconst useCurrentPromise = <R>(): UseCurrentPromiseReturn<R> => {\n  const ref = useRef<Promise<R> | null>(null);\n  return {\n    set: promise => (ref.current = promise),\n    get: () => ref.current,\n    is: promise => ref.current === promise,\n  };\n};\n\nexport type UseAsyncReturn<\n  R = UnknownResult,\n  Args extends any[] = UnknownArgs\n> = AsyncState<R> & {\n  set: (value: AsyncState<R>) => void;\n  merge: (value: Partial<AsyncState<R>>) => void;\n  reset: () => void;\n  execute: (...args: Args) => Promise<R>;\n  currentPromise: Promise<R> | null;\n  currentParams: Args | null;\n};\n\n// Relaxed interface which accept both async and sync functions\n// Accepting sync function is convenient for useAsyncCallback\nconst useAsyncInternal = <R = UnknownResult, Args extends any[] = UnknownArgs>(\n  asyncFunction: (...args: Args) => MaybePromise<R>,\n  params: Args,\n  options?: UseAsyncOptions<R>\n): UseAsyncReturn<R, Args> => {\n  // Fallback missing params, only for JS users forgetting the deps array, to prevent infinite loops\n  // https://github.com/slorber/react-async-hook/issues/27\n  // @ts-ignore\n  !params && (params = []);\n\n  const normalizedOptions = normalizeOptions<R>(options);\n\n  const [currentParams, setCurrentParams] = useState<Args | null>(null);\n\n  const AsyncState = useAsyncState<R>(normalizedOptions);\n\n  const isMounted = useIsMounted();\n  const CurrentPromise = useCurrentPromise<R>();\n\n  // We only want to handle the promise result/error\n  // if it is the last operation and the comp is still mounted\n  const shouldHandlePromise = (p: Promise<R>) =>\n    isMounted() && CurrentPromise.is(p);\n\n  const executeAsyncOperation = (...args: Args): Promise<R> => {\n    // async ensures errors thrown synchronously are caught (ie, bug when formatting api payloads)\n    // async ensures promise-like and synchronous functions are handled correctly too\n    // see https://github.com/slorber/react-async-hook/issues/24\n    const promise: Promise<R> = (async () => asyncFunction(...args))();\n    setCurrentParams(args);\n    CurrentPromise.set(promise);\n    AsyncState.setLoading();\n    promise.then(\n      result => {\n        if (shouldHandlePromise(promise)) {\n          AsyncState.setResult(result);\n        }\n        normalizedOptions.onSuccess(result, {\n          isCurrent: () => CurrentPromise.is(promise),\n        });\n      },\n      error => {\n        if (shouldHandlePromise(promise)) {\n          AsyncState.setError(error);\n        }\n        normalizedOptions.onError(error, {\n          isCurrent: () => CurrentPromise.is(promise),\n        });\n      }\n    );\n    return promise;\n  };\n\n  const getLatestExecuteAsyncOperation = useGetter(executeAsyncOperation);\n\n  const executeAsyncOperationMemo: (...args: Args) => Promise<R> = useCallback(\n    (...args) => getLatestExecuteAsyncOperation()(...args),\n    [getLatestExecuteAsyncOperation]\n  );\n\n  // Keep this outside useEffect, because inside isMounted()\n  // will be true as the component is already mounted when it's run\n  const isMounting = !isMounted();\n  useEffect(() => {\n    const execute = () => getLatestExecuteAsyncOperation()(...params);\n    isMounting && normalizedOptions.executeOnMount && execute();\n    !isMounting && normalizedOptions.executeOnUpdate && execute();\n  }, params);\n\n  return {\n    ...AsyncState.value,\n    set: AsyncState.set,\n    merge: AsyncState.merge,\n    reset: AsyncState.reset,\n    execute: executeAsyncOperationMemo,\n    currentPromise: CurrentPromise.get(),\n    currentParams,\n  };\n};\n\n// override to allow passing an async function with no args:\n// gives more user-freedom to create an inline async function\nexport function useAsync<R = UnknownResult, Args extends any[] = UnknownArgs>(\n  asyncFunction: () => Promise<R>,\n  params: Args,\n  options?: UseAsyncOptions<R>\n): UseAsyncReturn<R, Args>;\nexport function useAsync<R = UnknownResult, Args extends any[] = UnknownArgs>(\n  asyncFunction: (...args: Args) => Promise<R>,\n  params: Args,\n  options?: UseAsyncOptions<R>\n): UseAsyncReturn<R, Args>;\n\nexport function useAsync<R = UnknownResult, Args extends any[] = UnknownArgs>(\n  asyncFunction: (...args: Args) => Promise<R>,\n  params: Args,\n  options?: UseAsyncOptions<R>\n): UseAsyncReturn<R, Args> {\n  return useAsyncInternal(asyncFunction, params, options);\n}\n\ntype AddArg<H, T extends any[]> = ((h: H, ...t: T) => void) extends ((\n  ...r: infer R\n) => void)\n  ? R\n  : never;\n\nexport const useAsyncAbortable = <\n  R = UnknownResult,\n  Args extends any[] = UnknownArgs\n>(\n  asyncFunction: (...args: AddArg<AbortSignal, Args>) => Promise<R>,\n  params: Args,\n  options?: UseAsyncOptions<R>\n): UseAsyncReturn<R, Args> => {\n  const abortControllerRef = useRef<AbortController>();\n\n  // Wrap the original async function and enhance it with abortion login\n  const asyncFunctionWrapper: (...args: Args) => Promise<R> = async (\n    ...p: Args\n  ) => {\n    // Cancel previous async call\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    // Create/store new abort controller for next async call\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    try {\n      // @ts-ignore // TODO how to type this?\n      return await asyncFunction(abortController.signal, ...p);\n    } finally {\n      // Unset abortController ref if response is already there,\n      // as it's not needed anymore to try to abort it (would it be no-op?)\n      if (abortControllerRef.current === abortController) {\n        abortControllerRef.current = undefined;\n      }\n    }\n  };\n\n  return useAsync(asyncFunctionWrapper, params, options);\n};\n\n// keep compat with TS < 3.5\ntype LegacyOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n// Some options are not allowed for useAsyncCallback\nexport type UseAsyncCallbackOptions<R> =\n  | LegacyOmit<\n      Partial<UseAsyncOptionsNormalized<R>>,\n      'executeOnMount' | 'executeOnUpdate' | 'initialState'\n    >\n  | undefined\n  | null;\n\nexport const useAsyncCallback = <\n  R = UnknownResult,\n  Args extends any[] = UnknownArgs\n>(\n  asyncFunction: (...args: Args) => MaybePromise<R>,\n  options?: UseAsyncCallbackOptions<R>\n): UseAsyncReturn<R, Args> => {\n  return useAsyncInternal(\n    asyncFunction,\n    // Hacky but in such case we don't need the params,\n    // because async function is only executed manually\n    [] as any,\n    {\n      ...options,\n      executeOnMount: false,\n      executeOnUpdate: false,\n    }\n  );\n};\n", "\n'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./react-async-hook.cjs.production.min.js')\n} else {\n  module.exports = require('./react-async-hook.cjs.development.js')\n}\n", "import { useCallback, useState } from \"react\";\nimport { LocalStorage, useNavigation } from \"@raycast/api\";\nimport FormScreen, { TestStringFormValues } from \"./screens/FormScreen\";\nimport { useAsync } from \"react-async-hook\";\nimport MainScreen from \"./screens/MainScreen\";\n\nexport default function Command() {\n  const [testString, setTestString] = useState(\"\");\n  const [source, setSource] = useState<string | undefined>();\n  const { push } = useNavigation();\n\n  useAsync(async () => {\n    if (source === \"new\") {\n      const newString = { id: Date.now().toString(), value: testString };\n      const previousItem = await LocalStorage.getItem<string>(\"test-string-history\");\n      if (previousItem) {\n        const previousStrings = JSON.parse(previousItem);\n        const nextStrings = [newString, ...previousStrings].slice(0, 5);\n        await LocalStorage.setItem(\"test-string-history\", JSON.stringify(nextStrings));\n      } else {\n        await LocalStorage.setItem(\"test-string-history\", JSON.stringify([newString]));\n      }\n    }\n  }, [source]);\n\n  const handleSubmit = useCallback((values: TestStringFormValues) => {\n    setTestString(values.text);\n    setSource(values.source);\n    push(<MainScreen testString={values.text} />);\n  }, []);\n\n  return <FormScreen onSubmit={handleSubmit} />;\n}\n", "import { FC, useCallback, useEffect, useState } from \"react\";\nimport { Action, ActionPanel, Form, LocalStorage } from \"@raycast/api\";\nimport { useAsync } from \"react-async-hook\";\n\nexport type TestStringFormValues = {\n  text: string;\n  source: string;\n};\n\ninterface Props {\n  onSubmit: (values: TestStringFormValues) => void;\n}\n\ntype TestStringHistory = {\n  id: string;\n  value: string;\n};\n\nconst FormScreen: FC<Props> = ({ onSubmit }) => {\n  const [text, setText] = useState(\"\");\n  const [pastStrings, setPastStrings] = useState<TestStringHistory[] | undefined>();\n  const [source, setSource] = useState(\"new\");\n\n  useAsync(async () => {\n    const item = await LocalStorage.getItem<string>(\"test-string-history\");\n    if (!item) return;\n    setPastStrings(JSON.parse(item));\n  }, []);\n\n  useEffect(() => {\n    if (sources[source]) {\n      setText(sources[source]);\n    } else {\n      setText(pastStrings?.find((str) => str.id === source)?.value || \"\");\n    }\n  }, [source]);\n\n  const clearPreviousStrings = useCallback(() => {\n    LocalStorage.removeItem(\"test-string-history\");\n    setPastStrings(undefined);\n  }, []);\n\n  return (\n    <Form\n      actions={\n        <ActionPanel>\n          <Action.SubmitForm title=\"Test Regex\" onSubmit={onSubmit} />\n          <Action\n            title=\"Clear Previous Test Strings\"\n            onAction={clearPreviousStrings}\n            shortcut={{ modifiers: [\"cmd\"], key: \"backspace\" }}\n          />\n        </ActionPanel>\n      }\n    >\n      <Form.Dropdown id=\"source\" title=\"\" defaultValue=\"new\" onChange={setSource}>\n        <Form.Dropdown.Item value=\"new\" title=\"New Test String\" />\n        <Form.Dropdown.Item value=\"lorem\" title=\"Lorem Ipsum\" />\n        {pastStrings && (\n          <Form.Dropdown.Section title=\"Previous Test Strings\">\n            {pastStrings.map((str) => (\n              <Form.Dropdown.Item key={str.id} value={str.id} title={str.value} />\n            ))}\n          </Form.Dropdown.Section>\n        )}\n      </Form.Dropdown>\n      <Form.TextArea id=\"text\" title=\"\" placeholder=\"Enter your test string\" value={text} onChange={setText} />\n    </Form>\n  );\n};\n\nconst sources: Record<string, string> = {\n  lorem:\n    \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla malesuada viverra elit, at placerat metus dictum at. Aliquam pretium, massa nec interdum hendrerit, libero ipsum rutrum nibh, iaculis fringilla magna ante sit amet quam. Donec imperdiet leo risus, et accumsan sem malesuada eu. Nunc suscipit urna magna, sit amet tempus lectus laoreet vitae. Fusce in dolor vitae lacus luctus ullamcorper. Maecenas faucibus fringilla feugiat. Phasellus purus mauris, molestie vel dolor eget, posuere iaculis mauris. Nunc blandit neque ut semper ultrices. Cras tempus mollis pharetra. Quisque euismod orci eget augue lobortis feugiat. Suspendisse at consequat eros.\",\n};\n\nexport default FormScreen;\n", "import { List } from \"@raycast/api\";\nimport { FC, useCallback, useEffect, useState } from \"react\";\nimport CheatSheet from \"../components/CheatSheet\";\nimport RegexOptions, { Options } from \"../components/RegexOptions\";\n\ninterface Props {\n  testString: string;\n}\n\nconst MainScreen: FC<Props> = ({ testString }) => {\n  const [query, setQuery] = useState(\"\");\n  const [highlightedText, setHighlightedText] = useState(\"\");\n  const [options, setOptions] = useState<Options>(\"gm\");\n\n  const handleOptionsChange = useCallback((options: Options) => {\n    setOptions(options);\n  }, []);\n\n  useEffect(() => {\n    if (query === \"\") {\n      setHighlightedText(testString);\n      return;\n    }\n    try {\n      const nextHighlightedText = testString.replace(new RegExp(query, options), (match) => `|${match}|`);\n      setHighlightedText(nextHighlightedText);\n    } catch (error) {\n      console.log(\"regex error\", error);\n    }\n  }, [testString, query, options]);\n\n  return (\n    <List\n      isShowingDetail\n      enableFiltering={false}\n      searchBarPlaceholder=\"([A-Z])\\w+\"\n      searchText={query}\n      onSearchTextChange={setQuery}\n      searchBarAccessory={<RegexOptions onOptionsChange={handleOptionsChange} />}\n    >\n      <List.Item title=\"Preview\" subtitle=\"\" detail={<List.Item.Detail markdown={highlightedText} />} />\n      <List.Item title=\"Cheat Sheet\" subtitle=\"\" detail={<CheatSheet />} />\n    </List>\n  );\n};\n\nexport default MainScreen;\n", "import { List } from \"@raycast/api\";\n\nconst CheatSheet = () => <List.Item.Detail markdown={markdown} />;\n\nconst markdown = `\n# Regular Expression Cheat Sheet\n\n## Character Classes\n\n\\`.\\`\n\nany character except newline\n\n\\`\\\\w\\\\d\\\\s\\`\n\nword, digit, whitespace\n\n\\`\\\\W\\\\D\\\\S\\`\n\nnot word, digit, whitespace\n\n\\`[abc]\\`\n\nany of a, b, or c\n\n\\`[^abc]\\`\n\nnot a, b, or c\n\n\\`[a-g]\\`\n\ncharacter between a & g\n\n## Anchors\n\n\\`^abc$\\`\n\nstart / end of the string\n\n\\`\\\\b\\\\B\\`\n\nword, not-word boundary\n\n## Escaped characters\n\n\\`\\\\.\\\\*\\\\\\\\\\`\n\nescaped special characters\n\n\\`\\\\t\\\\n\\\\r\\`\n\ntab, linefeed, carriage return\n\n## Groups & Lookaround\n\n\\`(abc)\\`\n\ncapture group\n\n\\`\\\\1\\`\n\nbackreference to group #1\n\n\\`(?:abc)\\`\n\nnon-capturing group\n\n\\`(?=abc)\\`\n\npositive lookahead\n\n\\`(?!abc)\\`\n\nnegative lookahead\n\n## Quantifiers & Alternation\n\n\\`a*a+a?\\`\n\n0 or more, 1 or more, 0 or 1\n\n\\`a{5}a{2,}\\`\n\nexactly five, two or more\n\n\\`a{1,3}\\`\n\nbetween one & three\n\n\\`a+?a{2,}?\\`\n\nmatch as few as possible\n\n\\`ab|cd\\`\n\nmatch ab or cd\n\n`;\n\nexport default CheatSheet;\n", "import { FC } from \"react\";\nimport { List } from \"@raycast/api\";\n\nexport type Options = string;\n\ninterface Props {\n  onOptionsChange: (options: Options) => void;\n}\n\nconst RegexOptions: FC<Props> = ({ onOptionsChange }) => {\n  return (\n    <List.Dropdown tooltip=\"Regex Options\" defaultValue=\"gm\" onChange={onOptionsChange}>\n      <List.Dropdown.Item title=\"No Modifiers\" value=\"\" />\n      <List.Dropdown.Item title=\"Global (/g)\" value=\"g\" />\n      <List.Dropdown.Item title=\"Case-Insensitive (/i)\" value=\"i\" />\n      <List.Dropdown.Item title=\"Multiline (/m)\" value=\"m\" />\n      <List.Dropdown.Item title=\"Global, Case-Insensitive (/gi)\" value=\"gi\" />\n      <List.Dropdown.Item title=\"Global, Multiline (/gm)\" value=\"gm\" />\n      <List.Dropdown.Item title=\"Case-Insensitive, Multiline (/im)\" value=\"im\" />\n      <List.Dropdown.Item title=\"All Modifiers (/gim)\" value=\"gim\" />\n    </List.Dropdown>\n  );\n};\n\nexport default RegexOptions;\n"],
  "mappings": "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",
  "names": ["Symbol", "iterator", "asyncIterator", "useIsomorphicLayoutEffect", "window", "document", "createElement", "useLayoutEffect", "useEffect", "InitialAsyncState", "status", "loading", "result", "error", "undefined", "InitialAsyncLoadingState", "noop", "DefaultOptions", "initialState", "options", "executeOnMount", "executeOnUpdate", "setLoading", "_asyncState", "setResult", "setError", "onSuccess", "onError", "useAsyncInternal", "asyncFunction", "params", "ref", "normalizedOptions", "useState", "currentParams", "setCurrentParams", "AsyncState", "value", "setValue", "reset", "useCallback", "merge", "state", "set", "isMounted", "useRef", "current", "CurrentPromise", "promise", "get", "is", "useCurrentPromise", "shouldHandlePromise", "p", "getLatestExecuteAsyncOperation", "t", "e", "args", "then", "isCurrent", "executeAsyncOperationMemo", "isMounting", "execute", "currentPromise", "useAsync", "abortControllerRef", "abort", "abortController", "AbortController", "body", "finalizer", "signal", "bind", "_iteratorSymbol", "_asyncIteratorSymbol", "_finallyRethrows", "body", "finalizer", "result", "e", "useIsomorphicLayoutEffect", "window", "document", "createElement", "useLayoutEffect", "useEffect", "useGetter", "t", "ref", "useRef", "current", "useCallback", "InitialAsyncState", "status", "loading", "undefined", "error", "InitialAsyncLoadingState", "defaultSetLoading", "_asyncState", "defaultSetResult", "defaultSetError", "noop", "DefaultOptions", "initialState", "options", "executeOnMount", "executeOnUpdate", "setLoading", "setResult", "setError", "onSuccess", "onError", "normalizeOptions", "useAsyncState", "useState", "value", "setValue", "reset", "merge", "state", "_extends", "set", "useIsMounted", "useCurrentPromise", "promise", "get", "is", "useAsyncInternal", "asyncFunction", "params", "normalizedOptions", "currentParams", "setCurrentParams", "AsyncState", "isMounted", "CurrentPromise", "shouldHandlePromise", "p", "executeAsyncOperation", "args", "then", "isCurrent", "getLatestExecuteAsyncOperation", "executeAsyncOperationMemo", "isMounting", "execute", "currentPromise", "useAsync", "useAsyncAbortable", "abortControllerRef", "asyncFunctionWrapper", "_len2", "_key2", "abort", "abortController", "AbortController", "signal", "useAsyncCallback", "require_dist", "__commonJSMin", "exports", "module", "index_exports", "__export", "Command", "__toCommonJS", "import_react", "import_api", "import_react", "import_api", "import_react_async_hook", "import_jsx_runtime", "FormScreen", "onSubmit", "text", "setText", "pastStrings", "setPastStrings", "source", "setSource", "item", "sources", "str", "clearPreviousStrings", "FormScreen_default", "import_react_async_hook", "import_api", "import_react", "import_api", "import_jsx_runtime", "CheatSheet", "markdown", "CheatSheet_default", "import_api", "import_jsx_runtime", "RegexOptions", "onOptionsChange", "RegexOptions_default", "import_jsx_runtime", "MainScreen", "testString", "query", "setQuery", "highlightedText", "setHighlightedText", "options", "setOptions", "handleOptionsChange", "nextHighlightedText", "match", "error", "RegexOptions_default", "CheatSheet_default", "MainScreen_default", "import_jsx_runtime", "Command", "testString", "setTestString", "source", "setSource", "push", "newString", "previousItem", "previousStrings", "nextStrings", "handleSubmit", "values", "MainScreen_default", "FormScreen_default"]
}
