{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/parse-input.ts", "../src/line-strings.ts", "../src/generate-tree.ts"],
  "sourcesContent": ["import { Form, ActionPanel, Action } from \"@raycast/api\";\nimport { useState } from \"react\";\nimport { parseInput } from \"./parse-input\";\nimport { GenerateTreeOptions, generateTree } from \"./generate-tree\";\n\nexport default function Command() {\n  const [description, setDescription] = useState<string>(\"\");\n  const [options, setOptions] = useState<GenerateTreeOptions>({\n    charset: \"utf-8\",\n    trailingDirSlash: true,\n    fullPath: false,\n    rootDot: false,\n  });\n\n  const onDropdownChange = (value: \"ascii\" | \"utf-8\") => {\n    setOptions({ ...options, charset: value });\n  };\n\n  const onCheckboxChange = (id: keyof GenerateTreeOptions) => {\n    return (value: boolean) => setOptions({ ...options, [id]: value });\n  };\n\n  const onDescriptionChange = (value: string) => {\n    setDescription(value);\n  };\n\n  // console.log(options);\n\n  return (\n    <Form\n      actions={\n        <ActionPanel>\n          <Action.CopyToClipboard title=\"Copy Output\" content={generateTree(parseInput(description), options)} />\n        </ActionPanel>\n      }\n    >\n      <Form.TextArea id=\"input\" title=\"Input\" value={description} onChange={onDescriptionChange} />\n      <Form.Dropdown\n        id=\"charset\"\n        title=\"Charset\"\n        value={options.charset}\n        onChange={(value: string) => onDropdownChange(value as \"ascii\" | \"utf-8\")}\n        storeValue\n      >\n        <Form.Dropdown.Item value=\"ascii\" title=\"ASCII\" />\n        <Form.Dropdown.Item value=\"utf-8\" title=\"UTF-8\" />\n      </Form.Dropdown>\n      <Form.Checkbox\n        id=\"trailingDirSlash\"\n        label=\"Show Trailing /\"\n        value={options.trailingDirSlash}\n        onChange={onCheckboxChange(\"trailingDirSlash\")}\n      />\n      <Form.Checkbox\n        id=\"fullPath\"\n        label=\"Show Full Path\"\n        value={options.fullPath}\n        onChange={onCheckboxChange(\"fullPath\")}\n        storeValue\n      />\n      <Form.Checkbox\n        id=\"rootDot\"\n        label=\"Show Root .\"\n        value={options.rootDot}\n        onChange={onCheckboxChange(\"rootDot\")}\n        storeValue\n      />\n      <Form.TextArea\n        id=\"output\"\n        title=\"Output\"\n        value={generateTree(parseInput(description), options)}\n        onChange={() => {}}\n      />\n    </Form>\n  );\n}\n", "import { FileStructure } from \"./FileStructure\";\n\n/**\n * Matches the whitespace in front of a file name.\n * Also will match a markdown bullet point if included.\n * For example, testing against \"  - hello\" will return\n * a positive match with the first capturing group\n * with \"  - \" and a second with \"  \"\n */\nconst leadingWhitespaceAndBulletRegex = /^((\\s*)(?:-\\s)?)/;\n\n/** Matches lines that only contain whitespace */\nconst onlyWhitespaceRegex = /^\\s*$/;\n\n/** Used to split a block of text into individual lines */\nconst newlineSplitterRegex = /[^\\r\\n]+/g;\n\n/**\n * Translates a block of user-created text into\n * a nested FileStructure structure\n * @param input The plain-text input from the user\n */\nexport const parseInput = (input: string): FileStructure => {\n  const structures = splitInput(input);\n\n  const root: FileStructure = {\n    name: \".\",\n    children: [],\n    indentCount: -1,\n    parent: null,\n  };\n\n  const path = [root];\n  for (const s of structures) {\n    while (path[path.length - 1]!.indentCount >= s.indentCount) {\n      path.pop();\n    }\n\n    const parent = path[path.length - 1] as FileStructure;\n    parent.children.push(s);\n    s.parent = parent;\n\n    path.push(s);\n  }\n\n  return root;\n};\n\n/**\n * Splits a block of user-created text into\n * individual, un-nested FileStructure objects.\n * Used internally as part of `parseInput`.\n * @param input The plain-text input from the user\n */\nexport const splitInput = (input: string): FileStructure[] => {\n  let lines: string[] = input.match(newlineSplitterRegex) || [];\n\n  // filter out empty lines\n  lines = lines.filter((l) => !onlyWhitespaceRegex.test(l));\n\n  return lines.map((l) => {\n    const matchResult = leadingWhitespaceAndBulletRegex.exec(l);\n\n    if (!matchResult) {\n      throw new Error(`Unable to execute leadingWhitespaceAndBulletRegex against string: \"${l}\"`);\n    }\n\n    const name = l.replace(matchResult[1], \"\");\n    const indentCount = matchResult[2].length;\n\n    return {\n      name,\n      children: [],\n      indentCount,\n      parent: null,\n    };\n  });\n};\n", "/**\n * Represents an object that contains the\n * actual strings used to render the tree\n */\nexport interface LineStringSet {\n  /** The string to render immediately before non-last children */\n  CHILD: string;\n\n  /** The string to render immediately before the last child */\n  LAST_CHILD: string;\n\n  /** The string to render for parent directories */\n  DIRECTORY: string;\n\n  /** The string to render for empty space */\n  EMPTY: string;\n}\n\n/** Contains all strings for tree rendering */\nexport const LINE_STRINGS: { [charset: string]: LineStringSet } = {\n  ascii: {\n    CHILD: \"|-- \",\n    LAST_CHILD: \"`-- \",\n    DIRECTORY: \"|   \",\n    EMPTY: \"    \",\n  },\n  \"utf-8\": {\n    CHILD: \"\u251C\u2500\u2500 \",\n    LAST_CHILD: \"\u2514\u2500\u2500 \",\n    DIRECTORY: \"\u2502   \",\n    EMPTY: \"    \",\n  },\n};\n", "import { FileStructure } from \"./FileStructure\";\nimport { LINE_STRINGS } from \"./line-strings\";\n\n/**\n * Represents all rendering options available\n * when calling `generateTree`\n */\nexport interface GenerateTreeOptions {\n  /**\n   * Which set of characters to use when\n   * rendering directory lines\n   */\n  charset?: \"ascii\" | \"utf-8\";\n\n  /**\n   * Whether or not to append trailing slashes\n   * to directories. Items that already include a\n   * trailing slash will not have another appended.\n   */\n  trailingDirSlash?: boolean;\n\n  /**\n   * Whether or not to print the full\n   * path of the item\n   */\n  fullPath?: boolean;\n\n  /**\n   * Whether or not to render a dot as the root of the tree\n   */\n  rootDot?: boolean;\n}\n\n/** The default options if no options are provided */\nexport const defaultOptions: GenerateTreeOptions = {\n  charset: \"utf-8\",\n  trailingDirSlash: false,\n  fullPath: false,\n  rootDot: true,\n};\n\nconst flattenTree = (structure: FileStructure, options: GenerateTreeOptions): Array<string | null> => {\n  let lines: Array<string | null> = [getAsciiLine(structure, options)];\n  for (const child of structure.children) {\n    lines = lines.concat(flattenTree(child, options));\n  }\n  return lines;\n};\n\n/**\n * Generates an ASCII tree diagram, given a FileStructure\n * @param structure The FileStructure object to convert into ASCII\n * @param options The rendering options\n */\nexport const generateTree = (structure: FileStructure, options?: GenerateTreeOptions): string => {\n  const combinedOptions = { ...defaultOptions, ...options };\n  const lines = flattenTree(structure, combinedOptions)\n    .filter((line) => line != null)\n    .join(\"\\n\");\n  return lines;\n};\n\n/**\n * Returns a line of ASCII that represents\n * a single FileStructure object\n * @param structure The file to render\n * @param options The rendering options\n */\nconst getAsciiLine = (structure: FileStructure, options: GenerateTreeOptions): string | null => {\n  const lines = LINE_STRINGS[options.charset as string];\n\n  // Special case for the root element\n  if (!structure.parent) {\n    return options.rootDot ? structure.name : null;\n  }\n\n  const chunks = [isLastChild(structure) ? lines.LAST_CHILD : lines.CHILD, getName(structure, options)];\n\n  let current = structure.parent;\n  while (current && current.parent) {\n    chunks.unshift(isLastChild(current) ? lines.EMPTY : lines.DIRECTORY);\n    current = current.parent;\n  }\n\n  // Join all the chunks together to create the final line.\n  // If we're not rendering the root `.`, chop off the first 4 characters.\n  return chunks.join(\"\").substring(options.rootDot ? 0 : lines.CHILD.length);\n};\n\n/**\n * Returns the name of a file or folder according to the\n * rules specified by the rendering rules\n * @param structure The file or folder to get the name of\n * @param options The rendering options\n */\nconst getName = (structure: FileStructure, options: GenerateTreeOptions): string => {\n  const nameChunks = [structure.name];\n\n  // Optionally append a trailing slash\n  if (\n    // if the trailing slash option is enabled\n    options.trailingDirSlash &&\n    // and if the item has at least one child\n    structure.children.length > 0 &&\n    // and if the item doesn't already have a trailing slash\n    !/\\/\\s*$/.test(structure.name)\n  ) {\n    nameChunks.push(\"/\");\n  }\n\n  // Optionally prefix the name with its full path\n  if (options.fullPath && structure.parent) {\n    nameChunks.unshift(getName(structure.parent, { ...options, trailingDirSlash: true }));\n  }\n\n  return nameChunks.join(\"\");\n};\n\n/**\n * A utility function do determine if a file or folder\n * is the last child of its parent\n * @param structure The file or folder to test\n */\nconst isLastChild = (structure: FileStructure): boolean =>\n  Boolean(structure.parent && structure.parent.children[structure.parent.children.length - 1] === structure);\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "leadingWhitespaceAndBulletRegex", "onlyWhitespaceRegex", "newlineSplitterRegex", "parseInput", "input", "structures", "splitInput", "root", "path", "s", "parent", "lines", "l", "matchResult", "name", "indentCount", "LINE_STRINGS", "defaultOptions", "flattenTree", "structure", "options", "lines", "getAsciiLine", "child", "generateTree", "combinedOptions", "line", "LINE_STRINGS", "chunks", "isLastChild", "getName", "current", "nameChunks", "import_jsx_runtime", "Command", "description", "setDescription", "options", "setOptions", "onDropdownChange", "value", "onCheckboxChange", "id", "onDescriptionChange", "generateTree", "parseInput"]
}
