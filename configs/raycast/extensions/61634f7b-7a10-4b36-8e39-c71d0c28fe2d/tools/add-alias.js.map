{
  "version": 3,
  "sources": ["../../src/tools/add-alias.ts", "../../src/utils/alias-utils.ts"],
  "sourcesContent": ["import { addAlias, aliasExists, getConfigFiles, validateAliasCommand, validateAliasName } from \"../utils/alias-utils\";\n\n/**\n * Input parameters for adding an alias\n */\ntype Input = {\n  /** The name of the alias to create */\n  name: string;\n  /** The command that the alias should execute */\n  command: string;\n  /** The configuration file to add the alias to (.zshrc, .zsh_aliases, or .aliases). If not specified, defaults to the first available config file */\n  configFile?: string;\n};\n\n/**\n * Add a new zsh alias\n *\n * This tool creates a new alias in the specified configuration file.\n * It validates the alias name and command, checks for duplicates,\n * and handles file creation if necessary.\n *\n * @param input - The alias name, command, and optional config file\n * @returns Response indicating success or failure with details\n */\nexport default function addAliasCommand(input: Input) {\n  try {\n    const { name, command, configFile } = input;\n\n    // Validate alias name\n    const nameValidation = validateAliasName(name);\n    if (!nameValidation.isValid) {\n      return {\n        success: false,\n        message: nameValidation.error || \"Invalid alias name\",\n      };\n    }\n\n    // Validate alias command\n    const commandValidation = validateAliasCommand(command);\n    if (!commandValidation.isValid) {\n      return {\n        success: false,\n        message: commandValidation.error || \"Invalid alias command\",\n      };\n    }\n\n    // Check if alias already exists\n    if (aliasExists(name)) {\n      return {\n        success: false,\n        message: `Alias '${name}' already exists`,\n      };\n    }\n\n    // Get available config files\n    const availableFiles = getConfigFiles();\n\n    // Validate config file if provided\n    if (\n      configFile &&\n      !availableFiles.includes(configFile) &&\n      ![\".zshrc\", \".zsh_aliases\", \".aliases\"].includes(configFile)\n    ) {\n      return {\n        success: false,\n        message: `Invalid config file '${configFile}'. Must be one of: .zshrc, .zsh_aliases, .aliases`,\n      };\n    }\n\n    // Determine config file to use (after validation)\n    const targetFile = configFile || availableFiles[0];\n\n    // Add the alias\n    addAlias(name, command, targetFile);\n\n    return {\n      success: true,\n      message: `Alias '${name}' added successfully to ${targetFile}`,\n      aliasName: name,\n      configFile: targetFile,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: `Failed to add alias: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n    };\n  }\n}\n", "import { appendFileSync, existsSync, readFileSync, writeFileSync } from \"fs\";\nimport { homedir } from \"os\";\nimport { join } from \"path\";\n\nexport interface Alias {\n  name: string;\n  command: string;\n  file: string;\n}\n\n/**\n * Escapes special regex characters in a string\n * @param str - The string to escape\n * @returns The escaped string safe for use in RegExp\n */\nfunction escapeRegExp(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  error?: string;\n}\n\n/**\n * Parse aliases from zsh configuration files\n * @returns Array of parsed aliases\n */\nexport function parseAliases(): Alias[] {\n  const homeDir = homedir();\n  const configFiles = [\".zshrc\", \".zsh_aliases\", \".aliases\"];\n  const aliases: Alias[] = [];\n  const aliasPattern = /^\\s*alias\\s+([^=]+)=(['\"]?)(.+?)\\2\\s*$/;\n\n  for (const configFile of configFiles) {\n    const filePath = join(homeDir, configFile);\n    if (existsSync(filePath)) {\n      try {\n        const content = readFileSync(filePath, \"utf-8\");\n        const lines = content.split(\"\\n\");\n\n        for (const line of lines) {\n          const match = line.match(aliasPattern);\n          if (match) {\n            aliases.push({\n              name: match[1].trim(),\n              command: match[3].trim(),\n              file: configFile,\n            });\n          }\n        }\n      } catch (error) {\n        console.error(`Error reading ${configFile}:`, error);\n      }\n    }\n  }\n\n  return aliases.sort((a, b) => a.name.localeCompare(b.name));\n}\n\n/**\n * Get available zsh configuration files\n * @returns Array of configuration file paths\n */\nexport function getConfigFiles(): string[] {\n  const homeDir = homedir();\n  const configFiles = [\".zshrc\", \".zsh_aliases\", \".aliases\"];\n  const availableFiles: string[] = [];\n\n  for (const configFile of configFiles) {\n    const filePath = join(homeDir, configFile);\n    if (existsSync(filePath)) {\n      availableFiles.push(configFile);\n    }\n  }\n\n  // If no config files exist, default to .zshrc\n  if (availableFiles.length === 0) {\n    availableFiles.push(\".zshrc\");\n  }\n\n  return availableFiles;\n}\n\n/**\n * Check if an alias name already exists in any configuration file\n * @param aliasName - Name to check\n * @param excludeFile - Optional file to exclude from check\n * @param excludeName - Optional name to exclude from check (for renaming)\n */\nexport function aliasExists(aliasName: string, excludeFile?: string, excludeName?: string): boolean {\n  const homeDir = homedir();\n  const configFiles = [\".zshrc\", \".zsh_aliases\", \".aliases\"];\n\n  for (const configFile of configFiles) {\n    const filePath = join(homeDir, configFile);\n    if (existsSync(filePath)) {\n      try {\n        const content = readFileSync(filePath, \"utf-8\");\n        const aliasPattern = new RegExp(`^\\\\s*alias\\\\s+${escapeRegExp(aliasName)}=`, \"m\");\n        if (aliasPattern.test(content)) {\n          // If we're checking the same file and name (for rename), don't count it as existing\n          if (excludeFile === configFile && excludeName === aliasName) {\n            continue;\n          }\n          return true;\n        }\n      } catch (error) {\n        console.error(`Error reading ${configFile}:`, error);\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Add an alias to the specified configuration file\n * @param aliasName - Name of the alias\n * @param aliasCommand - Command for the alias\n * @param configFile - Configuration file to add the alias to\n */\nexport function addAlias(aliasName: string, aliasCommand: string, configFile: string): void {\n  const homeDir = homedir();\n  const filePath = join(homeDir, configFile);\n\n  // Escape single quotes in the command\n  const escapedCommand = aliasCommand.replace(/'/g, \"'\\\\''\");\n  const aliasLine = `alias ${aliasName}='${escapedCommand}'`;\n\n  try {\n    if (existsSync(filePath)) {\n      // Read existing content\n      const content = readFileSync(filePath, \"utf-8\");\n\n      // Check if file ends with newline\n      const endsWithNewline = content.endsWith(\"\\n\");\n\n      // Append alias with proper newlines\n      const newContent = endsWithNewline ? `${aliasLine}\\n` : `\\n${aliasLine}\\n`;\n      appendFileSync(filePath, newContent);\n    } else {\n      // Create new file with the alias\n      writeFileSync(filePath, `${aliasLine}\\n`);\n    }\n  } catch (error) {\n    throw new Error(`Failed to write to ${configFile}: ${error}`);\n  }\n}\n\n/**\n * Update an alias in its configuration file (supports renaming)\n * @param oldName - Original name of the alias\n * @param newName - New name for the alias\n * @param newCommand - New command for the alias\n * @param configFile - Configuration file containing the alias\n */\nexport function updateAlias(oldName: string, newName: string, newCommand: string, configFile: string): void {\n  const homeDir = homedir();\n  const filePath = join(homeDir, configFile);\n\n  if (!existsSync(filePath)) {\n    throw new Error(`Configuration file ${configFile} not found`);\n  }\n\n  try {\n    const content = readFileSync(filePath, \"utf-8\");\n    const lines = content.split(\"\\n\");\n    const aliasPattern = new RegExp(`^\\\\s*alias\\\\s+${escapeRegExp(oldName)}=(.*)$`);\n    let updated = false;\n\n    const newLines = lines.map((line) => {\n      const match = line.match(aliasPattern);\n      if (match) {\n        updated = true;\n        // Escape single quotes in the command\n        const escapedCommand = newCommand.replace(/'/g, \"'\\\\''\");\n        return `alias ${newName}='${escapedCommand}'`;\n      }\n      return line;\n    });\n\n    if (!updated) {\n      throw new Error(`Alias '${oldName}' not found in ${configFile}`);\n    }\n\n    writeFileSync(filePath, newLines.join(\"\\n\"));\n  } catch (error) {\n    if (error instanceof Error && error.message.includes(\"not found\")) {\n      throw error;\n    }\n    throw new Error(`Failed to update alias in ${configFile}: ${error}`);\n  }\n}\n\n/**\n * Remove an alias from its configuration file\n * @param aliasName - Name of the alias to remove\n * @param configFile - Configuration file containing the alias\n * @returns True if removed successfully, false otherwise\n */\nexport function removeAlias(aliasName: string, configFile: string): boolean {\n  const homeDir = homedir();\n  const filePath = join(homeDir, configFile);\n\n  if (!existsSync(filePath)) {\n    throw new Error(`Configuration file ${configFile} not found`);\n  }\n\n  try {\n    const content = readFileSync(filePath, \"utf-8\");\n    const lines = content.split(\"\\n\");\n    const aliasPattern = new RegExp(`^\\\\s*alias\\\\s+${escapeRegExp(aliasName)}=`);\n    let removed = false;\n\n    const newLines = lines.filter((line) => {\n      if (aliasPattern.test(line)) {\n        removed = true;\n        return false;\n      }\n      return true;\n    });\n\n    if (removed) {\n      writeFileSync(filePath, newLines.join(\"\\n\"));\n      return true;\n    }\n\n    return false;\n  } catch (error) {\n    throw new Error(`Failed to remove alias from ${configFile}: ${error}`);\n  }\n}\n\n/**\n * Validate alias name format\n * @param name - Alias name to validate\n * @returns Validation result with error message if invalid\n */\nexport function validateAliasName(name: string): ValidationResult {\n  if (!name || name.trim() === \"\") {\n    return { isValid: false, error: \"Alias name is required\" };\n  }\n  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {\n    return {\n      isValid: false,\n      error: \"Alias name must start with a letter or underscore and contain only letters, numbers, and underscores\",\n    };\n  }\n  return { isValid: true };\n}\n\n/**\n * Validate alias command format\n * @param command - Alias command to validate\n * @returns Validation result with error message if invalid\n */\nexport function validateAliasCommand(command: string): ValidationResult {\n  if (!command || command.trim() === \"\") {\n    return { isValid: false, error: \"Alias command is required\" };\n  }\n  return { isValid: true };\n}\n\n/**\n * Search aliases by name or command\n * @param query - Search query\n * @param aliases - Array of aliases to search through\n * @returns Array of matching aliases\n */\nexport function searchAliases(query: string, aliases?: Alias[]): Alias[] {\n  const aliasesToSearch = aliases || parseAliases();\n  const lowerQuery = query.toLowerCase();\n\n  return aliasesToSearch.filter(\n    (alias) => alias.name.toLowerCase().includes(lowerQuery) || alias.command.toLowerCase().includes(lowerQuery),\n  );\n}\n"],
  "mappings": "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",
  "names": ["add_alias_exports", "__export", "addAliasCommand", "__toCommonJS", "import_fs", "import_os", "import_path", "escapeRegExp", "str", "getConfigFiles", "homeDir", "configFiles", "availableFiles", "configFile", "filePath", "aliasExists", "aliasName", "excludeFile", "excludeName", "content", "escapeRegExp", "error", "addAlias", "aliasCommand", "escapedCommand", "aliasLine", "newContent", "validateAliasName", "name", "validateAliasCommand", "command", "addAliasCommand", "input", "name", "command", "configFile", "nameValidation", "validateAliasName", "commandValidation", "validateAliasCommand", "aliasExists", "availableFiles", "getConfigFiles", "targetFile", "addAlias", "error"]
}
