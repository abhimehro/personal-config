{
  "version": 3,
  "sources": ["../../src/tools/update-alias.ts", "../../src/utils/alias-utils.ts"],
  "sourcesContent": ["import { Tool } from \"@raycast/api\";\nimport { aliasExists, parseAliases, updateAlias, validateAliasCommand, validateAliasName } from \"../utils/alias-utils\";\n\n/**\n * Input parameters for updating an alias\n */\ntype Input = {\n  /** The current name of the alias to update */\n  currentName: string;\n  /** The new name for the alias (can be the same as currentName) */\n  newName: string;\n  /** The new command for the alias */\n  newCommand: string;\n  /** The configuration file containing the alias (.zshrc, .zsh_aliases, or .aliases). If not specified, searches all config files */\n  configFile?: string;\n};\n\n/**\n * Confirmation function for the update alias tool\n * Shows a confirmation dialog before updating the alias\n */\nexport const confirmation: Tool.Confirmation<Input> = async (input) => {\n  const { currentName, newName, newCommand, configFile } = input;\n\n  // Find the current alias to get details for confirmation\n  const aliases = parseAliases();\n  const currentAlias = aliases.find(\n    (alias) => alias.name === currentName && (!configFile || alias.file === configFile),\n  );\n\n  if (!currentAlias) {\n    return {\n      message: `Alias '${currentName}' not found${configFile ? ` in ${configFile}` : \"\"}`,\n    };\n  }\n\n  const isRename = currentName !== newName;\n  const message = isRename\n    ? `Are you sure you want to rename '${currentName}' to '${newName}' and update its command?`\n    : `Are you sure you want to update the command for '${currentName}'?`;\n\n  return {\n    message,\n    /**\n     * @type {Array<{name: string, value: string}>}\n     */\n    info: [\n      { name: \"Current Name\", value: currentAlias.name },\n      { name: \"New Name\", value: newName },\n      { name: \"Current Command\", value: currentAlias.command },\n      { name: \"New Command\", value: newCommand },\n      { name: \"File\", value: currentAlias.file },\n    ],\n  };\n};\n\n/**\n * Update an existing zsh alias\n *\n * This tool updates an alias name and/or command in the specified configuration file.\n * If no config file is specified, it searches all config files to find the alias.\n * Supports both renaming and command updates. Requires confirmation before changes.\n *\n * @param input - The current name, new name, new command, and optional config file\n * @returns Response indicating success or failure with details\n */\nexport default function updateAliasCommand(input: Input) {\n  try {\n    const { currentName, newName, newCommand, configFile } = input;\n\n    // Validate new alias name\n    const nameValidation = validateAliasName(newName);\n    if (!nameValidation.isValid) {\n      return {\n        success: false,\n        message: nameValidation.error || \"Invalid alias name\",\n      };\n    }\n\n    // Validate new alias command\n    const commandValidation = validateAliasCommand(newCommand);\n    if (!commandValidation.isValid) {\n      return {\n        success: false,\n        message: commandValidation.error || \"Invalid alias command\",\n      };\n    }\n\n    // If config file is specified, try to update in that file\n    if (configFile) {\n      // Check if we're renaming and the new name already exists\n      if (currentName !== newName && aliasExists(newName, configFile, currentName)) {\n        return {\n          success: false,\n          message: `Alias '${newName}' already exists`,\n        };\n      }\n\n      updateAlias(currentName, newName, newCommand, configFile);\n\n      return {\n        success: true,\n        message:\n          currentName !== newName\n            ? `Alias '${currentName}' renamed to '${newName}' and updated in ${configFile}`\n            : `Alias '${currentName}' updated successfully in ${configFile}`,\n        oldName: currentName,\n        newName,\n        configFile,\n      };\n    }\n\n    // If no config file specified, search all files to find the alias\n    const aliases = parseAliases();\n    const aliasToUpdate = aliases.find((alias) => alias.name === currentName);\n\n    if (!aliasToUpdate) {\n      return {\n        success: false,\n        message: `Alias '${currentName}' not found`,\n      };\n    }\n\n    // Check if we're renaming and the new name already exists\n    if (currentName !== newName && aliasExists(newName, aliasToUpdate.file, currentName)) {\n      return {\n        success: false,\n        message: `Alias '${newName}' already exists`,\n      };\n    }\n\n    // Update in the file where it was found\n    updateAlias(currentName, newName, newCommand, aliasToUpdate.file);\n\n    return {\n      success: true,\n      message:\n        currentName !== newName\n          ? `Alias '${currentName}' renamed to '${newName}' and updated in ${aliasToUpdate.file}`\n          : `Alias '${currentName}' updated successfully in ${aliasToUpdate.file}`,\n      oldName: currentName,\n      newName,\n      configFile: aliasToUpdate.file,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: `Failed to update alias: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n    };\n  }\n}\n", "import { appendFileSync, existsSync, readFileSync, writeFileSync } from \"fs\";\nimport { homedir } from \"os\";\nimport { join } from \"path\";\n\nexport interface Alias {\n  name: string;\n  command: string;\n  file: string;\n}\n\n/**\n * Escapes special regex characters in a string\n * @param str - The string to escape\n * @returns The escaped string safe for use in RegExp\n */\nfunction escapeRegExp(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  error?: string;\n}\n\n/**\n * Parse aliases from zsh configuration files\n * @returns Array of parsed aliases\n */\nexport function parseAliases(): Alias[] {\n  const homeDir = homedir();\n  const configFiles = [\".zshrc\", \".zsh_aliases\", \".aliases\"];\n  const aliases: Alias[] = [];\n  const aliasPattern = /^\\s*alias\\s+([^=]+)=(['\"]?)(.+?)\\2\\s*$/;\n\n  for (const configFile of configFiles) {\n    const filePath = join(homeDir, configFile);\n    if (existsSync(filePath)) {\n      try {\n        const content = readFileSync(filePath, \"utf-8\");\n        const lines = content.split(\"\\n\");\n\n        for (const line of lines) {\n          const match = line.match(aliasPattern);\n          if (match) {\n            aliases.push({\n              name: match[1].trim(),\n              command: match[3].trim(),\n              file: configFile,\n            });\n          }\n        }\n      } catch (error) {\n        console.error(`Error reading ${configFile}:`, error);\n      }\n    }\n  }\n\n  return aliases.sort((a, b) => a.name.localeCompare(b.name));\n}\n\n/**\n * Get available zsh configuration files\n * @returns Array of configuration file paths\n */\nexport function getConfigFiles(): string[] {\n  const homeDir = homedir();\n  const configFiles = [\".zshrc\", \".zsh_aliases\", \".aliases\"];\n  const availableFiles: string[] = [];\n\n  for (const configFile of configFiles) {\n    const filePath = join(homeDir, configFile);\n    if (existsSync(filePath)) {\n      availableFiles.push(configFile);\n    }\n  }\n\n  // If no config files exist, default to .zshrc\n  if (availableFiles.length === 0) {\n    availableFiles.push(\".zshrc\");\n  }\n\n  return availableFiles;\n}\n\n/**\n * Check if an alias name already exists in any configuration file\n * @param aliasName - Name to check\n * @param excludeFile - Optional file to exclude from check\n * @param excludeName - Optional name to exclude from check (for renaming)\n */\nexport function aliasExists(aliasName: string, excludeFile?: string, excludeName?: string): boolean {\n  const homeDir = homedir();\n  const configFiles = [\".zshrc\", \".zsh_aliases\", \".aliases\"];\n\n  for (const configFile of configFiles) {\n    const filePath = join(homeDir, configFile);\n    if (existsSync(filePath)) {\n      try {\n        const content = readFileSync(filePath, \"utf-8\");\n        const aliasPattern = new RegExp(`^\\\\s*alias\\\\s+${escapeRegExp(aliasName)}=`, \"m\");\n        if (aliasPattern.test(content)) {\n          // If we're checking the same file and name (for rename), don't count it as existing\n          if (excludeFile === configFile && excludeName === aliasName) {\n            continue;\n          }\n          return true;\n        }\n      } catch (error) {\n        console.error(`Error reading ${configFile}:`, error);\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Add an alias to the specified configuration file\n * @param aliasName - Name of the alias\n * @param aliasCommand - Command for the alias\n * @param configFile - Configuration file to add the alias to\n */\nexport function addAlias(aliasName: string, aliasCommand: string, configFile: string): void {\n  const homeDir = homedir();\n  const filePath = join(homeDir, configFile);\n\n  // Escape single quotes in the command\n  const escapedCommand = aliasCommand.replace(/'/g, \"'\\\\''\");\n  const aliasLine = `alias ${aliasName}='${escapedCommand}'`;\n\n  try {\n    if (existsSync(filePath)) {\n      // Read existing content\n      const content = readFileSync(filePath, \"utf-8\");\n\n      // Check if file ends with newline\n      const endsWithNewline = content.endsWith(\"\\n\");\n\n      // Append alias with proper newlines\n      const newContent = endsWithNewline ? `${aliasLine}\\n` : `\\n${aliasLine}\\n`;\n      appendFileSync(filePath, newContent);\n    } else {\n      // Create new file with the alias\n      writeFileSync(filePath, `${aliasLine}\\n`);\n    }\n  } catch (error) {\n    throw new Error(`Failed to write to ${configFile}: ${error}`);\n  }\n}\n\n/**\n * Update an alias in its configuration file (supports renaming)\n * @param oldName - Original name of the alias\n * @param newName - New name for the alias\n * @param newCommand - New command for the alias\n * @param configFile - Configuration file containing the alias\n */\nexport function updateAlias(oldName: string, newName: string, newCommand: string, configFile: string): void {\n  const homeDir = homedir();\n  const filePath = join(homeDir, configFile);\n\n  if (!existsSync(filePath)) {\n    throw new Error(`Configuration file ${configFile} not found`);\n  }\n\n  try {\n    const content = readFileSync(filePath, \"utf-8\");\n    const lines = content.split(\"\\n\");\n    const aliasPattern = new RegExp(`^\\\\s*alias\\\\s+${escapeRegExp(oldName)}=(.*)$`);\n    let updated = false;\n\n    const newLines = lines.map((line) => {\n      const match = line.match(aliasPattern);\n      if (match) {\n        updated = true;\n        // Escape single quotes in the command\n        const escapedCommand = newCommand.replace(/'/g, \"'\\\\''\");\n        return `alias ${newName}='${escapedCommand}'`;\n      }\n      return line;\n    });\n\n    if (!updated) {\n      throw new Error(`Alias '${oldName}' not found in ${configFile}`);\n    }\n\n    writeFileSync(filePath, newLines.join(\"\\n\"));\n  } catch (error) {\n    if (error instanceof Error && error.message.includes(\"not found\")) {\n      throw error;\n    }\n    throw new Error(`Failed to update alias in ${configFile}: ${error}`);\n  }\n}\n\n/**\n * Remove an alias from its configuration file\n * @param aliasName - Name of the alias to remove\n * @param configFile - Configuration file containing the alias\n * @returns True if removed successfully, false otherwise\n */\nexport function removeAlias(aliasName: string, configFile: string): boolean {\n  const homeDir = homedir();\n  const filePath = join(homeDir, configFile);\n\n  if (!existsSync(filePath)) {\n    throw new Error(`Configuration file ${configFile} not found`);\n  }\n\n  try {\n    const content = readFileSync(filePath, \"utf-8\");\n    const lines = content.split(\"\\n\");\n    const aliasPattern = new RegExp(`^\\\\s*alias\\\\s+${escapeRegExp(aliasName)}=`);\n    let removed = false;\n\n    const newLines = lines.filter((line) => {\n      if (aliasPattern.test(line)) {\n        removed = true;\n        return false;\n      }\n      return true;\n    });\n\n    if (removed) {\n      writeFileSync(filePath, newLines.join(\"\\n\"));\n      return true;\n    }\n\n    return false;\n  } catch (error) {\n    throw new Error(`Failed to remove alias from ${configFile}: ${error}`);\n  }\n}\n\n/**\n * Validate alias name format\n * @param name - Alias name to validate\n * @returns Validation result with error message if invalid\n */\nexport function validateAliasName(name: string): ValidationResult {\n  if (!name || name.trim() === \"\") {\n    return { isValid: false, error: \"Alias name is required\" };\n  }\n  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {\n    return {\n      isValid: false,\n      error: \"Alias name must start with a letter or underscore and contain only letters, numbers, and underscores\",\n    };\n  }\n  return { isValid: true };\n}\n\n/**\n * Validate alias command format\n * @param command - Alias command to validate\n * @returns Validation result with error message if invalid\n */\nexport function validateAliasCommand(command: string): ValidationResult {\n  if (!command || command.trim() === \"\") {\n    return { isValid: false, error: \"Alias command is required\" };\n  }\n  return { isValid: true };\n}\n\n/**\n * Search aliases by name or command\n * @param query - Search query\n * @param aliases - Array of aliases to search through\n * @returns Array of matching aliases\n */\nexport function searchAliases(query: string, aliases?: Alias[]): Alias[] {\n  const aliasesToSearch = aliases || parseAliases();\n  const lowerQuery = query.toLowerCase();\n\n  return aliasesToSearch.filter(\n    (alias) => alias.name.toLowerCase().includes(lowerQuery) || alias.command.toLowerCase().includes(lowerQuery),\n  );\n}\n"],
  "mappings": "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",
  "names": ["update_alias_exports", "__export", "confirmation", "updateAliasCommand", "__toCommonJS", "import_fs", "import_os", "import_path", "escapeRegExp", "str", "parseAliases", "homeDir", "configFiles", "aliases", "aliasPattern", "configFile", "filePath", "lines", "line", "match", "error", "a", "b", "aliasExists", "aliasName", "excludeFile", "excludeName", "homeDir", "configFiles", "configFile", "filePath", "content", "escapeRegExp", "error", "updateAlias", "oldName", "newName", "newCommand", "configFile", "homeDir", "filePath", "lines", "aliasPattern", "escapeRegExp", "updated", "newLines", "line", "escapedCommand", "error", "validateAliasName", "name", "validateAliasCommand", "command", "confirmation", "input", "currentName", "newName", "newCommand", "configFile", "currentAlias", "parseAliases", "alias", "updateAliasCommand", "nameValidation", "validateAliasName", "commandValidation", "validateAliasCommand", "aliasExists", "updateAlias", "aliasToUpdate", "error"]
}
