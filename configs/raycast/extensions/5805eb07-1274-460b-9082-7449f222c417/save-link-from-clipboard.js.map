{
  "version": 3,
  "sources": ["../src/save-link-from-clipboard.ts", "../src/utils.ts"],
  "sourcesContent": ["import { Clipboard, LaunchProps, showHUD } from \"@raycast/api\";\nimport { createAndCopyWeblocFile, extractDomainFromUrl, extractUrlFromText } from \"./utils\";\n\ninterface Arguments {\n  title?: string;\n}\n\nexport default async function main(props: LaunchProps<{ arguments: Arguments }>) {\n  const { title: customTitle } = props.arguments;\n\n  try {\n    // Read clipboard content\n    const clipboardContent = await Clipboard.read();\n\n    if (!clipboardContent.text) {\n      await showHUD(\"\u274C No text found in clipboard\");\n      return;\n    }\n\n    // Extract URL from clipboard text\n    const url = extractUrlFromText(clipboardContent.text);\n\n    if (!url) {\n      await showHUD(\"\u274C No valid URL found in clipboard\");\n      return;\n    }\n\n    // Create and copy webloc file using the abstracted function\n    await createAndCopyWeblocFile({\n      url,\n      customTitle,\n      fallbackTitle: extractDomainFromUrl(url),\n      titleSource: \"domain name\",\n    });\n  } catch (error) {\n    console.error(\"Error creating webloc file from clipboard:\", error);\n    await showHUD(`\u274C Failed to create webloc file: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n", "import { Clipboard, showHUD } from \"@raycast/api\";\nimport { mkdirSync, readdirSync, statSync, unlinkSync, writeFileSync } from \"fs\";\nimport { homedir } from \"os\";\nimport { join } from \"path\";\n\n// Configuration\nconst MAX_CACHE_FILES = 20; // Maximum number of webloc files to keep in cache\n\n// Types\nexport interface WeblocFileOptions {\n  url: string;\n  customTitle?: string;\n  fallbackTitle?: string;\n  titleSource?: string;\n}\n\n// Function to create webloc file content\nexport function createWeblocContent(url: string): string {\n  return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>URL</key>\n\t<string>${url}</string>\n</dict>\n</plist>`;\n}\n\n// Function to create a safe filename\nexport function createSafeFilename(title: string): string {\n  return title\n    .replace(/[^\\w\\s-]/g, \"\")\n    .replace(/\\s+/g, \" \")\n    .trim()\n    .slice(0, 50);\n}\n\n// Function to ensure cache directory exists\nexport function ensureCacheDirectory(): string {\n  const cacheDir = join(homedir(), \"Library\", \"Caches\", \"com.raycast.save-link\");\n  try {\n    mkdirSync(cacheDir, { recursive: true });\n  } catch {\n    // Directory might already exist, that's fine\n  }\n  return cacheDir;\n}\n\n// Function to validate if a string is a valid URL\nexport function isValidUrl(string: string): boolean {\n  try {\n    const url = new URL(string);\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\n  } catch {\n    return false;\n  }\n}\n\n// Function to extract URLs from text\nexport function extractUrlFromText(text: string): string | null {\n  // First try to validate the entire text as a URL\n  if (isValidUrl(text.trim())) {\n    return text.trim();\n  }\n\n  // If not, look for URLs in the text using regex\n  const urlRegex = /(https?:\\/\\/[^\\s]+)/gi;\n  const matches = text.match(urlRegex);\n\n  if (matches && matches.length > 0) {\n    // Return the first valid URL found\n    for (const match of matches) {\n      if (isValidUrl(match)) {\n        return match;\n      }\n    }\n  }\n\n  return null;\n}\n\n// Function to extract domain name from URL\nexport function extractDomainFromUrl(url: string): string {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.hostname.replace(\"www.\", \"\");\n  } catch {\n    return \"Link\";\n  }\n}\n\n// Function to clean up old cache files, keeping only the most recent ones\nexport function cleanupOldCacheFiles(cacheDir: string, maxFiles: number = 20): void {\n  try {\n    const files = readdirSync(cacheDir)\n      .filter((file) => file.endsWith(\".webloc\"))\n      .map((file) => {\n        const filePath = join(cacheDir, file);\n        return {\n          name: file,\n          path: filePath,\n          mtime: statSync(filePath).mtime,\n        };\n      })\n      .sort((a, b) => b.mtime.getTime() - a.mtime.getTime()); // Sort by modification time, newest first\n\n    // If we have more files than the limit, remove the oldest ones\n    if (files.length > maxFiles) {\n      const filesToRemove = files.slice(maxFiles);\n      for (const file of filesToRemove) {\n        try {\n          unlinkSync(file.path);\n        } catch (error) {\n          // Ignore errors when deleting files (file might be in use, etc.)\n          console.warn(`Failed to delete cache file ${file.name}:`, error);\n        }\n      }\n    }\n  } catch (error) {\n    // Ignore errors during cleanup - it's not critical\n    console.warn(\"Failed to cleanup cache files:\", error);\n  }\n}\n\n// Main function to create and copy webloc file\nexport async function createAndCopyWeblocFile(options: WeblocFileOptions): Promise<void> {\n  const { url, customTitle, fallbackTitle = \"Link\", titleSource = \"default\" } = options;\n\n  // Create cache directory\n  const cacheDir = ensureCacheDirectory();\n\n  // Determine the title to use\n  const titleToUse = customTitle || fallbackTitle;\n  const safeTitle = createSafeFilename(titleToUse);\n  const filename = `${safeTitle || \"Link\"}.webloc`;\n  const filePath = join(cacheDir, filename);\n\n  // Create the webloc file content\n  const weblocContent = createWeblocContent(url);\n\n  // Write the webloc file\n  try {\n    writeFileSync(filePath, weblocContent, \"utf8\");\n  } catch (error) {\n    throw new Error(`Failed to create webloc file: ${error}`);\n  }\n\n  // Clean up old cache files to prevent accumulation\n  cleanupOldCacheFiles(cacheDir, MAX_CACHE_FILES);\n\n  // Copy the file to clipboard\n  const fileContent: Clipboard.Content = { file: filePath };\n  await Clipboard.copy(fileContent);\n\n  // Show success message\n  const source = customTitle ? \"custom title\" : titleSource;\n  await showHUD(`\uD83D\uDCCB Copied \"${safeTitle}.webloc\" to clipboard (using ${source})`);\n}\n"],
  "mappings": "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",
  "names": ["save_link_from_clipboard_exports", "__export", "main", "__toCommonJS", "import_api", "import_api", "import_fs", "import_os", "import_path", "MAX_CACHE_FILES", "createWeblocContent", "url", "createSafeFilename", "title", "ensureCacheDirectory", "cacheDir", "isValidUrl", "string", "extractUrlFromText", "text", "urlRegex", "matches", "match", "extractDomainFromUrl", "cleanupOldCacheFiles", "maxFiles", "files", "file", "filePath", "a", "b", "filesToRemove", "error", "createAndCopyWeblocFile", "options", "customTitle", "fallbackTitle", "titleSource", "safeTitle", "filename", "weblocContent", "fileContent", "main", "props", "customTitle", "clipboardContent", "url", "extractUrlFromText", "createAndCopyWeblocFile", "extractDomainFromUrl", "error"]
}
