{
  "version": 3,
  "sources": ["../src/open-save-folder.ts", "../src/utils.ts"],
  "sourcesContent": ["import { open, showHUD } from \"@raycast/api\";\nimport { ensureCacheDirectory } from \"./utils\";\n\nexport default async function main() {\n  try {\n    // Get the cache directory path\n    const cacheDir = ensureCacheDirectory();\n\n    // Open the directory in Finder\n    await open(cacheDir);\n\n    // Show success message\n    await showHUD(\"\uD83D\uDCC2 Opened cached links directory\");\n  } catch (error) {\n    console.error(\"Error opening save folder:\", error);\n    await showHUD(`\u274C Failed to open save folder: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n", "import { Clipboard, showHUD } from \"@raycast/api\";\nimport { mkdirSync, readdirSync, statSync, unlinkSync, writeFileSync } from \"fs\";\nimport { homedir } from \"os\";\nimport { join } from \"path\";\n\n// Configuration\nconst MAX_CACHE_FILES = 20; // Maximum number of webloc files to keep in cache\n\n// Types\nexport interface WeblocFileOptions {\n  url: string;\n  customTitle?: string;\n  fallbackTitle?: string;\n  titleSource?: string;\n}\n\n// Function to create webloc file content\nexport function createWeblocContent(url: string): string {\n  return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>URL</key>\n\t<string>${url}</string>\n</dict>\n</plist>`;\n}\n\n// Function to create a safe filename\nexport function createSafeFilename(title: string): string {\n  return title\n    .replace(/[^\\w\\s-]/g, \"\")\n    .replace(/\\s+/g, \" \")\n    .trim()\n    .slice(0, 50);\n}\n\n// Function to ensure cache directory exists\nexport function ensureCacheDirectory(): string {\n  const cacheDir = join(homedir(), \"Library\", \"Caches\", \"com.raycast.save-link\");\n  try {\n    mkdirSync(cacheDir, { recursive: true });\n  } catch {\n    // Directory might already exist, that's fine\n  }\n  return cacheDir;\n}\n\n// Function to validate if a string is a valid URL\nexport function isValidUrl(string: string): boolean {\n  try {\n    const url = new URL(string);\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\n  } catch {\n    return false;\n  }\n}\n\n// Function to extract URLs from text\nexport function extractUrlFromText(text: string): string | null {\n  // First try to validate the entire text as a URL\n  if (isValidUrl(text.trim())) {\n    return text.trim();\n  }\n\n  // If not, look for URLs in the text using regex\n  const urlRegex = /(https?:\\/\\/[^\\s]+)/gi;\n  const matches = text.match(urlRegex);\n\n  if (matches && matches.length > 0) {\n    // Return the first valid URL found\n    for (const match of matches) {\n      if (isValidUrl(match)) {\n        return match;\n      }\n    }\n  }\n\n  return null;\n}\n\n// Function to extract domain name from URL\nexport function extractDomainFromUrl(url: string): string {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.hostname.replace(\"www.\", \"\");\n  } catch {\n    return \"Link\";\n  }\n}\n\n// Function to clean up old cache files, keeping only the most recent ones\nexport function cleanupOldCacheFiles(cacheDir: string, maxFiles: number = 20): void {\n  try {\n    const files = readdirSync(cacheDir)\n      .filter((file) => file.endsWith(\".webloc\"))\n      .map((file) => {\n        const filePath = join(cacheDir, file);\n        return {\n          name: file,\n          path: filePath,\n          mtime: statSync(filePath).mtime,\n        };\n      })\n      .sort((a, b) => b.mtime.getTime() - a.mtime.getTime()); // Sort by modification time, newest first\n\n    // If we have more files than the limit, remove the oldest ones\n    if (files.length > maxFiles) {\n      const filesToRemove = files.slice(maxFiles);\n      for (const file of filesToRemove) {\n        try {\n          unlinkSync(file.path);\n        } catch (error) {\n          // Ignore errors when deleting files (file might be in use, etc.)\n          console.warn(`Failed to delete cache file ${file.name}:`, error);\n        }\n      }\n    }\n  } catch (error) {\n    // Ignore errors during cleanup - it's not critical\n    console.warn(\"Failed to cleanup cache files:\", error);\n  }\n}\n\n// Main function to create and copy webloc file\nexport async function createAndCopyWeblocFile(options: WeblocFileOptions): Promise<void> {\n  const { url, customTitle, fallbackTitle = \"Link\", titleSource = \"default\" } = options;\n\n  // Create cache directory\n  const cacheDir = ensureCacheDirectory();\n\n  // Determine the title to use\n  const titleToUse = customTitle || fallbackTitle;\n  const safeTitle = createSafeFilename(titleToUse);\n  const filename = `${safeTitle || \"Link\"}.webloc`;\n  const filePath = join(cacheDir, filename);\n\n  // Create the webloc file content\n  const weblocContent = createWeblocContent(url);\n\n  // Write the webloc file\n  try {\n    writeFileSync(filePath, weblocContent, \"utf8\");\n  } catch (error) {\n    throw new Error(`Failed to create webloc file: ${error}`);\n  }\n\n  // Clean up old cache files to prevent accumulation\n  cleanupOldCacheFiles(cacheDir, MAX_CACHE_FILES);\n\n  // Copy the file to clipboard\n  const fileContent: Clipboard.Content = { file: filePath };\n  await Clipboard.copy(fileContent);\n\n  // Show success message\n  const source = customTitle ? \"custom title\" : titleSource;\n  await showHUD(`\uD83D\uDCCB Copied \"${safeTitle}.webloc\" to clipboard (using ${source})`);\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAA8B,wBCA9B,IAAAC,EAAmC,wBACnCC,EAA4E,cAC5EC,EAAwB,cACxBC,EAAqB,gBAmCd,SAASC,GAA+B,CAC7C,IAAMC,KAAW,WAAK,WAAQ,EAAG,UAAW,SAAU,uBAAuB,EAC7E,GAAI,IACF,aAAUA,EAAU,CAAE,UAAW,EAAK,CAAC,CACzC,MAAQ,CAER,CACA,OAAOA,CACT,CD3CA,eAAOC,GAA8B,CACnC,GAAI,CAEF,IAAMC,EAAWC,EAAqB,EAGtC,QAAM,QAAKD,CAAQ,EAGnB,QAAM,WAAQ,yCAAkC,CAClD,OAASE,EAAO,CACd,QAAQ,MAAM,6BAA8BA,CAAK,EACjD,QAAM,WAAQ,sCAAiCA,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAAC,EAAE,CACzG,CACF",
  "names": ["open_save_folder_exports", "__export", "main", "__toCommonJS", "import_api", "import_api", "import_fs", "import_os", "import_path", "ensureCacheDirectory", "cacheDir", "main", "cacheDir", "ensureCacheDirectory", "error"]
}
