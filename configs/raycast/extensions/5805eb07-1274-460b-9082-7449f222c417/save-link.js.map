{
  "version": 3,
  "sources": ["../src/save-link.ts", "../src/utils.ts"],
  "sourcesContent": ["import { BrowserExtension, LaunchProps, showHUD } from \"@raycast/api\";\nimport { createAndCopyWeblocFile } from \"./utils\";\n\ninterface Arguments {\n  title?: string;\n}\n\nexport default async function main(props: LaunchProps<{ arguments: Arguments }>) {\n  const { title: customTitle } = props.arguments;\n\n  try {\n    // Get the active browser tab\n    const tabs = await BrowserExtension.getTabs();\n    const activeTab = tabs.find((tab) => tab.active);\n\n    if (!activeTab || !activeTab.url) {\n      await showHUD(\"\u274C No active browser tab found\");\n      return;\n    }\n\n    // Create and copy webloc file using the abstracted function\n    await createAndCopyWeblocFile({\n      url: activeTab.url,\n      customTitle,\n      fallbackTitle: activeTab.title || \"Untitled\",\n      titleSource: \"page title\",\n    });\n  } catch (error) {\n    console.error(\"Error creating webloc file:\", error);\n    await showHUD(`\u274C Failed to create webloc file: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n", "import { Clipboard, showHUD } from \"@raycast/api\";\nimport { mkdirSync, readdirSync, statSync, unlinkSync, writeFileSync } from \"fs\";\nimport { homedir } from \"os\";\nimport { join } from \"path\";\n\n// Configuration\nconst MAX_CACHE_FILES = 20; // Maximum number of webloc files to keep in cache\n\n// Types\nexport interface WeblocFileOptions {\n  url: string;\n  customTitle?: string;\n  fallbackTitle?: string;\n  titleSource?: string;\n}\n\n// Function to create webloc file content\nexport function createWeblocContent(url: string): string {\n  return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>URL</key>\n\t<string>${url}</string>\n</dict>\n</plist>`;\n}\n\n// Function to create a safe filename\nexport function createSafeFilename(title: string): string {\n  return title\n    .replace(/[^\\w\\s-]/g, \"\")\n    .replace(/\\s+/g, \" \")\n    .trim()\n    .slice(0, 50);\n}\n\n// Function to ensure cache directory exists\nexport function ensureCacheDirectory(): string {\n  const cacheDir = join(homedir(), \"Library\", \"Caches\", \"com.raycast.save-link\");\n  try {\n    mkdirSync(cacheDir, { recursive: true });\n  } catch {\n    // Directory might already exist, that's fine\n  }\n  return cacheDir;\n}\n\n// Function to validate if a string is a valid URL\nexport function isValidUrl(string: string): boolean {\n  try {\n    const url = new URL(string);\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\n  } catch {\n    return false;\n  }\n}\n\n// Function to extract URLs from text\nexport function extractUrlFromText(text: string): string | null {\n  // First try to validate the entire text as a URL\n  if (isValidUrl(text.trim())) {\n    return text.trim();\n  }\n\n  // If not, look for URLs in the text using regex\n  const urlRegex = /(https?:\\/\\/[^\\s]+)/gi;\n  const matches = text.match(urlRegex);\n\n  if (matches && matches.length > 0) {\n    // Return the first valid URL found\n    for (const match of matches) {\n      if (isValidUrl(match)) {\n        return match;\n      }\n    }\n  }\n\n  return null;\n}\n\n// Function to extract domain name from URL\nexport function extractDomainFromUrl(url: string): string {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.hostname.replace(\"www.\", \"\");\n  } catch {\n    return \"Link\";\n  }\n}\n\n// Function to clean up old cache files, keeping only the most recent ones\nexport function cleanupOldCacheFiles(cacheDir: string, maxFiles: number = 20): void {\n  try {\n    const files = readdirSync(cacheDir)\n      .filter((file) => file.endsWith(\".webloc\"))\n      .map((file) => {\n        const filePath = join(cacheDir, file);\n        return {\n          name: file,\n          path: filePath,\n          mtime: statSync(filePath).mtime,\n        };\n      })\n      .sort((a, b) => b.mtime.getTime() - a.mtime.getTime()); // Sort by modification time, newest first\n\n    // If we have more files than the limit, remove the oldest ones\n    if (files.length > maxFiles) {\n      const filesToRemove = files.slice(maxFiles);\n      for (const file of filesToRemove) {\n        try {\n          unlinkSync(file.path);\n        } catch (error) {\n          // Ignore errors when deleting files (file might be in use, etc.)\n          console.warn(`Failed to delete cache file ${file.name}:`, error);\n        }\n      }\n    }\n  } catch (error) {\n    // Ignore errors during cleanup - it's not critical\n    console.warn(\"Failed to cleanup cache files:\", error);\n  }\n}\n\n// Main function to create and copy webloc file\nexport async function createAndCopyWeblocFile(options: WeblocFileOptions): Promise<void> {\n  const { url, customTitle, fallbackTitle = \"Link\", titleSource = \"default\" } = options;\n\n  // Create cache directory\n  const cacheDir = ensureCacheDirectory();\n\n  // Determine the title to use\n  const titleToUse = customTitle || fallbackTitle;\n  const safeTitle = createSafeFilename(titleToUse);\n  const filename = `${safeTitle || \"Link\"}.webloc`;\n  const filePath = join(cacheDir, filename);\n\n  // Create the webloc file content\n  const weblocContent = createWeblocContent(url);\n\n  // Write the webloc file\n  try {\n    writeFileSync(filePath, weblocContent, \"utf8\");\n  } catch (error) {\n    throw new Error(`Failed to create webloc file: ${error}`);\n  }\n\n  // Clean up old cache files to prevent accumulation\n  cleanupOldCacheFiles(cacheDir, MAX_CACHE_FILES);\n\n  // Copy the file to clipboard\n  const fileContent: Clipboard.Content = { file: filePath };\n  await Clipboard.copy(fileContent);\n\n  // Show success message\n  const source = customTitle ? \"custom title\" : titleSource;\n  await showHUD(`\uD83D\uDCCB Copied \"${safeTitle}.webloc\" to clipboard (using ${source})`);\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAuD,wBCAvD,IAAAC,EAAmC,wBACnCC,EAA4E,cAC5EC,EAAwB,cACxBC,EAAqB,gBAGfC,EAAkB,GAWjB,SAASC,EAAoBC,EAAqB,CACvD,MAAO;AAAA;AAAA;AAAA;AAAA;AAAA,WAKEA,CAAG;AAAA;AAAA,SAGd,CAGO,SAASC,EAAmBC,EAAuB,CACxD,OAAOA,EACJ,QAAQ,YAAa,EAAE,EACvB,QAAQ,OAAQ,GAAG,EACnB,KAAK,EACL,MAAM,EAAG,EAAE,CAChB,CAGO,SAASC,GAA+B,CAC7C,IAAMC,KAAW,WAAK,WAAQ,EAAG,UAAW,SAAU,uBAAuB,EAC7E,GAAI,IACF,aAAUA,EAAU,CAAE,UAAW,EAAK,CAAC,CACzC,MAAQ,CAER,CACA,OAAOA,CACT,CA8CO,SAASC,EAAqBC,EAAkBC,EAAmB,GAAU,CAClF,GAAI,CACF,IAAMC,KAAQ,eAAYF,CAAQ,EAC/B,OAAQG,GAASA,EAAK,SAAS,SAAS,CAAC,EACzC,IAAKA,GAAS,CACb,IAAMC,KAAW,QAAKJ,EAAUG,CAAI,EACpC,MAAO,CACL,KAAMA,EACN,KAAMC,EACN,SAAO,YAASA,CAAQ,EAAE,KAC5B,CACF,CAAC,EACA,KAAK,CAACC,EAAGC,IAAMA,EAAE,MAAM,QAAQ,EAAID,EAAE,MAAM,QAAQ,CAAC,EAGvD,GAAIH,EAAM,OAASD,EAAU,CAC3B,IAAMM,EAAgBL,EAAM,MAAMD,CAAQ,EAC1C,QAAWE,KAAQI,EACjB,GAAI,IACF,cAAWJ,EAAK,IAAI,CACtB,OAASK,EAAO,CAEd,QAAQ,KAAK,+BAA+BL,EAAK,IAAI,IAAKK,CAAK,CACjE,CAEJ,CACF,OAASA,EAAO,CAEd,QAAQ,KAAK,iCAAkCA,CAAK,CACtD,CACF,CAGA,eAAsBC,EAAwBC,EAA2C,CACvF,GAAM,CAAE,IAAAC,EAAK,YAAAC,EAAa,cAAAC,EAAgB,OAAQ,YAAAC,EAAc,SAAU,EAAIJ,EAGxEV,EAAWe,EAAqB,EAIhCC,EAAYC,EADCL,GAAeC,CACa,EACzCK,EAAW,GAAGF,GAAa,MAAM,UACjCZ,KAAW,QAAKJ,EAAUkB,CAAQ,EAGlCC,EAAgBC,EAAoBT,CAAG,EAG7C,GAAI,IACF,iBAAcP,EAAUe,EAAe,MAAM,CAC/C,OAASX,EAAO,CACd,MAAM,IAAI,MAAM,iCAAiCA,CAAK,EAAE,CAC1D,CAGAT,EAAqBC,EAAUqB,CAAe,EAG9C,IAAMC,EAAiC,CAAE,KAAMlB,CAAS,EACxD,MAAM,YAAU,KAAKkB,CAAW,EAIhC,QAAM,WAAQ,qBAAcN,CAAS,gCADtBJ,EAAc,eAAiBE,CAC6B,GAAG,CAChF,CDtJA,eAAOS,EAA4BC,EAA8C,CAC/E,GAAM,CAAE,MAAOC,CAAY,EAAID,EAAM,UAErC,GAAI,CAGF,IAAME,GADO,MAAM,mBAAiB,QAAQ,GACrB,KAAMC,GAAQA,EAAI,MAAM,EAE/C,GAAI,CAACD,GAAa,CAACA,EAAU,IAAK,CAChC,QAAM,WAAQ,oCAA+B,EAC7C,MACF,CAGA,MAAME,EAAwB,CAC5B,IAAKF,EAAU,IACf,YAAAD,EACA,cAAeC,EAAU,OAAS,WAClC,YAAa,YACf,CAAC,CACH,OAASG,EAAO,CACd,QAAQ,MAAM,8BAA+BA,CAAK,EAClD,QAAM,WAAQ,wCAAmCA,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAAC,EAAE,CAC3G,CACF",
  "names": ["save_link_exports", "__export", "main", "__toCommonJS", "import_api", "import_api", "import_fs", "import_os", "import_path", "MAX_CACHE_FILES", "createWeblocContent", "url", "createSafeFilename", "title", "ensureCacheDirectory", "cacheDir", "cleanupOldCacheFiles", "cacheDir", "maxFiles", "files", "file", "filePath", "a", "b", "filesToRemove", "error", "createAndCopyWeblocFile", "options", "url", "customTitle", "fallbackTitle", "titleSource", "ensureCacheDirectory", "safeTitle", "createSafeFilename", "filename", "weblocContent", "createWeblocContent", "MAX_CACHE_FILES", "fileContent", "main", "props", "customTitle", "activeTab", "tab", "createAndCopyWeblocFile", "error"]
}
