{
  "version": 3,
  "sources": ["../src/write-pr-description.tsx", "../src/_components/write-pr-description/WritePRDescription.tsx", "../src/_components/write-pr-description/usePRDescription.ts", "../src/_lib/ai-utils.ts", "../src/_lib/git/queue.ts", "../src/_lib/error-utils.ts", "../src/_constants/errors.ts", "../src/_constants/prompts.ts", "../src/_lib/git/commands.ts", "../src/_lib/git/repo.ts", "../src/_components/write-pr-description/PRDescriptionActions.tsx"],
  "sourcesContent": ["import { LaunchProps } from \"@raycast/api\";\nimport { WritePRDescription } from \"./_components/write-pr-description/WritePRDescription\";\n\ninterface LaunchContext {\n  baseBranch: string;\n}\n\nexport default function Command(props: LaunchProps<{ launchContext: LaunchContext }>) {\n  return <WritePRDescription baseBranch={props.launchContext?.baseBranch} />;\n}\n", "import { Detail } from \"@raycast/api\";\nimport { usePRDescription } from \"./usePRDescription\";\nimport { PRDescriptionActions } from \"./PRDescriptionActions\";\nimport { handleError } from \"../../_lib/error-utils\";\nimport { useEffect, useState } from \"react\";\nimport { getRepoDisplayName } from \"../../_lib/git\";\n\ninterface WritePRDescriptionProps {\n  baseBranch?: string;\n}\n\nexport function WritePRDescription({ baseBranch = \"main\" }: WritePRDescriptionProps) {\n  const { description, error, branchName, isLoading } = usePRDescription(baseBranch);\n  const [repoPath, setRepoPath] = useState<string>(\"\");\n\n  useEffect(() => {\n    fetchRepoPath();\n    if (error) {\n      handleError(error);\n    }\n  }, [error]);\n\n  async function fetchRepoPath() {\n    const displayName = await getRepoDisplayName();\n    setRepoPath(displayName);\n  }\n\n  return (\n    <Detail\n      markdown={description || \"Generating PR description...\"}\n      metadata={\n        branchName && description ? (\n          <Detail.Metadata>\n            <Detail.Metadata.Label title=\"Repository\" text={repoPath} />\n            <Detail.Metadata.Label title=\"Current Branch\" text={branchName} />\n            {baseBranch && <Detail.Metadata.Label title=\"Base Branch\" text={baseBranch} />}\n          </Detail.Metadata>\n        ) : null\n      }\n      actions={description ? <PRDescriptionActions description={description} branchName={branchName} /> : null}\n      isLoading={isLoading}\n    />\n  );\n}\n", "import { useState, useEffect } from \"react\";\nimport { getPreferenceValues } from \"@raycast/api\";\nimport { fetchAIContent } from \"../../_lib/ai-utils\";\nimport { ERROR_MESSAGES, PR_DESCRIPTION_PROMPT } from \"../../_constants\";\n\nexport function usePRDescription(userBaseBranch?: string) {\n  const [description, setDescription] = useState<string | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [branchName, setBranchName] = useState<string | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    fetchPRDescription();\n  }, []);\n\n  async function fetchPRDescription() {\n    try {\n      const preferences = await getPreferenceValues<{ [key: string]: string }>();\n      const defaultBaseBranch = preferences[\"default-base-branch\"];\n      const baseBranch = userBaseBranch || defaultBaseBranch;\n\n      const { aiContent, branchName } = await fetchAIContent({\n        diffType: \"baseBranch\",\n        aiModelName: \"pr-description-ai-model\",\n        aiPrompt: PR_DESCRIPTION_PROMPT,\n        baseBranch,\n      });\n\n      const cleanedDescription = cleanDescription(aiContent);\n      setDescription(cleanedDescription);\n      setBranchName(branchName);\n    } catch (error) {\n      const errorMessage = (error as Error).message || ERROR_MESSAGES.FETCH_PR_DESCRIPTION;\n      setError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  return { description, error, branchName, isLoading };\n}\n\nfunction cleanDescription(aiContent: string): string {\n  const cleanedMessage = aiContent.replace(/^```|```$/g, \"\").trim();\n  const lines = cleanedMessage.split(\"\\n\").map((line) => line.trim());\n\n  // Remove empty lines and filter out any remaining empty strings\n  const nonEmptyLines = lines.filter(Boolean);\n\n  // Remove \"markdown\" or \"diff\" if it's the only content on the first line\n  if (nonEmptyLines.length > 0) {\n    if (/^(markdown|diff)$/i.test(nonEmptyLines[0])) {\n      nonEmptyLines.shift();\n    } else {\n      nonEmptyLines[0] = nonEmptyLines[0].replace(/^(markdown|diff):\\s*/i, \"\");\n    }\n  }\n\n  return nonEmptyLines.join(\"\\n\").trim();\n}\n", "import { AI, getPreferenceValues } from \"@raycast/api\";\nimport { getRepoPath, getStagedGitDiff, getDiffComparedToBranch, getCurrentBranchName } from \"./git\";\nimport { ERROR_MESSAGES } from \"../_constants\";\nimport { handleFetchAIContentError } from \"./error-utils\";\n\nconst CREATIVITY_LEVEL = \"medium\";\n\ninterface FetchAIContentOptions {\n  diffType: \"staged\" | \"baseBranch\";\n  aiModelName: string;\n  aiPrompt: string;\n  baseBranch?: string;\n}\n\ninterface GitDiffOptions {\n  diffType: \"staged\" | \"baseBranch\";\n  repoPath: string;\n  baseBranch?: string;\n}\n\nasync function getAIModel(preferenceKey: string): Promise<AI.Model> {\n  const preferences = await getPreferenceValues<{ [key: string]: string }>();\n  const aiModelKey = preferences[preferenceKey];\n  if (!aiModelKey) {\n    throw new Error(\"No AI model provided\");\n  }\n  const aiModel = AI.Model[aiModelKey as keyof typeof AI.Model];\n  if (!aiModel) {\n    throw new Error(`Invalid AI model: ${aiModelKey}`);\n  }\n  return aiModel;\n}\n\nasync function getGitDiff({ diffType, repoPath, baseBranch }: GitDiffOptions): Promise<string> {\n  if (diffType === \"staged\") {\n    return await getStagedGitDiff(repoPath);\n  } else if (diffType === \"baseBranch\" && baseBranch) {\n    return await getDiffComparedToBranch(repoPath, baseBranch);\n  } else {\n    throw new Error(\"Invalid diffType or missing baseBranch\");\n  }\n}\n\nexport async function fetchAIContent(options: FetchAIContentOptions) {\n  const { diffType, aiModelName, aiPrompt, baseBranch } = options;\n  try {\n    const repoPath = await getRepoPath();\n    const gitDiff = await getGitDiff({ diffType, repoPath, baseBranch });\n\n    if (!gitDiff) {\n      throw new Error(ERROR_MESSAGES.GIT_DIFF_EMPTY);\n    }\n\n    const aiModel = await getAIModel(aiModelName);\n    const aiContent = await AI.ask(`${aiPrompt}${gitDiff}`, { model: aiModel, creativity: CREATIVITY_LEVEL });\n    const branchName = await getCurrentBranchName(repoPath);\n    return { aiContent, branchName };\n  } catch (error) {\n    handleFetchAIContentError(error as Error, diffType);\n  }\n}\n", "import { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport { handleGitError } from \"../error-utils\";\n\nconst execAsync = promisify(exec);\n\nconst gitQueue: (() => Promise<void>)[] = [];\nlet isProcessing = false;\n\nasync function processGitQueue() {\n  if (isProcessing) return;\n  isProcessing = true;\n\n  while (gitQueue.length > 0) {\n    const task = gitQueue.shift();\n    if (task) {\n      try {\n        await task();\n      } catch (error) {\n        console.error(\"Error in Git operation:\", error);\n      }\n    }\n  }\n\n  isProcessing = false;\n}\n\nexport function queueGitOperation<T>(operation: () => Promise<T>): Promise<T> {\n  return new Promise((resolve, reject) => {\n    gitQueue.push(async () => {\n      try {\n        const result = await operation();\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    });\n    processGitQueue();\n  });\n}\n\nexport async function runGitCommand(command: string, cwd: string): Promise<string> {\n  return queueGitOperation(async () => {\n    try {\n      const { stdout } = await execAsync(command, { cwd });\n      return stdout.trim();\n    } catch (error) {\n      throw handleGitError(error as Error);\n    }\n  });\n}\n", "import { Toast, popToRoot, showToast } from \"@raycast/api\";\nimport { ERROR_MESSAGES } from \"../_constants\";\n\nexport async function handleError(errorMessage: string) {\n  await popToRoot();\n  await showToast({\n    style: Toast.Style.Failure,\n    title: \"Error\",\n    message: errorMessage,\n  });\n}\n\nexport function handleGitError(error: Error): Error {\n  const errorMessage = error.message.toLowerCase();\n\n  if (errorMessage.includes(\"would be overwritten by checkout\")) {\n    return new Error(ERROR_MESSAGES.CHECKOUT_BRANCH);\n  }\n\n  if (errorMessage.includes(\"not a git repository\")) {\n    return new Error(ERROR_MESSAGES.INVALID_REPO);\n  }\n\n  if (errorMessage.includes(\"already exists\")) {\n    return new Error(ERROR_MESSAGES.BRANCH_EXISTS);\n  }\n\n  // If no specific error is matched, return the original error\n  return error;\n}\n\nexport function handleFetchAIContentError(error: Error, diffType: \"staged\" | \"baseBranch\"): never {\n  const errorMessage = error.message;\n  const knownErrors = {\n    [ERROR_MESSAGES.GIT_DIFF_EMPTY]: ERROR_MESSAGES.GIT_DIFF_EMPTY,\n    [ERROR_MESSAGES.REPO_PATH_MISSING]: ERROR_MESSAGES.REPO_PATH_MISSING,\n    [ERROR_MESSAGES.INVALID_REPO]: ERROR_MESSAGES.INVALID_REPO,\n    \"No AI model provided\": ERROR_MESSAGES.AI_MODEL_MISSING,\n    \"Invalid AI model\": ERROR_MESSAGES.AI_MODEL_INVALID,\n  };\n\n  const knownError = Object.entries(knownErrors).find(([key]) => errorMessage.includes(key));\n  if (knownError) {\n    throw new Error(knownError[1]);\n  }\n\n  throw new Error(diffType === \"staged\" ? ERROR_MESSAGES.FETCH_COMMIT_MESSAGE : ERROR_MESSAGES.FETCH_PR_DESCRIPTION);\n}\n", "export const ERROR_MESSAGES = {\n  FETCH_COMMIT_MESSAGE: \"Failed to generate commit message\",\n  COMMIT_CHANGES: \"Failed to commit changes\",\n  FETCH_PR_DESCRIPTION: \"Failed to generate PR description\",\n  REPO_PATH_MISSING: \"No repository path provided\",\n  INVALID_REPO: \"Invalid Git repository\",\n  BRANCH_EXISTS: \"Branch already exists\",\n  GIT_DIFF_EMPTY: \"No changes to commit\",\n  CHECKOUT_BRANCH: \"Failed to checkout branch\",\n  DELETE_BRANCH: \"Failed to delete branch\",\n  CLEANUP_BRANCHES: \"Failed to clean up branches\",\n  GET_CURRENT_BRANCH: \"Failed to get current branch\",\n  GET_BRANCHES: \"Failed to get branches\",\n  ACTIVE_BRANCH_DELETE: \"Cannot delete active branch\",\n  AI_MODEL_MISSING: \"No AI model provided\",\n  AI_MODEL_INVALID: \"Invalid AI model\",\n};\n", "export const PR_DESCRIPTION_PROMPT = `You are a world class software engineer. I need your help writing a PR description, using this diff:\n{diff}\n\nUse this markdown template:\n\\`\\`\\`\n## Summary\n\nProvide a concise summary of the implemented changes, including new features, bug fixes, and any updates to components or properties.\n\n## Changes\n\nList the main changes made in this PR.\n\\`\\`\\`\n\nWrite a concise and clear PR description using the markdown template. Don't add any extra text to the response. Only respond in markdown.`;\n\nexport const COMMIT_MESSAGE_PROMPT = `Please write a commit message given the provided diff. The commit message should be a short description in the present tense and imperative form, as if giving a command. For example, \"Add Button component\" or \"Fix issue with login form validation\". IMPORTANT: The entire generated message should be 50 characters or less. Diff: `;\n", "import { ERROR_MESSAGES } from \"../../_constants\";\nimport { runGitCommand } from \"./queue\";\n\nexport async function getStagedGitDiff(repoPath: string): Promise<string> {\n  try {\n    let gitDiff = await runGitCommand(`git diff --staged`, repoPath);\n    if (!gitDiff) {\n      await runGitCommand(`git add .`, repoPath);\n      gitDiff = await runGitCommand(`git diff --staged`, repoPath);\n    }\n    return gitDiff;\n  } catch (error) {\n    throw new Error(ERROR_MESSAGES.GIT_DIFF_EMPTY);\n  }\n}\n\nexport async function commitChanges(repoPath: string, commitMessage: string): Promise<void> {\n  await runGitCommand(`git commit -m \"${commitMessage}\"`, repoPath);\n}\n\nexport async function getCurrentBranchName(repoPath: string): Promise<string> {\n  return runGitCommand(`git rev-parse --abbrev-ref HEAD`, repoPath);\n}\n\nexport async function getDiffComparedToBranch(repoPath: string, baseBranch: string): Promise<string> {\n  return runGitCommand(`git diff ${baseBranch}`, repoPath);\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { ERROR_MESSAGES } from \"../../_constants\";\nimport { runGitCommand } from \"./queue\";\nimport path from \"path\";\n\nasync function isValidRepo(repoPath: string): Promise<boolean> {\n  try {\n    const result = await runGitCommand(`git rev-parse --is-inside-work-tree`, repoPath);\n    return result === \"true\";\n  } catch {\n    return false;\n  }\n}\n\nexport async function getRepoPath(): Promise<string> {\n  const preferences = await getPreferenceValues<{ \"repo-path\": string }>();\n  const repoPath = preferences[\"repo-path\"];\n  if (!repoPath) {\n    throw new Error(ERROR_MESSAGES.REPO_PATH_MISSING);\n  }\n  if (!(await isValidRepo(repoPath))) {\n    throw new Error(ERROR_MESSAGES.INVALID_REPO);\n  }\n  return repoPath;\n}\n\nexport async function getRepoDisplayName(): Promise<string> {\n  const repoPath = await getRepoPath();\n  return path.basename(repoPath);\n}\n", "import { Action, ActionPanel } from \"@raycast/api\";\n\ninterface PRDescriptionActionsProps {\n  description: string;\n  branchName: string | null;\n}\n\nexport function PRDescriptionActions({ description, branchName }: PRDescriptionActionsProps) {\n  return (\n    <ActionPanel title={branchName ? `Branch: ${branchName}` : \"Branch name\"}>\n      <Action.Paste title=\"Paste PR Description\" content={description} />\n      <Action.CopyToClipboard\n        title=\"Copy PR Description\"\n        content={description}\n        shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"c\" }}\n      />\n    </ActionPanel>\n  );\n}\n"],
  "mappings": "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",
  "names": ["write_pr_description_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "import_api", "import_api", "import_child_process", "import_util", "import_api", "ERROR_MESSAGES", "PR_DESCRIPTION_PROMPT", "handleError", "errorMessage", "handleGitError", "error", "ERROR_MESSAGES", "handleFetchAIContentError", "diffType", "knownErrors", "knownError", "key", "execAsync", "gitQueue", "isProcessing", "processGitQueue", "task", "error", "queueGitOperation", "operation", "resolve", "reject", "result", "runGitCommand", "command", "cwd", "stdout", "handleGitError", "getStagedGitDiff", "repoPath", "gitDiff", "runGitCommand", "ERROR_MESSAGES", "getCurrentBranchName", "repoPath", "runGitCommand", "getDiffComparedToBranch", "baseBranch", "import_api", "import_path", "isValidRepo", "repoPath", "runGitCommand", "getRepoPath", "ERROR_MESSAGES", "getRepoDisplayName", "path", "CREATIVITY_LEVEL", "getAIModel", "preferenceKey", "aiModelKey", "aiModel", "getGitDiff", "diffType", "repoPath", "baseBranch", "getStagedGitDiff", "getDiffComparedToBranch", "fetchAIContent", "options", "aiModelName", "aiPrompt", "getRepoPath", "gitDiff", "ERROR_MESSAGES", "aiContent", "branchName", "getCurrentBranchName", "error", "handleFetchAIContentError", "usePRDescription", "userBaseBranch", "description", "setDescription", "error", "setError", "branchName", "setBranchName", "isLoading", "setIsLoading", "fetchPRDescription", "defaultBaseBranch", "baseBranch", "aiContent", "fetchAIContent", "PR_DESCRIPTION_PROMPT", "cleanedDescription", "cleanDescription", "errorMessage", "ERROR_MESSAGES", "nonEmptyLines", "line", "import_api", "import_jsx_runtime", "PRDescriptionActions", "description", "branchName", "import_react", "import_jsx_runtime", "WritePRDescription", "baseBranch", "description", "error", "branchName", "isLoading", "usePRDescription", "repoPath", "setRepoPath", "fetchRepoPath", "handleError", "displayName", "getRepoDisplayName", "PRDescriptionActions", "import_jsx_runtime", "Command", "props", "WritePRDescription"]
}
