{
  "version": 3,
  "sources": ["../src/list-branches.tsx", "../src/_components/list-branches/ListBranches.tsx", "../src/_lib/git/queue.ts", "../src/_lib/error-utils.ts", "../src/_constants/errors.ts", "../src/_constants/success.ts", "../src/_lib/git/commands.ts", "../src/_lib/git/branches.ts", "../src/_lib/git/repo.ts", "../src/_components/list-branches/BranchItem.tsx", "../src/_components/list-branches/useBranchActions.ts"],
  "sourcesContent": ["import { ListBranches } from \"./_components/list-branches/ListBranches\";\n\nexport default function Command() {\n  return <ListBranches />;\n}\n", "import { useState, useEffect } from \"react\";\nimport { List, showToast, Toast } from \"@raycast/api\";\nimport { getRepoPath, getBranches, getCurrentBranchName, getRepoDisplayName } from \"../../_lib/git\";\nimport { handleError } from \"../../_lib/error-utils\";\nimport { BranchItem } from \"./BranchItem\";\nimport { useBranchActions } from \"./useBranchActions\";\nimport { ERROR_MESSAGES } from \"../../_constants\";\n\nexport function ListBranches() {\n  const [branches, setBranches] = useState<{ name: string; isLocal: boolean }[]>([]);\n  const [activeBranch, setActiveBranch] = useState<string | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [repoPath, setRepoPath] = useState<string>(\"\");\n\n  const { handleCheckout, handleCleanupBranches, handleDeleteBranch, handleWritePrDescription } = useBranchActions();\n\n  useEffect(() => {\n    fetchBranches();\n  }, []);\n\n  useEffect(() => {\n    if (error) {\n      handleError(error);\n    }\n  }, [error]);\n\n  async function fetchBranches() {\n    try {\n      const path = await getRepoPath();\n      const displayName = await getRepoDisplayName();\n      setRepoPath(displayName);\n      const branches = await getBranches(path);\n      const currentBranch = await getCurrentBranchName(path);\n      setBranches(branches);\n      setActiveBranch(cleanBranchName(currentBranch));\n    } catch (error) {\n      setError(error instanceof Error ? error.message : String(error));\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  const handleCheckoutWrapper = async (branchName: string) => {\n    try {\n      await handleCheckout(branchName);\n      await fetchBranches(); // Refresh the branch list after checkout\n    } catch (error) {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: \"Checkout Failed\",\n        message: error instanceof Error ? error.message : ERROR_MESSAGES.CHECKOUT_BRANCH,\n      });\n    }\n  };\n\n  const handleCleanupBranchesWrapper = async () => {\n    try {\n      await handleCleanupBranches();\n      await fetchBranches(); // Refresh the branch list after cleanup\n    } catch (error) {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: \"Cleanup Failed\",\n        message: error instanceof Error ? error.message : ERROR_MESSAGES.CLEANUP_BRANCHES,\n      });\n    }\n  };\n\n  const handleDeleteBranchWrapper = async (branchName: string) => {\n    try {\n      await handleDeleteBranch(branchName);\n      await fetchBranches(); // Refresh the branch list after deletion\n    } catch (error) {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: \"Delete Failed\",\n        message: error instanceof Error ? error.message : ERROR_MESSAGES.DELETE_BRANCH,\n      });\n    }\n  };\n\n  return (\n    <List isLoading={isLoading} searchBarPlaceholder=\"Search branches...\">\n      <List.Section title={`Repository: ${repoPath}`}>\n        {branches.map((branch) => (\n          <BranchItem\n            key={branch.name}\n            branch={branch}\n            isActive={cleanBranchName(branch.name) === activeBranch}\n            onCheckout={handleCheckoutWrapper}\n            onWritePrDescription={handleWritePrDescription}\n            onDeleteBranch={handleDeleteBranchWrapper}\n            onCleanupBranches={handleCleanupBranchesWrapper}\n          />\n        ))}\n      </List.Section>\n    </List>\n  );\n}\n\nfunction cleanBranchName(branchName: string): string {\n  return branchName.replace(/^\\* /, \"\");\n}\n", "import { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport { handleGitError } from \"../error-utils\";\n\nconst execAsync = promisify(exec);\n\nconst gitQueue: (() => Promise<void>)[] = [];\nlet isProcessing = false;\n\nasync function processGitQueue() {\n  if (isProcessing) return;\n  isProcessing = true;\n\n  while (gitQueue.length > 0) {\n    const task = gitQueue.shift();\n    if (task) {\n      try {\n        await task();\n      } catch (error) {\n        console.error(\"Error in Git operation:\", error);\n      }\n    }\n  }\n\n  isProcessing = false;\n}\n\nexport function queueGitOperation<T>(operation: () => Promise<T>): Promise<T> {\n  return new Promise((resolve, reject) => {\n    gitQueue.push(async () => {\n      try {\n        const result = await operation();\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    });\n    processGitQueue();\n  });\n}\n\nexport async function runGitCommand(command: string, cwd: string): Promise<string> {\n  return queueGitOperation(async () => {\n    try {\n      const { stdout } = await execAsync(command, { cwd });\n      return stdout.trim();\n    } catch (error) {\n      throw handleGitError(error as Error);\n    }\n  });\n}\n", "import { Toast, popToRoot, showToast } from \"@raycast/api\";\nimport { ERROR_MESSAGES } from \"../_constants\";\n\nexport async function handleError(errorMessage: string) {\n  await popToRoot();\n  await showToast({\n    style: Toast.Style.Failure,\n    title: \"Error\",\n    message: errorMessage,\n  });\n}\n\nexport function handleGitError(error: Error): Error {\n  const errorMessage = error.message.toLowerCase();\n\n  if (errorMessage.includes(\"would be overwritten by checkout\")) {\n    return new Error(ERROR_MESSAGES.CHECKOUT_BRANCH);\n  }\n\n  if (errorMessage.includes(\"not a git repository\")) {\n    return new Error(ERROR_MESSAGES.INVALID_REPO);\n  }\n\n  if (errorMessage.includes(\"already exists\")) {\n    return new Error(ERROR_MESSAGES.BRANCH_EXISTS);\n  }\n\n  // If no specific error is matched, return the original error\n  return error;\n}\n\nexport function handleFetchAIContentError(error: Error, diffType: \"staged\" | \"baseBranch\"): never {\n  const errorMessage = error.message;\n  const knownErrors = {\n    [ERROR_MESSAGES.GIT_DIFF_EMPTY]: ERROR_MESSAGES.GIT_DIFF_EMPTY,\n    [ERROR_MESSAGES.REPO_PATH_MISSING]: ERROR_MESSAGES.REPO_PATH_MISSING,\n    [ERROR_MESSAGES.INVALID_REPO]: ERROR_MESSAGES.INVALID_REPO,\n    \"No AI model provided\": ERROR_MESSAGES.AI_MODEL_MISSING,\n    \"Invalid AI model\": ERROR_MESSAGES.AI_MODEL_INVALID,\n  };\n\n  const knownError = Object.entries(knownErrors).find(([key]) => errorMessage.includes(key));\n  if (knownError) {\n    throw new Error(knownError[1]);\n  }\n\n  throw new Error(diffType === \"staged\" ? ERROR_MESSAGES.FETCH_COMMIT_MESSAGE : ERROR_MESSAGES.FETCH_PR_DESCRIPTION);\n}\n", "export const ERROR_MESSAGES = {\n  FETCH_COMMIT_MESSAGE: \"Failed to generate commit message\",\n  COMMIT_CHANGES: \"Failed to commit changes\",\n  FETCH_PR_DESCRIPTION: \"Failed to generate PR description\",\n  REPO_PATH_MISSING: \"No repository path provided\",\n  INVALID_REPO: \"Invalid Git repository\",\n  BRANCH_EXISTS: \"Branch already exists\",\n  GIT_DIFF_EMPTY: \"No changes to commit\",\n  CHECKOUT_BRANCH: \"Failed to checkout branch\",\n  DELETE_BRANCH: \"Failed to delete branch\",\n  CLEANUP_BRANCHES: \"Failed to clean up branches\",\n  GET_CURRENT_BRANCH: \"Failed to get current branch\",\n  GET_BRANCHES: \"Failed to get branches\",\n  ACTIVE_BRANCH_DELETE: \"Cannot delete active branch\",\n  AI_MODEL_MISSING: \"No AI model provided\",\n  AI_MODEL_INVALID: \"Invalid AI model\",\n};\n", "export const SUCCESS_MESSAGES = {\n  CHECKOUT_BRANCH: (branchName: string) => `Checked out to ${branchName}`,\n  COMMIT_CHANGES: \"Changes committed to the repository\",\n  DELETE_BRANCH: (branchName: string) => `Deleted branch ${branchName}`,\n  CLEANUP_BRANCHES: \"Cleaned up branches and switched to main\",\n};\n\nexport const COMMIT_SUCCESS_MESSAGE = \"Changes committed to the repository\";\n", "import { ERROR_MESSAGES } from \"../../_constants\";\nimport { runGitCommand } from \"./queue\";\n\nexport async function getStagedGitDiff(repoPath: string): Promise<string> {\n  try {\n    let gitDiff = await runGitCommand(`git diff --staged`, repoPath);\n    if (!gitDiff) {\n      await runGitCommand(`git add .`, repoPath);\n      gitDiff = await runGitCommand(`git diff --staged`, repoPath);\n    }\n    return gitDiff;\n  } catch (error) {\n    throw new Error(ERROR_MESSAGES.GIT_DIFF_EMPTY);\n  }\n}\n\nexport async function commitChanges(repoPath: string, commitMessage: string): Promise<void> {\n  await runGitCommand(`git commit -m \"${commitMessage}\"`, repoPath);\n}\n\nexport async function getCurrentBranchName(repoPath: string): Promise<string> {\n  return runGitCommand(`git rev-parse --abbrev-ref HEAD`, repoPath);\n}\n\nexport async function getDiffComparedToBranch(repoPath: string, baseBranch: string): Promise<string> {\n  return runGitCommand(`git diff ${baseBranch}`, repoPath);\n}\n", "import { runGitCommand } from \"./queue\";\nimport { ERROR_MESSAGES } from \"../../_constants\";\n\ninterface Branch {\n  name: string;\n  isLocal: boolean;\n  isActive?: boolean;\n}\n\nasync function fetchAllBranches(repoPath: string): Promise<void> {\n  await runGitCommand(`git fetch --all`, repoPath);\n}\n\nasync function getBranchesOutput(repoPath: string): Promise<string> {\n  return runGitCommand(`git branch -a`, repoPath);\n}\n\nfunction parseBranches(branchesOutput: string): Branch[] {\n  const branches = branchesOutput\n    .split(\"\\n\")\n    .map((branch) => branch.trim())\n    .filter((branch) => branch && !branch.includes(\" -> \"));\n\n  const remoteBranches = branches\n    .filter((branch) => branch.startsWith(\"remotes/\"))\n    .map((branch) => branch.replace(\"remotes/origin/\", \"\"));\n\n  return branches\n    .map((branch) => {\n      const isActive = branch.startsWith(\"* \");\n      const name = branch.replace(\"* \", \"\").replace(\"remotes/origin/\", \"\");\n      const isLocal = !remoteBranches.includes(name);\n      return { name, isLocal, isActive };\n    })\n    .filter((branch, index, self) => index === self.findIndex((b) => b.name === branch.name));\n}\n\nfunction removeDuplicateBranches(branches: Branch[]): Branch[] {\n  return Array.from(new Set(branches.map((b) => b.name)))\n    .map((name) => branches.find((b) => b.name === name))\n    .filter((b): b is Branch => b !== undefined);\n}\n\nfunction prioritizeActiveBranch(branches: Branch[]): Branch[] {\n  const activeBranchIndex = branches.findIndex((b) => b.isActive);\n  if (activeBranchIndex > -1) {\n    const [activeBranch] = branches.splice(activeBranchIndex, 1);\n    branches.unshift(activeBranch);\n  }\n  return branches;\n}\n\nexport async function getBranches(repoPath: string): Promise<Branch[]> {\n  await fetchAllBranches(repoPath);\n  const branchesOutput = await getBranchesOutput(repoPath);\n  const parsedBranches = parseBranches(branchesOutput);\n  const uniqueBranches = removeDuplicateBranches(parsedBranches);\n  return prioritizeActiveBranch(uniqueBranches);\n}\n\nexport async function checkoutBranch(repoPath: string, branchName: string): Promise<void> {\n  await runGitCommand(`git checkout ${branchName}`, repoPath);\n}\n\nexport async function cleanupBranches(repoPath: string): Promise<void> {\n  await runGitCommand(\n    `\n    git checkout main &&\n    git fetch --prune &&\n    git pull &&\n    git branch -vv | awk '/: gone]/{print $1}' | xargs git branch -d\n  `,\n    repoPath,\n  );\n}\n\nexport async function deleteBranch(repoPath: string, branchName: string): Promise<void> {\n  const currentBranch = await runGitCommand(`git rev-parse --abbrev-ref HEAD`, repoPath);\n  if (currentBranch === branchName) {\n    throw new Error(ERROR_MESSAGES.ACTIVE_BRANCH_DELETE);\n  }\n\n  await runGitCommand(`git branch -D ${branchName}`, repoPath);\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { ERROR_MESSAGES } from \"../../_constants\";\nimport { runGitCommand } from \"./queue\";\nimport path from \"path\";\n\nasync function isValidRepo(repoPath: string): Promise<boolean> {\n  try {\n    const result = await runGitCommand(`git rev-parse --is-inside-work-tree`, repoPath);\n    return result === \"true\";\n  } catch {\n    return false;\n  }\n}\n\nexport async function getRepoPath(): Promise<string> {\n  const preferences = await getPreferenceValues<{ \"repo-path\": string }>();\n  const repoPath = preferences[\"repo-path\"];\n  if (!repoPath) {\n    throw new Error(ERROR_MESSAGES.REPO_PATH_MISSING);\n  }\n  if (!(await isValidRepo(repoPath))) {\n    throw new Error(ERROR_MESSAGES.INVALID_REPO);\n  }\n  return repoPath;\n}\n\nexport async function getRepoDisplayName(): Promise<string> {\n  const repoPath = await getRepoPath();\n  return path.basename(repoPath);\n}\n", "import { List, ActionPanel, Action, Icon } from \"@raycast/api\";\n\ninterface BranchItemProps {\n  branch: { name: string; isLocal: boolean };\n  isActive: boolean;\n  onCheckout: (branchName: string) => void;\n  onWritePrDescription: (branchName: string) => void;\n  onDeleteBranch: (branchName: string) => void;\n  onCleanupBranches: () => void;\n}\n\nexport function BranchItem({\n  branch,\n  isActive,\n  onCheckout,\n  onWritePrDescription,\n  onDeleteBranch,\n  onCleanupBranches,\n}: BranchItemProps) {\n  const cleanedBranch = branch.name.replace(/^\\* /, \"\");\n  const accessories = [];\n\n  if (isActive) {\n    accessories.push({ text: \"\uD83D\uDFE2 Active Branch\" });\n  }\n\n  if (branch.isLocal) {\n    accessories.push({ text: \"\u26A0\uFE0E Untracked\" });\n  }\n\n  return (\n    <List.Item\n      title={cleanedBranch}\n      accessories={accessories}\n      actions={\n        <ActionPanel>\n          <Action title=\"Checkout Branch\" onAction={() => onCheckout(cleanedBranch)} icon={Icon.ArrowRightCircle} />\n          <Action\n            title=\"Write PR Description \u2192 This Branch\"\n            onAction={() => onWritePrDescription(cleanedBranch)}\n            icon={Icon.Pencil}\n          />\n          <Action.CopyToClipboard\n            title=\"Copy Branch Name\"\n            content={cleanedBranch}\n            shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"c\" }}\n            icon={Icon.CopyClipboard}\n          />\n          <Action\n            title=\"Delete Branch\"\n            onAction={() => onDeleteBranch(cleanedBranch)}\n            icon={Icon.Trash}\n            shortcut={{ modifiers: [\"cmd\"], key: \"backspace\" }}\n          />\n          <Action\n            title=\"Clean Up Branches\"\n            onAction={onCleanupBranches}\n            icon={Icon.Eraser}\n            shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"b\" }}\n          />\n        </ActionPanel>\n      }\n    />\n  );\n}\n", "import { showToast, popToRoot, launchCommand, LaunchType } from \"@raycast/api\";\nimport { getRepoPath, checkoutBranch, deleteBranch, cleanupBranches } from \"../../_lib/git\";\nimport { handleGitError } from \"../../_lib/error-utils\";\nimport { SUCCESS_MESSAGES } from \"../../_constants\";\n\nexport function useBranchActions() {\n  async function handleCheckout(branchName: string) {\n    try {\n      const repoPath = await getRepoPath();\n      await checkoutBranch(repoPath, branchName);\n      await showToast({ title: \"Success\", message: SUCCESS_MESSAGES.CHECKOUT_BRANCH(branchName) });\n      await popToRoot();\n    } catch (error) {\n      console.error(\"Checkout error:\", error);\n      throw handleGitError(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  async function handleCleanupBranches() {\n    try {\n      const repoPath = await getRepoPath();\n      await cleanupBranches(repoPath);\n      await showToast({ title: \"Success\", message: SUCCESS_MESSAGES.CLEANUP_BRANCHES });\n    } catch (error) {\n      console.error(\"Cleanup error:\", error);\n      throw handleGitError(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  async function handleDeleteBranch(branchName: string) {\n    try {\n      const repoPath = await getRepoPath();\n      await deleteBranch(repoPath, branchName);\n      await showToast({ title: \"Success\", message: SUCCESS_MESSAGES.DELETE_BRANCH(branchName) });\n    } catch (error) {\n      console.error(\"Delete branch error:\", error);\n      throw handleGitError(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  async function handleWritePrDescription(branchName: string) {\n    await launchCommand({\n      name: \"write-pr-description\",\n      type: LaunchType.UserInitiated,\n      context: { baseBranch: branchName },\n    });\n  }\n\n  return {\n    handleCheckout,\n    handleCleanupBranches,\n    handleDeleteBranch,\n    handleWritePrDescription,\n  };\n}\n"],
  "mappings": "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",
  "names": ["list_branches_exports", "__export", "Command", "__toCommonJS", "import_react", "import_api", "import_child_process", "import_util", "import_api", "ERROR_MESSAGES", "SUCCESS_MESSAGES", "branchName", "handleError", "errorMessage", "handleGitError", "error", "ERROR_MESSAGES", "execAsync", "gitQueue", "isProcessing", "processGitQueue", "task", "error", "queueGitOperation", "operation", "resolve", "reject", "result", "runGitCommand", "command", "cwd", "stdout", "handleGitError", "getCurrentBranchName", "repoPath", "runGitCommand", "fetchAllBranches", "repoPath", "runGitCommand", "getBranchesOutput", "parseBranches", "branchesOutput", "branches", "branch", "remoteBranches", "isActive", "name", "isLocal", "index", "self", "b", "removeDuplicateBranches", "prioritizeActiveBranch", "activeBranchIndex", "activeBranch", "getBranches", "parsedBranches", "uniqueBranches", "checkoutBranch", "branchName", "cleanupBranches", "deleteBranch", "ERROR_MESSAGES", "import_api", "import_path", "isValidRepo", "repoPath", "runGitCommand", "getRepoPath", "ERROR_MESSAGES", "getRepoDisplayName", "path", "import_api", "import_jsx_runtime", "BranchItem", "branch", "isActive", "onCheckout", "onWritePrDescription", "onDeleteBranch", "onCleanupBranches", "cleanedBranch", "accessories", "import_api", "useBranchActions", "handleCheckout", "branchName", "repoPath", "getRepoPath", "checkoutBranch", "SUCCESS_MESSAGES", "error", "handleGitError", "handleCleanupBranches", "cleanupBranches", "handleDeleteBranch", "deleteBranch", "handleWritePrDescription", "import_jsx_runtime", "ListBranches", "branches", "setBranches", "activeBranch", "setActiveBranch", "error", "setError", "isLoading", "setIsLoading", "repoPath", "setRepoPath", "handleCheckout", "handleCleanupBranches", "handleDeleteBranch", "handleWritePrDescription", "useBranchActions", "fetchBranches", "handleError", "path", "getRepoPath", "displayName", "getRepoDisplayName", "getBranches", "currentBranch", "getCurrentBranchName", "cleanBranchName", "handleCheckoutWrapper", "branchName", "ERROR_MESSAGES", "handleCleanupBranchesWrapper", "handleDeleteBranchWrapper", "branch", "BranchItem", "import_jsx_runtime", "Command", "ListBranches"]
}
