"use strict";var q=Object.create;var A=Object.defineProperty;var Q=Object.getOwnPropertyDescriptor;var X=Object.getOwnPropertyNames;var z=Object.getPrototypeOf,J=Object.prototype.hasOwnProperty;var Z=(t,e)=>{for(var r in e)A(t,r,{get:e[r],enumerable:!0})},N=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of X(e))!J.call(t,i)&&i!==r&&A(t,i,{get:()=>e[i],enumerable:!(n=Q(e,i))||n.enumerable});return t};var j=(t,e,r)=>(r=t!=null?q(z(t)):{},N(e||!t||!t.__esModule?A(r,"default",{value:t,enumerable:!0}):r,t)),tt=t=>N(A({},"__esModule",{value:!0}),t);var mt={};Z(mt,{default:()=>U});module.exports=tt(mt);var C=require("@raycast/api");var p=require("react");var u=require("@raycast/api");var v=require("child_process"),b=require("util");var h=require("@raycast/api");var o={FETCH_COMMIT_MESSAGE:"Failed to generate commit message",COMMIT_CHANGES:"Failed to commit changes",FETCH_PR_DESCRIPTION:"Failed to generate PR description",REPO_PATH_MISSING:"No repository path provided",INVALID_REPO:"Invalid Git repository",BRANCH_EXISTS:"Branch already exists",GIT_DIFF_EMPTY:"No changes to commit",CHECKOUT_BRANCH:"Failed to checkout branch",DELETE_BRANCH:"Failed to delete branch",CLEANUP_BRANCHES:"Failed to clean up branches",GET_CURRENT_BRANCH:"Failed to get current branch",GET_BRANCHES:"Failed to get branches",ACTIVE_BRANCH_DELETE:"Cannot delete active branch",AI_MODEL_MISSING:"No AI model provided",AI_MODEL_INVALID:"Invalid AI model"};var G="Changes committed to the repository";var O='Please write a commit message given the provided diff. The commit message should be a short description in the present tense and imperative form, as if giving a command. For example, "Add Button component" or "Fix issue with login form validation". IMPORTANT: The entire generated message should be 50 characters or less. Diff: ';async function M(t){await(0,h.popToRoot)(),await(0,h.showToast)({style:h.Toast.Style.Failure,title:"Error",message:t})}function D(t){let e=t.message.toLowerCase();return e.includes("would be overwritten by checkout")?new Error(o.CHECKOUT_BRANCH):e.includes("not a git repository")?new Error(o.INVALID_REPO):e.includes("already exists")?new Error(o.BRANCH_EXISTS):t}function x(t,e){let r=t.message,n={[o.GIT_DIFF_EMPTY]:o.GIT_DIFF_EMPTY,[o.REPO_PATH_MISSING]:o.REPO_PATH_MISSING,[o.INVALID_REPO]:o.INVALID_REPO,"No AI model provided":o.AI_MODEL_MISSING,"Invalid AI model":o.AI_MODEL_INVALID},i=Object.entries(n).find(([c])=>r.includes(c));throw i?new Error(i[1]):new Error(e==="staged"?o.FETCH_COMMIT_MESSAGE:o.FETCH_PR_DESCRIPTION)}var et=(0,b.promisify)(v.exec),P=[],_=!1;async function rt(){if(!_){for(_=!0;P.length>0;){let t=P.shift();if(t)try{await t()}catch(e){console.error("Error in Git operation:",e)}}_=!1}}function ot(t){return new Promise((e,r)=>{P.push(async()=>{try{let n=await t();e(n)}catch(n){r(n)}}),rt()})}async function a(t,e){return ot(async()=>{try{let{stdout:r}=await et(t,{cwd:e});return r.trim()}catch(r){throw D(r)}})}async function R(t){try{let e=await a("git diff --staged",t);return e||(await a("git add .",t),e=await a("git diff --staged",t)),e}catch{throw new Error(o.GIT_DIFF_EMPTY)}}async function T(t,e){await a(`git commit -m "${e}"`,t)}async function l(t){return a("git rev-parse --abbrev-ref HEAD",t)}async function y(t,e){return a(`git diff ${e}`,t)}var F=require("@raycast/api");var H=j(require("path"));async function nt(t){try{return await a("git rev-parse --is-inside-work-tree",t)==="true"}catch{return!1}}async function m(){let e=(await(0,F.getPreferenceValues)())["repo-path"];if(!e)throw new Error(o.REPO_PATH_MISSING);if(!await nt(e))throw new Error(o.INVALID_REPO);return e}async function B(){let t=await m();return H.default.basename(t)}var it="medium";async function at(t){let r=(await(0,u.getPreferenceValues)())[t];if(!r)throw new Error("No AI model provided");let n=u.AI.Model[r];if(!n)throw new Error(`Invalid AI model: ${r}`);return n}async function st({diffType:t,repoPath:e,baseBranch:r}){if(t==="staged")return await R(e);if(t==="baseBranch"&&r)return await y(e,r);throw new Error("Invalid diffType or missing baseBranch")}async function L(t){let{diffType:e,aiModelName:r,aiPrompt:n,baseBranch:i}=t;try{let c=await m(),d=await st({diffType:e,repoPath:c,baseBranch:i});if(!d)throw new Error(o.GIT_DIFF_EMPTY);let f=await at(r),w=await u.AI.ask(`${n}${d}`,{model:f,creativity:it}),I=await l(c);return{aiContent:w,branchName:I}}catch(c){x(c,e)}}function k(){let[t,e]=(0,p.useState)(null),[r,n]=(0,p.useState)(null),[i,c]=(0,p.useState)(null),[d,f]=(0,p.useState)(!0);(0,p.useEffect)(()=>{w()},[]);async function w(){try{let I=await m(),{aiContent:W}=await L({diffType:"staged",aiModelName:"commit-message-ai-model",aiPrompt:O}),K=ct(W);e(K),c(await l(I))}catch{n(o.FETCH_COMMIT_MESSAGE)}finally{f(!1)}}return{commitMessage:t,error:r,branchName:i,isLoading:d}}function ct(t){return t.replace(/[`"'.,]/g,"")}var s=require("@raycast/api");var E=require("react/jsx-runtime");function V({commitMessage:t,branchName:e,onError:r}){async function n(){try{let i=await m();i&&t&&await T(i,t),await(0,s.popToRoot)({clearSearchBar:!0}),await(0,s.showToast)({title:"Changes committed",message:G})}catch{r(o.COMMIT_CHANGES)}}return(0,E.jsxs)(s.ActionPanel,{title:e?`Active Branch: ${e}`:void 0,children:[(0,E.jsx)(s.Action,{title:"Commit Changes",onAction:n,autoFocus:!0,icon:s.Icon.CheckCircle}),(0,E.jsx)(s.Action.CopyToClipboard,{title:"Copy Commit Message",content:t,shortcut:{modifiers:["cmd","shift"],key:"c"}})]})}var S=require("react");var g=require("react/jsx-runtime");function $(){let{commitMessage:t,error:e,branchName:r,isLoading:n}=k(),[i,c]=(0,S.useState)("");(0,S.useEffect)(()=>{d(),e&&M(e)},[e]);async function d(){let f=await B();c(f)}return(0,g.jsx)(C.Detail,{markdown:t||"Generating commit message...",metadata:r&&t?(0,g.jsxs)(C.Detail.Metadata,{children:[(0,g.jsx)(C.Detail.Metadata.Label,{title:"Repository",text:i}),(0,g.jsx)(C.Detail.Metadata.Label,{title:"Active Branch",text:r})]}):null,actions:t?(0,g.jsx)(V,{commitMessage:t,branchName:r,onError:f=>M(f)}):null,isLoading:n})}var Y=require("react/jsx-runtime");function U(){return(0,Y.jsx)($,{})}
