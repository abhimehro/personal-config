"use strict";var re=Object.create;var S=Object.defineProperty;var te=Object.getOwnPropertyDescriptor;var ne=Object.getOwnPropertyNames;var oe=Object.getPrototypeOf,ie=Object.prototype.hasOwnProperty;var ae=(e,r)=>{for(var t in r)S(e,t,{get:r[t],enumerable:!0})},x=(e,r,t,o)=>{if(r&&typeof r=="object"||typeof r=="function")for(let n of ne(r))!ie.call(e,n)&&n!==t&&S(e,n,{get:()=>r[n],enumerable:!(o=te(r,n))||o.enumerable});return e};var se=(e,r,t)=>(t=e!=null?re(oe(e)):{},x(r||!e||!e.__esModule?S(t,"default",{value:e,enumerable:!0}):t,e)),ce=e=>x(S({},"__esModule",{value:!0}),e);var Ce={};ae(Ce,{default:()=>V});module.exports=ce(Ce);var d=require("react"),l=require("@raycast/api");var O=require("child_process"),G=require("util");var E=require("@raycast/api");var c={FETCH_COMMIT_MESSAGE:"Failed to generate commit message",COMMIT_CHANGES:"Failed to commit changes",FETCH_PR_DESCRIPTION:"Failed to generate PR description",REPO_PATH_MISSING:"No repository path provided",INVALID_REPO:"Invalid Git repository",BRANCH_EXISTS:"Branch already exists",GIT_DIFF_EMPTY:"No changes to commit",CHECKOUT_BRANCH:"Failed to checkout branch",DELETE_BRANCH:"Failed to delete branch",CLEANUP_BRANCHES:"Failed to clean up branches",GET_CURRENT_BRANCH:"Failed to get current branch",GET_BRANCHES:"Failed to get branches",ACTIVE_BRANCH_DELETE:"Cannot delete active branch",AI_MODEL_MISSING:"No AI model provided",AI_MODEL_INVALID:"Invalid AI model"};var A={CHECKOUT_BRANCH:e=>`Checked out to ${e}`,COMMIT_CHANGES:"Changes committed to the repository",DELETE_BRANCH:e=>`Deleted branch ${e}`,CLEANUP_BRANCHES:"Cleaned up branches and switched to main"};async function M(e){await(0,E.popToRoot)(),await(0,E.showToast)({style:E.Toast.Style.Failure,title:"Error",message:e})}function C(e){let r=e.message.toLowerCase();return r.includes("would be overwritten by checkout")?new Error(c.CHECKOUT_BRANCH):r.includes("not a git repository")?new Error(c.INVALID_REPO):r.includes("already exists")?new Error(c.BRANCH_EXISTS):e}var he=(0,G.promisify)(O.exec),I=[],P=!1;async function me(){if(!P){for(P=!0;I.length>0;){let e=I.shift();if(e)try{await e()}catch(r){console.error("Error in Git operation:",r)}}P=!1}}function le(e){return new Promise((r,t)=>{I.push(async()=>{try{let o=await e();r(o)}catch(o){t(o)}}),me()})}async function h(e,r){return le(async()=>{try{let{stdout:t}=await he(e,{cwd:r});return t.trim()}catch(t){throw C(t)}})}async function R(e){return h("git rev-parse --abbrev-ref HEAD",e)}async function pe(e){await h("git fetch --all",e)}async function ue(e){return h("git branch -a",e)}function de(e){let r=e.split(`
`).map(o=>o.trim()).filter(o=>o&&!o.includes(" -> ")),t=r.filter(o=>o.startsWith("remotes/")).map(o=>o.replace("remotes/origin/",""));return r.map(o=>{let n=o.startsWith("* "),i=o.replace("* ","").replace("remotes/origin/",""),m=!t.includes(i);return{name:i,isLocal:m,isActive:n}}).filter((o,n,i)=>n===i.findIndex(m=>m.name===o.name))}function fe(e){return Array.from(new Set(e.map(r=>r.name))).map(r=>e.find(t=>t.name===r)).filter(r=>r!==void 0)}function ge(e){let r=e.findIndex(t=>t.isActive);if(r>-1){let[t]=e.splice(r,1);e.unshift(t)}return e}async function _(e){await pe(e);let r=await ue(e),t=de(r),o=fe(t);return ge(o)}async function T(e,r){await h(`git checkout ${r}`,e)}async function N(e){await h(`
    git checkout main &&
    git fetch --prune &&
    git pull &&
    git branch -vv | awk '/: gone]/{print $1}' | xargs git branch -d
  `,e)}async function D(e,r){if(await h("git rev-parse --abbrev-ref HEAD",e)===r)throw new Error(c.ACTIVE_BRANCH_DELETE);await h(`git branch -D ${r}`,e)}var L=require("@raycast/api");var b=se(require("path"));async function Ee(e){try{return await h("git rev-parse --is-inside-work-tree",e)==="true"}catch{return!1}}async function f(){let r=(await(0,L.getPreferenceValues)())["repo-path"];if(!r)throw new Error(c.REPO_PATH_MISSING);if(!await Ee(r))throw new Error(c.INVALID_REPO);return r}async function v(){let e=await f();return b.default.basename(e)}var s=require("@raycast/api"),u=require("react/jsx-runtime");function H({branch:e,isActive:r,onCheckout:t,onWritePrDescription:o,onDeleteBranch:n,onCleanupBranches:i}){let m=e.name.replace(/^\* /,""),B=[];return r&&B.push({text:"\u{1F7E2} Active Branch"}),e.isLocal&&B.push({text:"\u26A0\uFE0E Untracked"}),(0,u.jsx)(s.List.Item,{title:m,accessories:B,actions:(0,u.jsxs)(s.ActionPanel,{children:[(0,u.jsx)(s.Action,{title:"Checkout Branch",onAction:()=>t(m),icon:s.Icon.ArrowRightCircle}),(0,u.jsx)(s.Action,{title:"Write PR Description \u2192 This Branch",onAction:()=>o(m),icon:s.Icon.Pencil}),(0,u.jsx)(s.Action.CopyToClipboard,{title:"Copy Branch Name",content:m,shortcut:{modifiers:["cmd","shift"],key:"c"},icon:s.Icon.CopyClipboard}),(0,u.jsx)(s.Action,{title:"Delete Branch",onAction:()=>n(m),icon:s.Icon.Trash,shortcut:{modifiers:["cmd"],key:"backspace"}}),(0,u.jsx)(s.Action,{title:"Clean Up Branches",onAction:i,icon:s.Icon.Eraser,shortcut:{modifiers:["cmd","shift"],key:"b"}})]})})}var p=require("@raycast/api");function k(){async function e(n){try{let i=await f();await T(i,n),await(0,p.showToast)({title:"Success",message:A.CHECKOUT_BRANCH(n)}),await(0,p.popToRoot)()}catch(i){throw console.error("Checkout error:",i),C(i instanceof Error?i:new Error(String(i)))}}async function r(){try{let n=await f();await N(n),await(0,p.showToast)({title:"Success",message:A.CLEANUP_BRANCHES})}catch(n){throw console.error("Cleanup error:",n),C(n instanceof Error?n:new Error(String(n)))}}async function t(n){try{let i=await f();await D(i,n),await(0,p.showToast)({title:"Success",message:A.DELETE_BRANCH(n)})}catch(i){throw console.error("Delete branch error:",i),C(i instanceof Error?i:new Error(String(i)))}}async function o(n){await(0,p.launchCommand)({name:"write-pr-description",type:p.LaunchType.UserInitiated,context:{baseBranch:n}})}return{handleCheckout:e,handleCleanupBranches:r,handleDeleteBranch:t,handleWritePrDescription:o}}var y=require("react/jsx-runtime");function U(){let[e,r]=(0,d.useState)([]),[t,o]=(0,d.useState)(null),[n,i]=(0,d.useState)(null),[m,B]=(0,d.useState)(!0),[$,K]=(0,d.useState)(""),{handleCheckout:Y,handleCleanupBranches:q,handleDeleteBranch:Q,handleWritePrDescription:X}=k();(0,d.useEffect)(()=>{w()},[]),(0,d.useEffect)(()=>{n&&M(n)},[n]);async function w(){try{let a=await f(),g=await v();K(g);let j=await _(a),ee=await R(a);r(j),o(F(ee))}catch(a){i(a instanceof Error?a.message:String(a))}finally{B(!1)}}let z=async a=>{try{await Y(a),await w()}catch(g){await(0,l.showToast)({style:l.Toast.Style.Failure,title:"Checkout Failed",message:g instanceof Error?g.message:c.CHECKOUT_BRANCH})}},J=async()=>{try{await q(),await w()}catch(a){await(0,l.showToast)({style:l.Toast.Style.Failure,title:"Cleanup Failed",message:a instanceof Error?a.message:c.CLEANUP_BRANCHES})}},Z=async a=>{try{await Q(a),await w()}catch(g){await(0,l.showToast)({style:l.Toast.Style.Failure,title:"Delete Failed",message:g instanceof Error?g.message:c.DELETE_BRANCH})}};return(0,y.jsx)(l.List,{isLoading:m,searchBarPlaceholder:"Search branches...",children:(0,y.jsx)(l.List.Section,{title:`Repository: ${$}`,children:e.map(a=>(0,y.jsx)(H,{branch:a,isActive:F(a.name)===t,onCheckout:z,onWritePrDescription:X,onDeleteBranch:Z,onCleanupBranches:J},a.name))})})}function F(e){return e.replace(/^\* /,"")}var W=require("react/jsx-runtime");function V(){return(0,W.jsx)(U,{})}
